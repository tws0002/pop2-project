// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Creation Date:  December 8/2000
//
// Description:
//
//		This file contains the procedures which create and manipulate the
//		Hypershade panel UI.
//
source hyperViewer;
source propertyPanel;
global int $gHypershadeInitialBrowserHeight = 236;
global string $gPreviousFilterBox = "";
global string $gPreviousFilterButton = "";
global string $gLookdevSelectionArray[];
global string $gShaderBallEditor = "";
global string $gShaderBallRendererMenu = "";
global string $gHypershadePropertyPanelRoot;
global string $gHypershadeEnvironmentEditor = "";
global string $gLookdevCustomEnvironments[];
global string $gHardwareMenu = "";
$gHardwareMenu = (uiRes("m_hyperShadePanel.kHWRender"));

global string $gLookdevCreatePanel = "LookdevCreatePanel";
global string $gLookdevBinsPanel = "LookdevBinsPanel";
global string $gLookdevBrowserPanel = "LookdevBrowserPanel";
global string $gLookdevPropertyPanel = "LookdevPropertyPanel";
global string $gLookdevShaderballPanel = "LookdevShaderballPanel";
global string $gLookdevModelEditorPanel = "LookdevModelEditorPanel";
global string $gLookdevSpreadsheetPanel = "LookdevSpreadsheetPanel";
global string $gLookdevRenderViewPanel = "LookdevRenderViewPanel";
global string $gLookdevOutlinerPanel = "LookdevOutlinerPanel";
global string $gLookdevUVEditorPanel = "LookdevUVEditorPanel";
global string $gLookdevGraphEditorPanel = "LookdevGraphEditorPanel";

// This script is sourced at startup by initScriptedPanels.mel. We will take
// this opportunity to ensure that the option vars related to node creation (ie
// with/without placement, as normal/projection/stencil...) exist.
//
initCreateNodeOptionVars();

// Initialize the optionVar which specifies which tab sections are to be shown,
// if it does not already exist.
//
if (!`optionVar -exists hyperShadePanelTabSectionsShown`)
{
	optionVar
		-stringValue
			hyperShadePanelTabSectionsShown
			"showTopAndBottomTabs";
}

// Initialize the optionVar which specifies whether the create bar is to be
// shown, if the optionVar does not already exist.
//
if (!`optionVar -exists hyperShadePanelCreateBarShown`)
{
	optionVar -intValue hyperShadePanelCreateBarShown true;
}

// Initialize the optionVar which specified how wide the create bar should be
// when in icons and text mode, if the optionVar does not already exist.
//
if (!`optionVar -exists hyperShadePanelCreateBarIconsAndTextWidth`)
{
	optionVar
		-intValue
			hyperShadePanelCreateBarIconsAndTextWidth 172;
}

// Initialize the optionVar which specifies whether to clear before graphing,
// if it does not already exist.
//
if (!`optionVar -exists hsClearBeforeGraphing`)
{
	optionVar -intValue hsClearBeforeGraphing true;
}

// Initialize the optionVar which specifies wheather to draw relationship connections,
// if it does not already exist.
if (!`optionVar -exists hsShowRelationships`)
{
	optionVar -intValue hsShowRelationships true;
}

// Initialize the optionVar which specifies whether to merge connections,
// if it does not already exist.
if (!`optionVar -exists hsMergeConnections`)
{
	optionVar -intValue hsMergeConnections true;
}

// Initialize the optionVar which specifies whether to draw container backgrounds as opaque,
// if it does not already exist.
if (!`optionVar -exists hsOpaqueContainers`)
{
	optionVar -intValue hsOpaqueContainers false;
}


if (!`scriptedPanelType -exists hyperShadePanel`)
//
// If you change this, you must also change the one in
// initScriptedPanels.mel
//
{
	//
	//  Define the callbacks for the shader editor panel.
	//
	scriptedPanelType
		-createCallback		"createHyperShadePanel"
		-initCallback		"initHyperShadePanel"
		-addCallback		"addHyperShadePanel"
		-removeCallback		"removeHyperShadePanel"
		-saveStateCallback	"saveStateHyperShadePanel"
		-deleteCallback		"deleteHyperShadePanel"
		-unique true
		hyperShadePanel;

}

// Description:  This procedure is used to get icon size for a scene
//      tab.
//      If there is no icon size stored in the preferences, then
//      make medium size the default and store it in a preference.
//
proc string getIconSize(string $optionVar)
{
    string $iconSize = "mediumIcons";
    if (`optionVar -exists ($optionVar+"IconSize")`)
    {
        $iconSize = `optionVar -query ($optionVar+"IconSize")`;
    }
    else
    {
        optionVar -stringValue ($optionVar+"IconSize") $iconSize;
    }
    return $iconSize;
}

global proc string hyperShadePanelName()
//
// Description:
//	This procedure returns the name of the panel containing the
//	shader editor.
//	If there is no shader editor in existence, the behaviour of this
//	procedure is undefined.
//
//	ASSUMPTION: This procedure assumes there is a maximum of one
//	shader editor open.
//
{
	string $hyperShadePanels[] =
		`getPanel -scriptType "hyperShadePanel"`;

	return $hyperShadePanels[0];
}

// ---------------------------------------------------------------------------
// 	Registry to record tabs and their associated libraryUI, graphUI and
// 	collectionUI components.
//

global string $gHyperShadePanelLookupTable[];
global int $gHyperShadePanelLookupTableCreated = false;

proc createHyperShadePanelLookupTable()
{
	//
	// Description:
	//	This procedure initializes the string array
	//	$gHyperShadePanelLookupTable[] for use as a lookup table. The lookup
	//	table will contain information about the tabs of the hypershade panel,
	//	and the UI contained within them.
	//

	global string $gHyperShadePanelLookupTable[];
	global int $gHyperShadePanelLookupTableCreated;

	if (!$gHyperShadePanelLookupTableCreated)
	{
		string $columns[];

		$columns[0] = "tab";
		$columns[1] = "type";
		$columns[2] = "componentName";
		$columns[3] = "optionVar";
		$columns[4] = "tabLayout";

		lookupTable($gHyperShadePanelLookupTable, $columns);
		$gHyperShadePanelLookupTableCreated = true;
	}
}

proc registerTab(
	string $tab,
	string $type,
	string $libraryUI,
	string $optionVar,
    string $tabLayout)
{
	//
	// Description:
	//	This procedure enters information about the specified tab into the
	//	lookup table that contains information about all of the tabs in the
	//	hypershade panel.
	//

	if (	($type != "disk")
		&& 	($type != "graph")
		&& 	($type != "protected graph")
		&& 	($type != "scene") )
	{
		error
			-showLineNumber true
			(uiRes("m_hyperShadePanel.kUnrecognizedTabTypeRegisterError"));
	}

	global string $gHyperShadePanelLookupTable[];
	string $row[];

	$row[0] = $tab;
	$row[1] = $type;
	$row[2] = $libraryUI;
	$row[3] = $optionVar;
	$row[4] = $tabLayout;

	lookupTableAddRow($gHyperShadePanelLookupTable, $row);
}

proc unregisterTab(
	string $tab)
{
	//
	// Description:
	//	This procedure removes information about the specified tab from the
	//	lookup table.
	//

	global string $gHyperShadePanelLookupTable[];

	lookupTableRemoveRow(
		$gHyperShadePanelLookupTable,
		"tab",
		$tab);
}

proc string lookupComponentName(
	string $tab)
{
	//
	// Description:
	//	This procedure uses the lookup table to look up the name of the
	//	UI component (ie libraryUI, collectionUI or graphUI) associated with
	// 	the specified tab.
	//
	// Returns:
	//	The name of the UI component associated with the specified tab.
	//

	global string $gHyperShadePanelLookupTable[];

	return lookupTableLookup(
		$gHyperShadePanelLookupTable,
		"tab",
		$tab,
		"componentName");
}

proc string lookupTabLayoutName(
    string $componentName)
{
    //
    // Description:
    //  This procedure uses the lookup table to look up the name of the
    //  tabLayout (firstPaneTabs or secondPaneTabs) associated with
    //  the specified componentName.
    //

	global string $gHyperShadePanelLookupTable[];

	return lookupTableLookup(
		$gHyperShadePanelLookupTable,
		"componentName",
		$componentName,
		"tabLayout");
}

proc updateComponentNameInTabRegistry(
	string $tab, string $componentName)
{
	//
	// Description:
	//	This procedure edit the lookup table to update the
    //  componentName for the specified tab.
	//
	//

	global string $gHyperShadePanelLookupTable[];

	lookupTableEdit(
		$gHyperShadePanelLookupTable,
		"tab",
		$tab,
		"componentName",
        $componentName);
}

proc string lookupTabOptionVar(
	string $tab)
{
	//
	// Description:
	//	This procedure uses the lookup table to look up the name of the
	//	optionVar which stores information about the specified tab. The
	//	information stored in these optionVars is used to recreate tabs with
	//	the same characteristics in subsequent Maya sessions, and also to
	//	recreate tabs when the panel is torn off into a window.
	//
	// Returns:
	//	The name of the optionVar associated with the specified tab.
	//

	global string $gHyperShadePanelLookupTable[];

	return lookupTableLookup(
		$gHyperShadePanelLookupTable,
		"tab",
		$tab,
		"optionVar");
}

proc string lookupOptionVarTab(
	string $optionVar)
{
	//
	// Description:
	//	This procedure uses the lookup table to look up the name of the tab
	//	associated with the specified optionVar.
	//
	// Returns:
	//	The name of the tab associated with the specified optionVar.
	//

	global string $gHyperShadePanelLookupTable[];

	return lookupTableLookup(
		$gHyperShadePanelLookupTable,
		"optionVar",
		$optionVar,
		"tab");
}

proc string lookupTabType(
	string $tab)
{
	//
	// Description:
	//	This procedure uses the lookup table to look up the type (disk, scene,
	//	graph, protected graph) of the specified tab.
	//
	// Returns:
	//	The type of the specified tab.
	//

    if ($tab == "")
    {
        return "";
    }

	global string $gHyperShadePanelLookupTable[];

	return lookupTableLookup(
		$gHyperShadePanelLookupTable,
		"tab",
		$tab,
		"type");
}

proc int isDiskTab(
	string $tab)
{
	//
	// Description:
	//	This procedure is used to query whether the specified tab is a disk
	//	tab.
	//
	// Returns:
	//	True if the tab is a disk tab, false if not.
	//

	global string $gHyperShadePanelLookupTable[];

	return (lookupTabType($tab) == "disk");
}

proc int isGraphTab(
	string $tab)
{
	//
	// Description:
	//	This procedure is used to query whether the specified tab is a graph
	//	tab.
	//
	// Returns:
	//	True if the tab is a graph tab or protected graph tab, false if not.
	//

	global string $gHyperShadePanelLookupTable[];

	string $type = lookupTabType($tab);

	return (($type == "graph") || ($type == "protected graph"));
}

proc int isSceneTab(
	string $tab)
{
	//
	// Description:
	//	This procedure is used to query whether the specified tab is a scene
	//	tab.
	//
	// Returns:
	//	True if the tab is a scene tab, false if not.
	//
    if ($tab == "")
    {
        return false;
    }

	global string $gHyperShadePanelLookupTable[];

	return (lookupTabType($tab) == "scene");
}

// ---------------------------------------------------------------------------
// 	Procedures to find out information about the current tab
//
proc int activePaneIndex(
	string $panel)
{
	//
	// Description:
	//	This procedure determines what pane within the hypershade panel is the
	//	active pane.
	//
	// Returns:
	//	The index of the active pane within the paneLayout called
	//	paneArrangement.
	//

	setParent $panel;
	string $paneLayout = `setParent paneArrangement`;

	// Determine what tab layout is currently active, and which tab layout the
	// tab is being moved to.
	//
	int $activePaneIndex;

	$activePaneIndex = `paneLayout -query -activePaneIndex $paneLayout`;

	return $activePaneIndex;
}

proc string activeTabLayout(
	string $panel)
{
	//
	// Description:
	//	This procedure determines the name of the tab layout in the active
	//	pane of the hypershade panel.
	//
	// Returns:
	//	The name of the tab layout in the active pane of the hypershade panel.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	setParent $panel;

	string $activeTabLayout;

	string $tabSectionsShown =
		`optionVar -query hyperShadePanelTabSectionsShown`;

	if ($tabSectionsShown == "showTopAndBottomTabs")
	{
		$activeTabLayout = `paneLayout -query -activePane paneArrangement`;
	}
	else if ($tabSectionsShown == "showTopTabsOnly")
	{
		$activeTabLayout = "firstPaneTabs";
	}
	else // ($tabSectionsShown == "showBottomTabsOnly")
	{
		$activeTabLayout = "secondPaneTabs";
	}

	$activeTabLayout = `setParent $activeTabLayout`;

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;

	return $activeTabLayout;
}

proc string activeTab(
	string $panel)
{
	//
	// Description:
	//	This procedure determines the name of the frontmost tab in the tab
	//	layout in the active pane of the hypershade panel.
	//
	// Returns:
	//	The name of the tab.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	string $activeTabLayout = activeTabLayout($panel);

	setParent $activeTabLayout;

	string $activeTab;
    if (size(`tabLayout -q -childArray $activeTabLayout`) == 0)
    {
        // No tabs are under this tabLayout.
        //
        $activeTab = "";
    }
    else
    {
	    $activeTab = `tabLayout -query -selectTab $activeTabLayout`;
	    $activeTab = `setParent $activeTab`;
    }

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;

	return $activeTab;
}

proc string activeTabIndex(
	string $panel)
{
	//
	// Description:
	//	This procedure determines the index of the frontmost tab in the tab
	//	layout in the active pane of the hypershade panel.
	//
	// Returns:
	//	The index of the tab within the active tab layout.
	//

	string $activeTabLayout = activeTabLayout($panel);

	int $activeTabIndex;
	$activeTabIndex = `tabLayout -query -selectTabIndex $activeTabLayout`;

	return $activeTabIndex;
}

proc string activeTabLabel(
	string $panel)
{
	//
	// Description:
	//	This procedure determines the label of the frontmost tab in the tab
	//	layout in the active pane of the hypershade panel.
	//
	// Returns:
	//	The label of the tab.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	setParent $panel;
	string $activeTabLayout = activeTabLayout($panel);
	int $activeTabIndex = activeTabIndex($panel);

	string $tabLabelArray[];
	$tabLabelArray = `tabLayout -query -tabLabel $activeTabLayout`;

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;

	return $tabLabelArray[$activeTabIndex - 1];
}


proc string workAreaTab()
{
	//
	// Description:
	//	This procedure determines the name of the graph tab which is used as
	//	the designated work area (the tab to which graphs should be drawn if no
	//	other graph tab is a more obvious choice).
	//	The designated work area tab should be the only protected graph tab in
	//	the hypershade panel.
	//
	// Returns:
	//	The name of the designated work area tab.
	//

	string $workAreaTab;
	$workAreaTab = `optionVar -q hyperShadePanelWorkAreaTab`;

	if ($workAreaTab == "")
	{
		error
			-showLineNumber true
			(uiRes("m_hyperShadePanel.kWorkAreaGraphTabNotFound"));
	}

	return $workAreaTab;
}

proc int isGraphTabVisible(
	string $panel)
{
	//
	// Description:
	//	This procedure determines if a graph tab (work area) is visible within
	//	either of the two tab sections of the hypershade panel.
	//
	// Returns:
	//	True if at least one of the two tab sections has a graph tab as the
	//	frontmost tab.
	//	False otherwise.
	//

	string $saveParent = `setParent -query`;
	string $saveParentMenu = `setParent -query -menu`;
	int    $result = false;

	// Determine the names of the tabs in the two tab sections
	//
	setParent $panel;
	$tabLayout = `setParent firstPaneTabs`;
	string $frontFirstPaneTab =
		($tabLayout + "|" +`tabLayout -query -selectTab $tabLayout`);

	setParent $panel;
	$tabLayout = `setParent secondPaneTabs`;
	string $frontSecondPaneTab =
		($tabLayout + "|" +`tabLayout -query -selectTab $tabLayout`);

	// Determine if a graph tab is currently frontmost in either tab section
	//
	if (	isGraphTab($frontFirstPaneTab)
		|| 	isGraphTab($frontSecondPaneTab) )
	{
		$result = true;
	}
	else
	{
		$result =  false;
	}

	setParent $saveParent;
	setParent -menu $saveParentMenu;

	return $result;
}

proc string targetGraphTab(
	string $panel)
{
	//
	// Description:
	//	This procedure is called when the user is performing an action which
	//	should affect a graph tab (work area). For example, if the user has
	//	pressed the Show Up and Downstream Connections button, the resulting
	//	graph must be displayed in a graph tab.
	//	This procedure determines which graph tab would be the most appropriate
	//	graph tab in which to perform the action. The decision is made as
	//	follows:
	//		If there is only one graph tab visible, it will be the target.
	//		Else if there are two graph tabs visible, the one in the active pane
	//		will be the target.
	//		Else the default work area tab will be the target.
	//
	// Returns:
	//	The name of the graph tab which is the most appropriate target for an
	//	operation affecting a graph tab at the time this procedure is called.
	//

	// Determine which tab layout is currently active
	//
	int 	$activePaneIndex = activePaneIndex($panel);
	string 	$activeTabLayout;
	string 	$inactiveTabLayout;

	if ($activePaneIndex == 1)
	{
		$activeTabLayout = "firstPaneTabs";
		$inactiveTabLayout = "secondPaneTabs";
	}
	else
	{
		$inactiveTabLayout = "firstPaneTabs";
		$activeTabLayout = "secondPaneTabs";
	}

	// Determine the names of the tabs in the active and inactive tab sections
	//
	string $targetTab;

	setParent $panel;
	$tabLayout = `setParent $activeTabLayout`;
	string $frontActiveTab =
		($tabLayout + "|" +`tabLayout -query -selectTab $tabLayout`);

	setParent $panel;
	$tabLayout = `setParent $inactiveTabLayout`;
	string $frontInactiveTab =
		($tabLayout + "|" +`tabLayout -query -selectTab $tabLayout`);

	// Decide which graph tab should be the target
	//
	if (isGraphTab($frontActiveTab))
	{
		// The frontmost tab in the active tab section is a graph tab.
		// Therefore we will consider it to be the target tab.
		//
		$targetTab = $frontActiveTab;
	}
	else if (isGraphTab($frontInactiveTab))
	{
		// The frontmost tab in the active tab section is not a graph tab, but
		// the frontmost tab in the inactive tab section is. We will consider
		// the graph tab in the inactive tab section to be the target tab.
		//
		$targetTab = $frontInactiveTab;
	}
	else
	{
		// Neither tab section has a graph tab frontmost. Therefore we will
		// consider the target tab to be the default work area tab.
		//
		$targetTab = workAreaTab();
	}

	return $targetTab;
}

proc string renderCreateBarUIName(
	string $panel)
{
	//
	// Description:
	//	This procedure determines and returns the name of the top level
	//	formLayout of the renderCreateBarUI. The name can then be used to call
	//	renderCreateBarUI procedures.
	//
	// Returns:
	//	The name of the layout.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	setParent $panel;
	string $createBarForm = hyperShadeCreateBarForm($panel);
    if ($createBarForm == "")
        return "";

	string $childArray[] = `formLayout -query -childArray $createBarForm`;
	string $renderCreateBarUIName = $childArray[0];


	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;

	return $renderCreateBarUIName;
}

// ---------------------------------------------------------------------------
// 	Procedures to save/access information in option vars about the tab
//	layouts and settings of individual tabs
//
proc string tabLabel(
	string $tab)
{
	//
	// Description:
	//	This procedure determines the label of the specified tab.
	//
	// Returns:
	//	The label of the specified tab.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	string $tabLabel = "";

	setParent $tab;
	setParent ..;
	string $tabLayout = `setParent -query`;
	string $tabLabelArray[] = `tabLayout -query -tabLabel $tabLayout`;
	string $tabArray[] = `tabLayout -query -childArray $tabLayout`;

	int $i;

	for ($i = 0; ($i < size($tabArray)) && ($tabLabel == ""); $i++)
	{
		setParent $tabLayout;
		$tabArray[$i] = `setParent $tabArray[$i]`;

		if ($tabArray[$i] == $tab)
		{
			$tabLabel = $tabLabelArray[$i];
		}
	}

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;

	return $tabLabel;
}

proc string generateUniqueTabOptionVarName()
{
	//
	// Description:
	//	This procedure is used to create a unique name for an optionVar in
	//	which information about a tab will be stored.
	//
	// Returns:
	//	A unique name for an optionVar.
	//

	int $i = 1;
	string $optionVarName;

	do
	{
		$optionVarName = ("hyperShadeTab" + $i);
		$i++;
	}
	while (`optionVar -exists $optionVarName`);

	return $optionVarName;
}

proc updateTabOptionVar(
	string $optionVar,
	string $tab)
{
	//
	// Description:
	//	This procedure is called from updateTabOptionVar() and from
	//	createTabOptionVar(). It encapsulates some shared functionality of the
	//	two other procedures.
	//	This procedure generates a unique name for a tab option var if no name
	//	is provided in $optionVar. This procedure looks up the type of the tab
	//	in the lookup table if the type is not specified in $type.
	//	This procedure then gathers all of the information about the specified
	//	tab which needs to be stored in the optionVar, and saves that
	//	information in the optionVar in a known format.
	//

	if ($optionVar == "")
	{
		// No optionVar name was specified, so we create a new one.
		//
		$optionVar = generateUniqueTabOptionVarName();
	}

	//
	// Now we gather all of the information we need to store about the tab.
	//

	string $tabLabel = tabLabel($tab);
	string $type = lookupTabType($tab);
	string $component = lookupComponentName($tab);

	optionVar -intValue $optionVar 1;
	optionVar -stringValue ($optionVar + "Label") $tabLabel;
	optionVar -stringValue ($optionVar + "Type") $type;

	if ($type == "disk")
	{
		optionVar
			-stringValue ($optionVar + "DirectoriesVisorName")
			`libraryUIDirectoriesVisor($component)`;
		optionVar
			-stringValue ($optionVar + "FilesVisorName")
			`libraryUIFilesVisor($component)`;
		optionVar
			-stringValue ($optionVar + "RootDirectory")
			`libraryUIRootDirectory($component)`;
		optionVar
			-stringValue ($optionVar + "CurrentDirectory")
			`libraryUICurrentDirectory($component)`;
		optionVar
			-intValue ($optionVar + "DirectoriesShown")
			`libraryUIDirectoriesShown($component)`;
		optionVar
			-intValue ($optionVar + "FilesShown")
			`libraryUIFilesShown($component)`;
	}
	else if (($type == "graph") || ($type == "protected graph"))
	{
		optionVar
			-stringValue ($optionVar + "HypershadeName")
			`graphUIHypershadeName($component)`;
	}
	else if ($type == "scene")
	{
		optionVar
			-stringValue ($optionVar + "HypershadeName")
			`collectionUIHypershadeName($component)`;
		optionVar
			-stringValue ($optionVar + "Filter")
			`collectionUIFilter($component)`;
	}
	else
	{
		string $errorMsg = (uiRes("m_hyperShadePanel.kUnexpectedTab"));
		error
			-showLineNumber true
			(`format -s $type $errorMsg`);
	}
}

proc setTabLabel(
	string $tab,
	string $label)
{
	//
	// Description:
	//	This procedure sets the label of the specified tab.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	setParent $tab;
	setParent ..;
	string $tabLayout = `setParent -query`;
	string $tabLabelArray[] = `tabLayout -query -tabLabel $tabLayout`;
	string $tabArray[] = `tabLayout -query -childArray $tabLayout`;

	int $i;
	string $shortTabName;
	int $found = false;

	for ($i = 0; ($i < size($tabArray)) && (!$found); $i++)
	{
		setParent $tabLayout;
		$shortTabName = $tabArray[$i];
		$tabArray[$i] = `setParent $tabArray[$i]`;

		if ($tabArray[$i] == $tab)
		{
			$found = true;
		}
	}

	if ($found)
	{
		tabLayout
			-edit
			-tabLabel $shortTabName $label
			$tabLayout;
	}

	// Save the new tab label so that it will be remembered the next time the
	// visor is opened.
	//
	string $optionVar = lookupTabOptionVar($tab);
	updateTabOptionVar($optionVar, $tab);

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;
}

proc string tabTypeFromOptionVar(
	string $optionVar)
{
	//
	// Description:
	//	This procedure retrieves the type of the tab whose information is
	//	stored in the specified optionVar.
	//
	// Returns:
	//	The type of the tab.
	//

	string $valueArray[];
	$valueArray = `optionVar -query $optionVar`;

	return $valueArray[0];
}

proc string tabLabelFromOptionVar(
	string $optionVar)
{
	//
	// Description:
	//	This procedure retrieves the label of the tab whose information is
	//	stored in the specified optionVar.
	//
	// Returns:
	//	The label of the tab.
	//

	string $valueArray[];
	$valueArray = `optionVar -query $optionVar`;

	return $valueArray[1];
}

proc deleteOptionVar(
	string $optionVar)
{
	//
	// Description:
	//	This method is called from deleteTabOptionVar() or from
	//	deleteUnusedOptionVars().
	//	This method deletes the specified optionVar and the optionVars related
	//	to it.
	//	The specified optionVar actually serves no purpose except to act as a
	//	prefic for the related optionVars.
	//

	optionVar -remove $optionVar;
	optionVar -remove ($optionVar + "Label");
	optionVar -remove ($optionVar + "Type");
	optionVar -remove ($optionVar + "DirectoriesVisorName");
	optionVar -remove ($optionVar + "FilesVisorName");
	optionVar -remove ($optionVar + "RootDirectory");
	optionVar -remove ($optionVar + "CurrentDirectory");
	optionVar -remove ($optionVar + "DirectoriesShown");
	optionVar -remove ($optionVar + "FilesShown");
	optionVar -remove ($optionVar + "HypershadeName");
	optionVar -remove ($optionVar + "Filter");
	optionVar -remove ($optionVar + "IconSize");
	optionVar -remove ($optionVar + "ViewOption");
	optionVar -remove ($optionVar + "SortOption");
	optionVar -remove ($optionVar + "ReverseOption");
}

proc deleteTabOptionVar(
	string $tab)
{
	//
	// Description:
	//	This procedure deletes the optionVar associated with the specified tab.
	//

	string $optionVar = lookupTabOptionVar($tab);
	deleteOptionVar($optionVar);
}

proc deleteUnusedTabOptionVars(
	string $panel)
{
	//
	// Description:
	//	This procedure is called the first time hypershade is opened each
	//	session.
	//	This procedure deletes all optionVars whose names indicate that they
	//	contain information about hypershade panel tabs, but which are not
	//	being used for some reason. This is done so that the user's userPrefs
	//	does not fill up with unused optionVars.
	//

	int $i;

	for ($i = 0; $i < 100; $i++)
	{
		string $optionVar = ("hyperShadeTab" + $i);
		if (`optionVar -exists $optionVar`)
		{
			if (lookupOptionVarTab($optionVar) == "")
			{
				deleteOptionVar($optionVar);
			}
		}
	}
}

proc updateTabLayoutOptionVar(
	string $panel,
	string $tabLayout)
{
	//
	// Description:
	//	This procedure should be called whenever a change is made to the tab
	//	layouts in the hypershade panel which we want to save to an optionVar
	//	in order to be able to recreate the same tab layout structure at a
	//	later time. For example, we would want to call this procedure if we had
	//	moved a tab left or right within the tab layout.
	//	This procedure writes out an option var which names all of the option
	//	vars describing properties of the tabs in the specified tab layout.
	//	The tab option vars are named in order from left to right.
	//

	string $oldParent = `setParent -query`;
	setParent $panel;

	// Get the short name of the tab layout, since the caller may have passed
	// in the full path
	//
	string $tabLayoutPathTokens[];
	tokenize($tabLayout, "|", $tabLayoutPathTokens);
	$tabLayout = $tabLayoutPathTokens[size($tabLayoutPathTokens) - 1];

	string $tabLayoutOptionVar;

	if ($tabLayout == "firstPaneTabs")
	{
		$tabLayoutOptionVar = "hyperShadeFirstPaneTabs";
	}
	else if ($tabLayout == "secondPaneTabs")
	{
		$tabLayoutOptionVar = "hyperShadeSecondPaneTabs";
	}
	else
	{
		string $errorMsg = (uiRes("m_hyperShadePanel.kUnexpectedTabLayoutName"));
		error
			-showLineNumber true
			(`format -s $tabLayout $errorMsg`);
	}

	// Delete the existing optionVar for the tabs in this pane, because we are
	// going to rebuild it.
	//
	optionVar -remove $tabLayoutOptionVar;

    if (size(`tabLayout -q -childArray $tabLayout`) == 0)
    {
        // The tabLayout has no tabs in it.  Nothing to do.
        //
	    if ($oldParent != "NONE") setParent $oldParent;
        return;
    }


	string $tabArray[] = `tabLayout -query -childArray $tabLayout`;

	//
	// Now that we have a list of the layouts associated with the tabs, we can
	// lookup the name of the optionVar associated with each and store it in
	// the optionVar which describes the ordering of the tabs.
	//

	string $tab;
	string $tabOptionVar;

	// For each tab in the tabLayout of the pane
	//
	for ($i = 0; $i < size($tabArray); $i++)
	{
		$tab = $tabArray[$i];
		setParent $panel;
		$tab = `setParent $tab`;

		// Lookup the optionVar which describes this tab
		//
		$tabOptionVar = lookupTabOptionVar($tab);

		if ($tabOptionVar == "")
		{
			global string $gHyperShadePanelLookupTable[];
			lookupTablePrint($gHyperShadePanelLookupTable);

			error
				-showLineNumber true
				(uiRes("m_hyperShadePanel.kNonEmptyTabOptionVarName"));
		}

		// Append the name of the optionVar to the optionVar describing the
		// tabs in this pane
		//
		optionVar -stringValueAppend $tabLayoutOptionVar $tabOptionVar;
	}

	//if ($oldParent != "NONE") setParent $oldParent;
}

//
// Description: Called for a newly created graph, apply the saved settings for
//      the hypergraph graphing options.
//
proc applyHypergraphOptions(string $hypershadeName)
{
    int $isMergeConnectionsSet = `optionVar -query hsMergeConnections`;
    hyperGraph -edit -mergeConnections $isMergeConnectionsSet $hypershadeName;

    int $isOpaqueContainersSet = `optionVar -query hsOpaqueContainers`;
    hyperGraph -edit -opaqueContainers $isOpaqueContainersSet $hypershadeName;
}

// ---------------------------------------------------------------------------
// 	UI creation procedures
//

proc string createGraphTab(
	string $panel,
	string $tabLayout,
	string $tabLabel,
	int $protected)
{
	//
	// Description:
	//	This procedure is called when the user creates a new graph tab, or when
	//	the default tabs are being created (ie the first time the user uses the
	//	hypershade panel or as a result of a revert to default tabs).
	//	This procedure creates a graph tab.
	//	If the $protected argument is true, this tab will be flagged as a
	//	protected graph. A protected graph is one which cannot be removed from
	//	the hypershade panel or moved from one tab layout to the other within
	//	the hypershade panel.
	//
	// Returns:
	//	The name of the newly created tab.
	//

	setParent $panel;
	setParent $tabLayout;
		string $tab = `formLayout`;
			// Create the graph UI. The second parameter is blank
			// because we want to have a new hypershade created,
			// rather than specifying an existing one to be used.
			//
			string $graphUI =
				graphUI(
					$tab,
					""); // hypershadeName
		setParent ..; // from $tab
	setParent ..; // from $tabLayout

	// Set the label on the tab
	//
	tabLayout
		-edit
		-tabLabel $tab $tabLabel
		$tabLayout;

	// Configure the graphUI
	//
	graphUISetPopupMenuScript(
		$graphUI,
		("hyperShadePanelSceneAndGraphTabPopupMenu " + $panel));

	string $hypershadeName = graphUIHypershadeName($graphUI);

    // Create a callback to set the active pane when mouse is pressed.
    //
	hyperGraph -edit
		-focusCommand
			("hyperShadePanelSetActiveTabLayout "
				+ $panel
				+ " "
				+ $tabLayout
                + " false")
		$hypershadeName;

	// Specify the callback to be called when the user clicks on the menu arrow
	// on the bottom of a node
	//
	hyperGraph
		-edit
		-nodeMenuCommand
			("hyperShadePanelSceneAndGraphTabPopupMenu " + $panel)
		$hypershadeName;

	string $optionVar = generateUniqueTabOptionVarName();
	if ($protected)
	{
		// A protected graph is one which cannot be removed or moved to the
		// other tab layout. It *can* be moved left and right within the tab
		// layout it is in.
		//
		registerTab($tab, "protected graph", $graphUI, $optionVar, $tabLayout);
	}
	else
	{
		registerTab($tab, "graph", $graphUI, $optionVar, $tabLayout);
	}
	updateTabOptionVar($optionVar, $tab);

	// Update the tab layout option var now that a new tab has been added
	//
	updateTabLayoutOptionVar($panel, $tabLayout);

	// If the graph tab is protected, it should be considered the designated
	// Work Area tab.
	//
	// ASSUMPTION:
	// We assume there will only ever be one protected tab, since we do not
	// allow the user to create one. If additional protected graph tabs are
	// created in the future, this code will need to change.
	//
	if ($protected)
	{
		optionVar -stringValue "hyperShadePanelWorkAreaTab" $tab;
	}

    applyHypergraphOptions($hypershadeName);

	// Return the name of the tab which was created.
	//
	return $tab;
}

proc string recreateGraphTab(
	string $panel,
	string $tabLayout,
	string $optionVar,
	int $reuseEditors,
	int $protected)
{
	//
	// Description:
	//	This procedure is called when a graph tab is being recreated from an
	//	optionVar.
	//	This procedure creates a graph tab using the information stored in the
	//	specified optionVar.
	//	If the $protected argument is true, this tab will be flagged as a
	//	protected graph. A protected graph is one which cannot be removed from
	//	the hypershade panel or moved from one tab layout to the other within
	//	the hypershade panel.
	//
	// Returns:
	//	The name of the newly created tab.
	//

	string $tabLabel
		= `optionVar -query ($optionVar + "Label")`;
	string $hypershadeName;

	if ($reuseEditors)
	{
		$hypershadeName = `optionVar -query ($optionVar + "HypershadeName")`;
	}

	setParent $panel;
	setParent $tabLayout;
		string $tab = `formLayout`;
			// Create the graph UI specifying that an existing hypershade
			// should be used.
			//
			string $graphUI =
				graphUI(
					$tab,
					$hypershadeName);
		setParent ..; // from $tab
	setParent ..; // from $tabLayout

	// Set the label on the tab
	//
	tabLayout
		-edit
		-tabLabel $tab $tabLabel
		$tabLayout;

	// Configure the graphUI according to saved state
	//
	graphUISetPopupMenuScript(
		$graphUI,
		("hyperShadePanelSceneAndGraphTabPopupMenu " + $panel));

    // Create a callback to set the active pane when mouse is pressed.
    //
	$hypershadeName = graphUIHypershadeName($graphUI);

	hyperGraph -edit
		-focusCommand
			("hyperShadePanelSetActiveTabLayout "
				+ $panel
				+ " "
				+ $tabLayout
                + " false")
		$hypershadeName;

	// Specify the callback to be called when the user clicks on the menu arrow
	// on the bottom of a node
	//
	hyperGraph
		-edit
		-nodeMenuCommand
			("hyperShadePanelSceneAndGraphTabPopupMenu " + $panel)
		$hypershadeName;

	if ($protected)
	{
		registerTab($tab, "protected graph", $graphUI, $optionVar, $tabLayout);
	}
	else
	{
		registerTab($tab, "graph", $graphUI, $optionVar, $tabLayout);
	}

	// Update the tab layout option var now that a new tab has been added
	//
	updateTabLayoutOptionVar($panel, $tabLayout);

	// If the graph tab is protected, it should be considered the designated
	// Work Area tab.
	//
	// ASSUMPTION:
	// We assume there will only ever be one protected tab, since we do not
	// allow the user to create one. If additional protected graph tabs are
	// created in the future, this code will need to change.
	//
	if ($protected)
	{
		optionVar -stringValue "hyperShadePanelWorkAreaTab" $tab;
	}

	if ($reuseEditors)
	{
        evalDeferred("hyperGraph -edit -frameGraph "+$hypershadeName);
    }

    applyHypergraphOptions($hypershadeName);

	// Return the name of the tab which was created.
	//
	return $tab;
}

global proc hypershadeNodeEdTabChanged(string $ned)
{
	if (`nodeEditor -exists $ned` && `iconTextButton -exists tabsRLCTButton`) {
		iconTextButton -e -enable `nodeEditor -q -restoreLastClosedTab $ned` tabsRLCTButton;
	}
}

global proc hypershadeBuildNEMenus(string $ned)
{
	callPython("maya.app.general.nodeEditor","addCallback",{$ned});
	callPython("maya.app.general.nodeEditor","buildPanelMenus",{$ned});

	nodeEditor -e -tabChangeCommand ("hypershadeNodeEdTabChanged \"" + $ned + "\"") $ned;
}

global proc int hyperShadePanelKeyPressCmd(string $ned, string $key)
{
	return nodeEdKeyPressCommand($ned, $key);
}

global proc int hyperShadePanelKeyReleaseCmd(string $ned, string $key)
{
	return nodeEdKeyReleaseCommand($ned, $key);
}

proc string createNodeEditor(string $name, string $parent)
{
	if (!(`nodeEditor -exists $name`))
	{
	// We use evalDeffered for contentsChangedCommand since
	// it seems that this command has priority over the delete command.
	// Since we want the delete to take priority elsewhere we resolve to this.
	//
		nodeEditor -unParent
            -addNewNodes true
            -showTabs true
            -allowTabTearoff false
			-editorMode "lookdev"
			-syncedSelection true
			-popupMenuScript hypershadeBuildNEMenus
		    -createNodeCommand nodeEdCreateNodeCommand
			-keyPressCommand hyperShadePanelKeyPressCmd
			-keyReleaseCommand hyperShadePanelKeyReleaseCmd
			-filterCreateNodeTypes "lookdevNodeTypes"
            -contentsChangedCommand "evalDeferred -lp \"hyperShadeRefreshActiveNode\""
			$name;
	}

	// Parent the editors to the editor layout
	nodeEditor -edit -parent $parent $name;

	return $name;
}

proc string createDiskTab(
	string $panel,
	string $tabLayout,
	string $tabLabel,
	string $directory)
{
	//
	// Description:
	//	This procedure is called when the user creates a new disk tab, or when
	//	the default tabs are being created (ie the first time the user uses the
	//	hypershade panel or as a result of a revert to default tabs).
	//	This procedure creates a disk tab.
	//
	// Returns:
	//	The name of the newly created tab.
	//

	setParent $panel;
	setParent $tabLayout;
		string $tab = `formLayout`;
			// Create the library UI. The second and third parameters are blank
			// because we want to have new directory and files visors created,
			// rather than specifying existing ones to be used.
			//
			string $libraryUI =
				libraryUI(
					$tab,
					"", 	// directoriesVisorName
					""); 	// filesVisorName
			libraryUISetRootDirectory($libraryUI, $directory);
		setParent ..; // from $tab
	setParent ..; // from $tabLayout

	// Set the label on the tab
	//
	tabLayout
		-edit
		-tabLabel $tab $tabLabel
		$tabLayout;

    // Create a callback to set the active pane when mouse is pressed.
    //
    {
        string $directoriesName = libraryUIDirectoriesVisor($libraryUI);

        hyperGraph -edit
            -focusCommand
				("hyperShadePanelSetActiveTabLayout "
					+ $panel
					+ " "
					+ $tabLayout
                    + " false")
            $directoriesName;

        string $filesName = libraryUIFilesVisor($libraryUI);

        hyperGraph -edit
            -focusCommand
				("hyperShadePanelSetActiveTabLayout "
					+ $panel
					+ " "
					+ $tabLayout
                    + " false")
            $filesName;
    }

	// Configure the libraryUI
	//
	libraryUISetFilesPopupMenuScript(
		$libraryUI,
		("hyperShadePanelDiskTabPopupMenu " + $panel));

	string $optionVar = generateUniqueTabOptionVarName();
	registerTab($tab, "disk", $libraryUI, $optionVar, $tabLayout);
	updateTabOptionVar($optionVar, $tab);

	// Update the tab layout option var now that a new tab has been added
	//
	updateTabLayoutOptionVar($panel, $tabLayout);

	// Return the name of the tab which was created.
	//
	return $tab;
}

proc string recreateDiskTab(
	string $panel,
	string $tabLayout,
	string $optionVar,
	int $reuseEditors)
{
	//
	// Description:
	//	This procedure is called when a disk tab is being recreated from
	//	optionVars.
	//	This procedure creates a disk tab using the information stored in
	//	optionVars.
	//
	// Returns:
	//	The name of the newly created tab.
	//

	string $tabLabel
		= `optionVar -query ($optionVar + "Label")`;
	string $directoriesVisorName;
	string $filesVisorName;

	if ($reuseEditors)
	{
		$directoriesVisorName
			= `optionVar -query ($optionVar + "DirectoriesVisorName")`;
		$filesVisorName
			= `optionVar -query ($optionVar + "FilesVisorName")`;
	}

	setParent $panel;
	setParent $tabLayout;
		string $tab = `formLayout`;
			// Create the library UI specifying that our existing directory and
			// files visors should be used.
			//
			string $libraryUI =
				libraryUI(
					$tab,
					$directoriesVisorName,
					$filesVisorName);
		setParent ..; // from $tab
	setParent ..; // from $tabLayout

	// Set the label on the tab
	//
	tabLayout
		-edit
		-tabLabel $tab $tabLabel
		$tabLayout;

    // Create a callback to set the active pane when mouse is pressed.
    //
    {
        string $directoriesName = libraryUIDirectoriesVisor($libraryUI);

        hyperGraph -edit
            -focusCommand
				("hyperShadePanelSetActiveTabLayout "
					+ $panel
					+ " "
					+ $tabLayout
                    + " false")
            $directoriesName;

        string $filesName = libraryUIFilesVisor($libraryUI);

        hyperGraph -edit
            -focusCommand
				("hyperShadePanelSetActiveTabLayout "
					+ $panel
					+ " "
					+ $tabLayout
                    + " false")
            $filesName;
    }

	//
	// Configure the libraryUI according to saved state
	//
	// For some tabs we may not necessarily use the root directory and current
	// directory that have been stored in optionVars. In situations where the
	// tab label indicates that the tab is a "default" tab (ie one you would
	// get if you did Revert To Default Tabs), we will ensure the directories
	// point to the current installation of Maya. If we did not do this, we
	// would have situations where a user running a new installation of Maya
	// would still end up looking at shader libraries and such from a previous
	// installation.
	//

	// Initialize the root directory and current directory for the tab to be
	// the directories stored in optionVars.
	//
	string $rootDirectory =
		`optionVar -query ($optionVar + "RootDirectory")`;
	string $currentDirectory =
		`optionVar -query ($optionVar + "CurrentDirectory")`;

	// For disk tabs with particular labels, we will massage the directories to
	// be sure they are appropriate.
	//
	if ($tabLabel == (uiRes("m_hyperShadePanel.kProjectsTab")) )
	{
		string $projectsDir = `internalVar -userWorkspaceDir`;

		if ($rootDirectory != $projectsDir)
		{
			$rootDirectory = $projectsDir;
			$currentDirectory = $projectsDir;
		}
	}
	else if ($tabLabel == (uiRes("m_hyperShadePanel.kShaderLibraryTab")) )
	{
		string $shaderLibraryDir = `getenv MAYA_SHADER_LIBRARY_PATH`;

		if ( ( $shaderLibraryDir != "" )
			 &&	( $rootDirectory != $shaderLibraryDir )
			 && ( `filetest -d $shaderLibraryDir` ) )
		{
			$rootDirectory = $shaderLibraryDir;
			$currentDirectory = $shaderLibraryDir;
		}
	}


	// Set the root and current directories of the tab
	//
	libraryUISetRootDirectory($libraryUI, $rootDirectory);
	libraryUISetCurrentDirectory($libraryUI, $currentDirectory);

	if (`optionVar -query ($optionVar + "DirectoriesShown")`)
	{
		if (`optionVar -query ($optionVar + "FilesShown")`)
		{
			libraryUIShowDirectoriesAndFiles($libraryUI);
		}
		else
		{
			libraryUIShowDirectoriesOnly($libraryUI);
		}
	}
	else
	{
		libraryUIShowFilesOnly($libraryUI);
	}

	libraryUISetFilesPopupMenuScript(
		$libraryUI,
		("hyperShadePanelDiskTabPopupMenu " + $panel));


	registerTab($tab, "disk", $libraryUI, $optionVar, $tabLayout);

	// Update the tab layout option var now that a new tab has been added
	//
	updateTabLayoutOptionVar($panel, $tabLayout);

	// Return the name of the tab which was created.
	//
	return $tab;
}

proc string createSceneTab(
	string $panel,
	string $tabLayout,
	string $tabLabel,
	string $filter)
{
	//
	// Description:
	//	This procedure is called when the user creates a new scene tab, or when
	//	the default tabs are being created (ie the first time the user uses the
	//	hypershade panel or as a result of a revert to default tabs).
	//	This procedure creates a scene tab.
	//
	// Returns:
	//	The name of the newly created tab.
	//

	setParent $panel;
	setParent $tabLayout;
		string $tab = `formLayout`;
			// Create the collection UI. The second parameter is blank
			// because we want to have a new hypershade created,
			// rather than specifying an existing one to be used.
			//
			string $collectionUI =
				collectionUI(
					$tab,
					""); // hypershadeName
		setParent ..; // from $tab
	setParent ..; // from $tabLayout

	// Set the label on the tab
	//
	tabLayout
		-edit
		-tabLabel $tab $tabLabel
		$tabLayout;

    // Create a callback to set the active pane when mouse is pressed.
    //
    {
        string $hyperName = collectionUIHypershadeName($collectionUI);

        hyperGraph -edit
            -focusCommand
				("hyperShadePanelSetActiveTabLayout "
					+ $panel
					+ " "
					+ $tabLayout
                    + " false")
            -scrollUpDownNoZoom true
            -iconSize "mediumIcons"
			-viewOption "asIcons"
			// sortOption and reverseOption initialized below
            $hyperName;
		registerSortOption( $collectionUI, "byName" );
		registerReverseOption( $collectionUI, "false" );
    }

	// Configure the collectionUI
	//
	collectionUISetFilter($collectionUI, $filter);
	collectionUISetPopupMenuScript(
		$collectionUI,
		("hyperShadePanelSceneAndGraphTabPopupMenu " + $panel));

	string $optionVar = generateUniqueTabOptionVarName();
	registerTab($tab, "scene", $collectionUI, $optionVar, $tabLayout);
	updateTabOptionVar($optionVar, $tab);

	// Update the tab layout option var now that a new tab has been added
	//
	updateTabLayoutOptionVar($panel, $tabLayout);

	//	create the appropriate filtering controls for the tab
	//
	string $implicitFilter = filteredCollection_RealFilterName( $filter );
	showFilter( $panel, $tab, $implicitFilter );

	// Return the name of the tab which was created.
	//
	return $tab;
}

proc refreshSceneTabContent(
	string $panel,
	string $tabLayout,
    string $tab,
	int $reuseEditors)
{
	//
	// Description:
	//	This procedure is called to refresh the scene tab content.
    //  If the content of the tab is not yet created, we create it here.
	//

    // If it is not a scene tab, then don't do anything.
    //
    if (!isSceneTab($tab))
    {
        return;
    }

    if (size(`formLayout -q -childArray $tab`) > 0)
    {
        // The content of this tab has already been created.
        // We have nothing to do.
        //
        return;
    }

    // The content of this tab is not created yet, create it.
    //
    setParent $tab;

	string $hypershadeName;
    string $optionVar = lookupTabOptionVar($tab);
	if ($reuseEditors)
	{
		$hypershadeName = `optionVar -query ($optionVar + "HypershadeName")`;
	}

    // Create the graph UI specifying that an existing hypershade
    // should be used.
    //
    string $collectionUI =
        collectionUI(
            $tab,
            $hypershadeName);

    // The previous registration of the tab did not specify its its
    // collectionUI.  Update the component of the tab in the tab registry.
    //
    updateComponentNameInTabRegistry($tab, $collectionUI);


    // Create a callback to set the active pane when mouse is pressed.
    //
    {
        string $hyperName = collectionUIHypershadeName($collectionUI);

        // Retrieve icon size from saved state.
        //
        string $iconSize = getIconSize($optionVar);

        hyperGraph -edit
            -focusCommand
				("hyperShadePanelSetActiveTabLayout "
					+ $panel
					+ " "
					+ $tabLayout
                    + " false")
            -scrollUpDownNoZoom true
            -iconSize $iconSize
			-viewOption "asIcons"
			// sortOption and reverseOption initialized below
            $hyperName;
		registerSortOption( $collectionUI, "byName" );
		registerReverseOption( $collectionUI, "false" );
    }

	// Configure the collectionUI according to saved state
	//
	string $filter = `optionVar -query ($optionVar + "Filter")`;
	collectionUISetFilter(
		$collectionUI,
		$filter );
	collectionUISetPopupMenuScript(
		$collectionUI,
		("hyperShadePanelSceneAndGraphTabPopupMenu " + $panel));

	//	create the appropriate filtering controls for the tab
	//
	string $implicitFilter = filteredCollection_RealFilterName( $filter );
	showFilter( $panel, $tab, $implicitFilter );
}

proc string recreateSceneTab(
	string $panel,
	string $tabLayout,
	string $optionVar,
	int $reuseEditors)
{
	//
	// Description:
	//	This procedure is called when a scene tab is being recreated from an
	//	optionVar.
	//	This procedure creates a scene tab using the information stored in the
	//	specified optionVar.
	//
	// Returns:
	//	The name of the newly created tab.
	//

	string $tabLabel
		= `optionVar -query ($optionVar + "Label")`;
	string $hypershadeName;

	if ($reuseEditors)
	{
		$hypershadeName = `optionVar -query ($optionVar + "HypershadeName")`;
	}

	setParent $panel;
	setParent $tabLayout;
		string $tab = `formLayout`;
			// Create the collection UI specifying that an existing hypershade
			// should be used.
			//
			string $collectionUI =
				collectionUI(
					$tab,
					$hypershadeName);
		setParent ..; // from $tab
	setParent ..; // from $tabLayout

	// Set the label on the tab
	//
	tabLayout
		-edit
		-tabLabel $tab $tabLabel
		$tabLayout;

	// Create a callback to set the active pane when mouse is pressed.
    //
    {
        string $hyperName = collectionUIHypershadeName($collectionUI);

        string $iconSize = getIconSize($optionVar);

        hyperGraph -edit
            -focusCommand
				("hyperShadePanelSetActiveTabLayout "
					+ $panel
					+ " "
					+ $tabLayout
                    + " false")
            -scrollUpDownNoZoom true
            -iconSize $iconSize
			-viewOption "asIcons"
			// sortOption and reverseOption initialized below
            $hyperName;

		string $viewOption = "asIcons";
		if (`optionVar -exists ($optionVar + "ViewOption")`)
		{
			$viewOption = `optionVar -query ($optionVar + "ViewOption")`;
		}
		registerViewOption( $collectionUI, $viewOption );
		hyperGraph -edit -viewOption $viewOption $hyperName;
	
		string $sortOption = "byName";
		if (`optionVar -exists ($optionVar + "SortOption")`)
		{
			$sortOption = `optionVar -query ($optionVar + "SortOption")`;
		}
		registerSortOption( $collectionUI, $sortOption );
		
		string $reverseOption = "false";
		if (`optionVar -exists ($optionVar + "ReverseOption")`)
		{
			$reverseOption = `optionVar -query ($optionVar + "ReverseOption")`;
		}
		registerReverseOption( $collectionUI, $reverseOption );
    }

	// Configure the collectionUI
	//
	string $filter = `optionVar -query ($optionVar + "Filter")`;
	collectionUISetFilter(
		$collectionUI,
		$filter );
	collectionUISetPopupMenuScript(
		$collectionUI,
		("hyperShadePanelSceneAndGraphTabPopupMenu " + $panel));

    registerTab($tab, "scene", $collectionUI, $optionVar, $tabLayout);

	// Update the tab layout option var now that a new tab has been added
	//
	updateTabLayoutOptionVar($panel, $tabLayout);

	//	create the appropriate filtering controls for the tab
	//
	string $implicitFilter = filteredCollection_RealFilterName( $filter );
	showFilter( $panel, $tab, $implicitFilter );

    // If we need to reuseEditor, then we can create the content
    // of the tab right away.
    //
    if ($reuseEditors)
    {
        refreshSceneTabContent($panel, $tabLayout, $tab, $reuseEditors);
    }

	// Return the name of the tab which was created.
	//
	return $tab;
}


proc string recreateTab(
	string $panel,
	string $tabLayout,
	string $optionVar,
	int $reuseEditors)
{
	//
	// Description:
	//	This procedure is called by initTabs() when a tab is being recreated
	//	from an optionVar.
	//	This procedure determines what kind of tab is represented by the
	//	optionVar, then calls one of recreateGraphTab(), recreateDiskTab() or
	//	recreateSceneTab() to create the tab.
	//

	string $type = `optionVar -query ($optionVar + "Type")`;

	if ($type == "disk")
	{
		recreateDiskTab($panel, $tabLayout, $optionVar, $reuseEditors);
	}
	else if ($type == "graph")
	{
		recreateGraphTab(
			$panel,
			$tabLayout,
			$optionVar,
			$reuseEditors,
			false);
	}
	else if ($type == "protected graph")
	{
		recreateGraphTab(
			$panel,
			$tabLayout,
			$optionVar,
			$reuseEditors,
			true);
	}
	else if ($type == "nodeEditor")
	{
	}
	else if ($type == "scene")
	{
		recreateSceneTab($panel, $tabLayout, $optionVar, $reuseEditors);
	}
	else
	{
		string $errorMsg = (uiRes("m_hyperShadePanel.kUnexpectedTabInOptionVar"));
		error
			-showLineNumber true
			(`format -s $type $errorMsg`);
	}

	return $type;
}


// Description:  This procedure is called to delete a scene tab as well as
//      the filterBox and filterButton associated with it.
//      We assume that the input tab is a scene tab.
//
proc removeSceneTabFilterReference(string $panel, string $tab)
{
    // Delete the filterBox and filterButton associated with the scene.
    //
	string $collection = lookupComponentName( $tab );

	string $filterControls[] = collectionUIFilterControls( $collection );
	string $filterBox = $filterControls[1];
	string $filterButton = $filterControls[2];

    setParent $panel;
    deleteUI $filterBox;
    deleteUI $filterButton;

    // Remove any reference to the filterBox and filterButton.
    //
    global string $gPreviousFilterBox;
    global string $gPreviousFilterButton;
    if ($gPreviousFilterBox == $filterBox)
    {
        $gPreviousFilterBox = "";
    }
    if ($gPreviousFilterButton == $filterButton)
    {
        $gPreviousFilterButton = "";
    }
}

// Description:  This procedure is called when we need to refresh
//      the sceneTabFilterForm to reflect the current pane and front
//      tab arrangement.
//
proc refreshSceneTabFilterForm(string $panel)
{
    // Check which is the top most pane.
    //
    string $tabSectionsShown =
        `optionVar -query hyperShadePanelTabSectionsShown`;

    string $upperPane = "firstPaneTabs";

    if ($tabSectionsShown == "showBottomTabsOnly")
    {
        // When only the bottom pane is showing, the bottom pane is considered
        // the upper pane for the time being.
        //
        $upperPane = "secondPaneTabs";
    }

    setParent $panel;
    setParent $upperPane;

    // Check which tab is the front most tab in this upperPane.
    //
    string $upperPaneFrontMostTab = `tabLayout -query -selectTab $upperPane`;

    if ($upperPaneFrontMostTab != "")
    {
        $upperPaneFrontMostTab = `setParent $upperPaneFrontMostTab`;
    }

    if (isSceneTab($upperPaneFrontMostTab))
    {
        // If this front most tab is a scene tab, then show its filter in the
        // sceneTabFilterForm.
        //
        showCurrentFilterBoxAndButton($panel, $upperPaneFrontMostTab);
    }
    else
    {
        // Dim the sceneTabFilterForm.
        //
        dimCurrentFilterBoxAndButton();
    }
}


proc moveTab(
	string $panel,
	string $direction)
{
	//
	// Description:
	//	This procedure moves a tab up, down, left or right within the
	//	hypershade panel.
	//	This procedure acts on the currently active tab when the $direction is
	//	"left" or "right". When the $direction is "up" or "down", this
	//	procedure acts on the frontmost tab in the bottom or top tab layout
	//	respectively.
	//	Once the move has been completed, the tab is made the active tab so
	//	that it can easily be immediately moved again.
	//

	//	flag this as a "construction" operation.  This will prevent
	//	many unnecessary refreshes of the various tabs as they are
	//	moved around.
	//
	hyperShadeStartConstruction( $panel );

	setParent $panel;
	string $paneLayout = `setParent paneArrangement`;

	if ($direction == "up")
	{
		// Make the bottom tab layout active
		//
		paneLayout -edit -activePaneIndex 2 paneArrangement;
	}
	else if ($direction == "down")
	{
		// Make the top tab layout active
		//
		paneLayout -edit -activePaneIndex 1 paneArrangement;
	}

	// Determine what tab layout is currently active, and which tab layout the
	// tab is being moved to.
	//
	int 	$activePaneIndex = activePaneIndex($panel);
	string 	$activeTabLayout;

	if ($activePaneIndex == 1)
	{
		$activeTabLayout = "firstPaneTabs";
	}
	else
	{
		$activeTabLayout = "secondPaneTabs";
	}

	int 	$activeTabIndex = activeTabIndex($panel);

	if (($direction == "left") || ($direction == "right"))
	{
		int $numTabs = `tabLayout -query -numberOfChildren $activeTabLayout`;
		int $targetTabIndex;

		if (($direction == "left") && ($activeTabIndex > 1))
		{
			$targetTabIndex = $activeTabIndex - 1;
			tabLayout
				-edit
				-moveTab $activeTabIndex $targetTabIndex
				$activeTabLayout;

			// Bring the target tab to the front
			//
			tabLayout
				-edit
				-selectTabIndex $targetTabIndex
				$activeTabLayout;

			// Update the tab layout option vars now that a tab has been moved
			//
			updateTabLayoutOptionVar($panel, $activeTabLayout);
		}
		else if (($direction == "right") && ($activeTabIndex < $numTabs))
		{
			$targetTabIndex = $activeTabIndex + 1;
			tabLayout
				-edit
				-moveTab $activeTabIndex $targetTabIndex
				$activeTabLayout;

			// Bring the target tab to the front
			//
			tabLayout
				-edit
				-selectTabIndex $targetTabIndex
				$activeTabLayout;

			// Update the tab layout option vars now that a tab has been moved
			//
			updateTabLayoutOptionVar($panel, $activeTabLayout);
		}
	}
	else
	{
		string 	$activeTab 			= activeTab($panel);

		string 	$targetTabLabel 	= activeTabLabel($panel);
		int 	$targetPaneIndex;
		string 	$targetTabLayout;

		if ($activePaneIndex == 1)
		{
			$targetTabLayout = "secondPaneTabs";
			$targetPaneIndex = 2;
		}
		else
		{
			$targetTabLayout = "firstPaneTabs";
			$targetPaneIndex = 1;
		}

		string $recreatedTab;

		// Determine what kind of tab the current tab is (disk/graph/scene)
		//
		if (isDiskTab($activeTab))
		{
			string $libraryUI;
			$libraryUI = lookupComponentName($activeTab);

			// Store the information needed to recreate the tab into an
			// optionVar
			//
			string $tabOptionVar = lookupTabOptionVar($activeTab);
			updateTabOptionVar($tabOptionVar, $activeTab);

			// Delete the libraryUI and the active tab.
			//
			unregisterTab($activeTab);
			libraryUIDelete(
				$libraryUI,
				false); // don't delete the visors
			deleteUI $activeTab;

			// Recreate the libraryUI in the target tab.
			//
			$recreatedTab = recreateDiskTab(
				$panel,
				$targetTabLayout,
				$tabOptionVar,
				true /* reuse editors */);

		}
		else if (isGraphTab($activeTab))
		{
			int $protected = (lookupTabType($activeTab) == "protected graph");
			string $graphUI;
			$graphUI = lookupComponentName($activeTab);

			// Store the information needed to recreate the tab into an
			// optionVar
			//
			string $tabOptionVar = lookupTabOptionVar($activeTab);
			updateTabOptionVar($tabOptionVar, $activeTab);

			// Delete the libraryUI and the active tab.
			//
			unregisterTab($activeTab);
			graphUIDelete(
				$graphUI,
				false); // don't delete the hypershade
			deleteUI $activeTab;

			// Recreate the libraryUI in the target tab.
			//
			$recreatedTab = recreateGraphTab(
				$panel,
				$targetTabLayout,
				$tabOptionVar,
				true, /* reuse editors */
				$protected);
		}
		else if (isSceneTab($activeTab))
		{
			string $collectionUI;
			$collectionUI = lookupComponentName($activeTab);

			// Store the information needed to recreate the tab into an
			// optionVar
			//
			string $tabOptionVar = lookupTabOptionVar($activeTab);
			updateTabOptionVar($tabOptionVar, $activeTab);

			// Delete the collectionUI and the active tab.
			//
            removeSceneTabFilterReference($panel, $activeTab);
			unregisterTab($activeTab);
			collectionUIDelete(
				$collectionUI,
				false); // don't delete the hypershade
			deleteUI $activeTab;

			// Recreate the collectionUI in the target tab.
			//
			$recreatedTab = recreateSceneTab(
				$panel,
				$targetTabLayout,
				$tabOptionVar,
				true /* reuse editors */);

		}

		// Bring the target tab to the front
		//
		tabLayout
			-edit
			-selectTab $recreatedTab
			$targetTabLayout;

        // Refresh the pane tabs.
        // Keep the focus with the tab which is moved.
        //
        if ($targetPaneIndex == 1)
        {
            hyperShadePanelSetActiveTabLayout($panel, "secondPaneTabs", true);
            hyperShadePanelSetActiveTabLayout($panel, "firstPaneTabs", true);
        }
        else
        {
            hyperShadePanelSetActiveTabLayout($panel, "firstPaneTabs", true);
            hyperShadePanelSetActiveTabLayout($panel, "secondPaneTabs", true);
        }

		// Give the target tab layout focus so the user can move the tab
		// again without having to reselect it.
		//
		paneLayout -edit -activePaneIndex $targetPaneIndex paneArrangement;

		// Update the tab layout option vars now that a tab has been moved
		//
		updateTabLayoutOptionVar($panel, $activeTabLayout);
		updateTabLayoutOptionVar($panel, $targetTabLayout);
	}

    refreshSceneTabFilterForm($panel);

	//	Signal the end of the construction operation.  Specify
	//	that the HyperShade is still around, so the active tabs
	//	must be refreshed.
	//
	hyperShadeEndConstruction( $panel, 1 );
}

proc removeTab(
	string $tab)
{
	//
	// Description:
	//	This procedure removes the specified tab from the hypershade panel.
	//

	// Flag this as a "construction" operation.  This will prevent
	//	many unnecessary refreshes of the various tabs as they are
	//	removed.
	// First save the current construction state. Previously this was not
	//	done, so at the end of this method when it ends construction, the
	//	calling proc (revertToDefaultTabs) was losing its contruction status
	//
	int $oldConstructionState = hyperShadeIsInConstruction("");
	string $panel = hyperShadePanelName();
	hyperShadeStartConstruction( $panel );

	// Delete the option var which describes this tab, so that it won't come
	// back the next time the user runs Maya
	//
	deleteTabOptionVar($tab);

	// Determine what kind of tab the current tab is (disk/graph/scene)
	//
	if (isDiskTab($tab))
	{
		string $libraryUI;
		$libraryUI = lookupComponentName($tab);

		// Delete the libraryUI and the active tab.
		//
		unregisterTab($tab);
		libraryUIDelete(
			$libraryUI,
			true); // delete the visors
		deleteUI $tab;
	}
	else if (isGraphTab($tab))
	{
		string $graphUI;
		$graphUI = lookupComponentName($tab);

		// Delete the graphUI and the active tab.
		//
		unregisterTab($tab);
		graphUIDelete(
			$graphUI,
			true); // delete the hypershade
		deleteUI $tab;
	}
	else if (isSceneTab($tab))
	{
		string $collectionUI;
		$collectionUI = lookupComponentName($tab);

		// Delete the collectionUI and the active tab.
		//
        removeSceneTabFilterReference($panel, $tab);
		unregisterTab($tab);

        // Delete the $collectionUI if it exists.
        //
        if ($collectionUI != "")
        {
            // Remove the collectionUI's hyperShadeName from the
            // $gFilterUIViewList.
            //
            string $hypershadeName = collectionUIHypershadeName($collectionUI);
            global string $gFilterUIViewList[];

            // Bug 215233:
            // Before removing the view, we must update several lists,
            // deleting entries which correspond to the view so that the
            // active tab doesn't contain past content of previously
            // deleted tabs.
            //
            // To do this, first identify the index of the view (since all the
            // arrays are index-matched).
            //
            // Note: These global variables are a subset of those listed in
            // filterUI.mel
            //
            int $i;
            int $matchedIndex = -1;
            for ($i=0 ; $i<size($gFilterUIViewList) ; $i++){
				if ($hypershadeName == $gFilterUIViewList[$i])
					$matchedIndex = $i;
			}
			if ($matchedIndex != -1){

				global string $gFilterUIPopupMenuList[];
				$gFilterUIPopupMenuList = stringArrayRemove({$gFilterUIPopupMenuList[$matchedIndex]}, $gFilterUIPopupMenuList);

				global string $gFilterUIFieldList[];
				$gFilterUIFieldList = stringArrayRemove({$gFilterUIFieldList[$matchedIndex]}, $gFilterUIFieldList);

				global string $gFilterUIFilterStatusControlList[];
				$gFilterUIFilterStatusControlList = stringArrayRemove({$gFilterUIFilterStatusControlList[$matchedIndex]}, $gFilterUIFilterStatusControlList);

				global string $gFilterUIImplicitFilterList[];
				$gFilterUIImplicitFilterList= stringArrayRemove({$gFilterUIImplicitFilterList[$matchedIndex]}, $gFilterUIImplicitFilterList);

				global string $gFilterUIRelatedFiltersProcedureList[];
				$gFilterUIRelatedFiltersProcedureList= stringArrayRemove({$gFilterUIRelatedFiltersProcedureList[$matchedIndex]}, $gFilterUIRelatedFiltersProcedureList);
            }

            $gFilterUIViewList = stringArrayRemove({$hypershadeName}, $gFilterUIViewList);

            // Delete collectionUI.
            //
		    collectionUIDelete(
			    $collectionUI,
			    true); // delete the hypershade
		}
		deleteUI $tab;

        // Figure out which tabLayout is active at the moment.
        //
        string $activeTabLayout = activeTabLayout($panel);

        // Refresh the active tab.
        //
        hyperShadePanelSetActiveTabLayout($panel, $activeTabLayout, true);
	}

    refreshSceneTabFilterForm($panel);

	//	Signal the end of the construction operation.  Specify
	//	that the HyperShade is still around, so the active tabs
	//	must be refreshed. But first make sure this proc wasn't called
	//	from a section that was already in construction mode.
	//
	if ($oldConstructionState == 0)
	{
		hyperShadeEndConstruction( $panel, 1 );
	}

}

proc removeActiveTab(
	string $panel)
{
	//
	// Description:
	//	This procedure removes the active tab from the hypershade panel.
	//

	setParent $panel;
	string $paneLayout = `setParent paneArrangement`;

	// Determine what tab layout is currently active.
	//
	string $tabLayout;
	$tabLayout = activeTabLayout($panel);

	string 	$activeTab = activeTab($panel);

	if (`lookupTabType($activeTab)` == "protected graph")
	{
		// The active tab is marked as a protected graph, which means we don't
		// want to allow it to be deleted or moved between tab layouts.
		//
		return;
	}

	removeTab($activeTab);

	// Delete the option var which describes this tab, so that it won't come
	// back the next time the user runs Maya
	//
	deleteTabOptionVar($activeTab);

	// Determine what kind of tab the current tab is (disk/graph/scene)
	//
	if (isDiskTab($activeTab))
	{
		string $libraryUI;
		$libraryUI = lookupComponentName($activeTab);

		// Delete the libraryUI and the active tab.
		//
		unregisterTab($activeTab);
		libraryUIDelete(
			$libraryUI,
			true); // delete the visors
		deleteUI $activeTab;
	}
	else if (isGraphTab($activeTab))
	{
		string $graphUI;
		$graphUI = lookupComponentName($activeTab);

		// Delete the graphUI and the active tab.
		//
		unregisterTab($activeTab);
		graphUIDelete(
			$graphUI,
			true); // delete the hypershade
		deleteUI $activeTab;
	}
	else if (isSceneTab($activeTab))
	{
		string $collectionUI;
		$collectionUI = lookupComponentName($activeTab);

		// Delete the collectionUI and the active tab.
		//
        removeSceneTabFilterReference($panel, $activeTab);
		unregisterTab($activeTab);
		collectionUIDelete(
			$collectionUI,
			true); // delete the hypershade
		deleteUI $activeTab;
	}

	// Update the tab layout option var now that the tab has been deleted
	//
	updateTabLayoutOptionVar($panel, $tabLayout);

    refreshSceneTabFilterForm($panel);
}

// Description:  This procedure is called to refresh the icon size
//      menu items.
//
proc refreshIconSize(string $panel, string $activeTab)
{
    int $isSceneTab = isSceneTab($activeTab);

    string $oldParent = `setParent -q`;
    setParent $panel;

    menuItem -edit -enable $isSceneTab -radioButton false smallIcons;
    menuItem -edit -enable $isSceneTab -radioButton false mediumIcons;
    menuItem -edit -enable $isSceneTab -radioButton false largeIcons;
    menuItem -edit -enable $isSceneTab -radioButton false superIcons;

	// Enable/disable the buttons and update images
	setParent browserButtons;
	string $image1 = $isSceneTab ? "iconSmall.png" : "iconSmall_disabled.png";
	string $image2 = $isSceneTab ? "iconMedium.png" : "iconMedium_disabled.png";
	string $image3 = $isSceneTab ? "iconLarge.png" : "iconLarge_disabled.png";
	string $image4 = $isSceneTab ? "iconSuper.png" : "iconSuper_disabled.png";

	iconTextRadioButton -edit -image1 $image1 -enable $isSceneTab
		smallIconsBrowserButton;
	iconTextRadioButton -edit -image1 $image2 -enable $isSceneTab
		mediumIconsBrowserButton;
	iconTextRadioButton -edit -image1 $image3 -enable $isSceneTab
		largeIconsBrowserButton;
	iconTextRadioButton -edit -image1 $image4 -enable $isSceneTab
		superIconsBrowserButton;
	setParent ..; // from browserButtons

    if ($isSceneTab)
    {
        // For scene tab, find out which iconSize was used by this
        // tab, and set that radioButton to on.
        //
        string $collectionUI = lookupComponentName( $activeTab );
        string $optionVar = lookupTabOptionVar($activeTab);

        string $iconSize = getIconSize($optionVar);
        menuItem -edit -radioButton true $iconSize;

		setParent browserButtons;
		string $iconSizeButton = $iconSize + "BrowserButton";
		iconTextRadioButton -edit -select $iconSizeButton;
		setParent ..; // from browserButtons
    }

    setParent $oldParent;
}

proc refreshViewOption(string $panel, string $activeTab)
{
    int $isSceneTab = isSceneTab($activeTab);
    int $isGraphTab = isGraphTab($activeTab);

    string $oldParent = `setParent -q`;
    setParent $panel;

    menuItem -edit -enable $isSceneTab -radioButton false asIcons;
    menuItem -edit -enable $isSceneTab -radioButton false asList;

	// Enable/disable the buttons and update images
	setParent browserButtons;
	string $image1 = $isSceneTab ? "viewIcon.png" : "viewIcon_disabled.png";
	string $image2 = $isSceneTab ? "viewList.png" : "viewList_disabled.png";

	iconTextRadioButton -edit -image1 $image1 -enable $isSceneTab
		asIconsBrowserButton;
	iconTextRadioButton -edit -image1 $image2 -enable $isSceneTab
		asListBrowserButton;
	setParent ..; // from browserButtons

    if ($isSceneTab)
    {
        // For scene tab, find out which view option was used by this
        // tab, and set that radioButton to on.
        //
        string $collectionUI = lookupComponentName( $activeTab );
		string $viewOption = collectionUIViewOption( $collectionUI );
        if ($viewOption == "")
        {
            // If the user has not specified a view option yet, then
            // we default to displaying icons (swatches).
            //
            $viewOption = "asIcons";
        }
        menuItem -edit -radioButton true $viewOption;

		setParent browserButtons;
		string $viewOptionButton = $viewOption + "BrowserButton";
		iconTextRadioButton -edit -select $viewOptionButton;
		setParent ..; // from browserButtons
    }
    setParent $oldParent;

	// disable/enable show-relationships menu item
	menuItem -edit -enable $isGraphTab showRelationshipsItem;

	// disable/enable merge-connections menu item
	menuItem -edit -enable $isGraphTab mergeConnectionsItem;

	if (getenv("MAYA_ENABLE_LEGACY_HYPERSHADE") == "1")
	{
		// disable/enable opaque-containers menu item
		menuItem -edit -enable $isGraphTab opaqueContainersItem;
	}

}

proc refreshSortOption(string $panel, string $activeTab)
{
    int $isSceneTab = isSceneTab($activeTab);

    string $oldParent = `setParent -q`;
    setParent $panel;

    menuItem -edit -enable $isSceneTab -radioButton false byName;
    menuItem -edit -enable $isSceneTab -radioButton false byType;
    menuItem -edit -enable $isSceneTab -radioButton false byTime;

	// Enable/disable the buttons and update images
	setParent browserButtons;
	string $image1 = $isSceneTab ? "sortName.png" : "sortName_disabled.png";
	string $image2 = $isSceneTab ? "sortType.png" : "sortType_disabled.png";
	string $image3 = $isSceneTab ? "sortTime.png" : "sortTime_disabled.png";

	iconTextRadioButton -edit -image1 $image1 -enable $isSceneTab
		byNameBrowserButton;
	iconTextRadioButton -edit -image1 $image2 -enable $isSceneTab
		byTypeBrowserButton;
	iconTextRadioButton -edit -image1 $image3 -enable $isSceneTab
		byTimeBrowserButton;
	setParent ..; // from browserButtons

    if ($isSceneTab)
    {
        // For scene tab, find out which sort option was used by this
        // tab, and set that radioButton to on.
        //
		string $collectionUI = lookupComponentName( $activeTab );
		string $sortOption = collectionUISortOption( $collectionUI );
        if ($sortOption == "")
        {
            // If the user has not specified a sort option yet, then
            // we set the sort option to alphabetical.
            //
            $sortOption = "byName";
        }
        menuItem -edit -radioButton true $sortOption;

		setParent browserButtons;
		string $sortOptionButton = $sortOption + "BrowserButton";
		iconTextRadioButton -edit -select $sortOptionButton;
		setParent ..; // from browserButtons
    }
    setParent $oldParent;
}

proc refreshReverseOption(string $panel, string $activeTab)
{
    int $isSceneTab = isSceneTab($activeTab);

    string $oldParent = `setParent -q`;
    setParent $panel;

	// Enable/disable the option
	//
	menuItem -edit -enable $isSceneTab reverseOrder;

	// Enable/disable the buttons and update images
	setParent browserButtons;
	string $image1 = $isSceneTab ? "reverseOrder.png" : "reverseOrder_disabled.png";

	iconTextCheckBox -edit -image1 $image1 -enable $isSceneTab
		reverseOrderBrowserButton;
	setParent ..; // from browserButtons

    if ($isSceneTab)
    {
        // For scene tab, find out whether to reverse, and
		// set checkBox accordingly
        //
		string $collectionUI = lookupComponentName( $activeTab );
		string $reverseOption = collectionUIReverseOption( $collectionUI );
		if( $reverseOption == "true" ){
			menuItem -edit -checkBox true reverseOrder;

			setParent browserButtons;
			iconTextCheckBox -edit -value true reverseOrderBrowserButton;
			setParent ..; // from browserButtons
		}else{ //$reverseOption == "false" or "" (not yet specified)
			menuItem -edit -checkBox false reverseOrder;

			setParent browserButtons;
			iconTextCheckBox -edit -value false reverseOrderBrowserButton;
			setParent ..; // from browserButtons
		}
    }
    setParent $oldParent;
}

proc refreshToolbar(
	string $panel)
{
	setParent $panel;

	string $activeTab = activeTab($panel);

	// Enable the Clear Graph and Rearrange Graph buttons only if a graph tab
	// (work area) is visible.
	//
	int $enable;
	$enable = isGraphTabVisible($panel);

	iconTextButton
		-edit
		-enable $enable
		clearGraphButton;

	iconTextButton
		-edit
		-enable $enable
		rearrangeGraphButton;

	if (getenv("MAYA_ENABLE_LEGACY_HYPERSHADE") == "1")
	{
		// The radio buttons which indicate which tab sections are shown need
		// to be kept in sync with the optionVar which stores that information.
		//
		if (`optionVar -query hyperShadePanelTabSectionsShown`
				== "showTopTabsOnly")
		{
			iconTextRadioButton
				-edit
				-select
				showTopTabsOnlyButton;
		}
		else if (
			`optionVar -query hyperShadePanelTabSectionsShown`
				== "showBottomTabsOnly")
		{
			iconTextRadioButton
				-edit
				-select
				showBottomTabsOnlyButton;
		}
		else
		{
			iconTextRadioButton
				-edit
				-select
				showTopAndBottomTabsButton;
		}
	}

    global string $gHypershadeNodeEditor;
	nodeEditor -edit -gridVisibility `optionVar -q "HypershadeGridVisibility"` $gHypershadeNodeEditor;
	nodeEditor -edit -gridSnap `optionVar -q "HypershadeGridSnap"` $gHypershadeNodeEditor;
}

proc refreshCreateMenu(
	string $panel)
{
	//
	// Description:
	//	This procedure is called after a change is made which would require the
	//	hypershade panel Create menu to be updated to reflect a new state of
	//	the UI. For example, when the user changes the state of the With
	//	Shading Group checkbox in the create render node dialog, the menu
	//	needs to be refreshed so that the menu item which reflects the state of
	//	that checkbox is kept in sync. This procedure is not invoked
	//	automatically when a change which affects the menus occurs, it must be
	//	explicitly called.
	//	This procedure refreshes the Create menu as appropriate considering the
	//	current state of the UI.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	setParent $panel;

	string $menuPrefix = "hyperShadePanelMenu";
	string $menu = ($menuPrefix + "CreateMenu");

	// Since the Create menu is built each time it is opened, the menu
	// items it contains may not exist if it has not yet been opened.
	// We will only try to update the menu if the menu items actually
	// exist.
	//
	if (	(`menu -exists $menu`)
		&&	(`menu -query -numberOfItems $menu` > 0))
	{
		setParent -menu $menu;

		// Update the create textures with placement checkbox
		//
		menuItem
			-edit
			-checkBox
				`optionVar -query createTexturesWithPlacement`
			createIncludePlacementItem;

		// Update the normal/projection/stencil radiobuttons
		//
		menuItem
			-edit
			-radioButton
				(`optionVar -query create2dTextureType` == "normal")
			textureAsNormalItem;
		menuItem
			-edit
			-radioButton
				(`optionVar -query create2dTextureType` == "projection")
			textureAsProjectionItem;
		menuItem
			-edit
			-radioButton
				(`optionVar -query create2dTextureType` == "stencil")
			textureAsStencilItem;

		// Update the create materials with shading groups checkbox
		//
		menuItem
			-edit
			-checkBox
				`optionVar -query createMaterialsWithShadingGroup`
			includeShadingGroupItem;
	}

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;
}

proc refreshTabsMenu(
	string $panel)
{
	//
	// Description:
	//	This procedure is called after a change is made which would require the
	//	hypershade panel Tabs menu to be updated to reflect a new state of the
	//	UI. For example, when the user presses one of the toolbar buttons which
	//	changes which tab sections are shown, the menus need to be refreshed so
	//	that the menu items which indicate which tab sections are shown are
	//	properly updated.
	//	This procedure is not invoked automatically when a change which affects
	//	the menus occurs, it must be explicitly called.
	//	This procedure refreshes the Tabs menu as appropriate considering the
	//	current state of the UI.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	setParent $panel;

	string $menuPrefix = "hyperShadePanelMenu";
	string $menu = ($menuPrefix + "TabsMenu");

	if (`menu -exists $menu`)
	{
		setParent -menu $menu;

		if (getenv("MAYA_ENABLE_LEGACY_HYPERSHADE") == "1")
		{
			// Move Tab Up and Move Tab Down should be enabled if and only if both
			// tab sections are shown.
			//
			menuItem
				-edit
				-enable
					(`optionVar -query hyperShadePanelTabSectionsShown`
						== "showTopAndBottomTabs")
				tabsMoveTabUpItem;
			menuItem
				-edit
				-enable
					(`optionVar -query hyperShadePanelTabSectionsShown`
						== "showTopAndBottomTabs")
				tabsMoveTabDownItem;

			// The radio buttons which indicate which tab sections are shown need
			// to be kept in sync with the optionVar which stores that information.
			//
			menuItem
				-edit
				-radioButton
					(`optionVar -query hyperShadePanelTabSectionsShown`
						== "showTopTabsOnly")
				tabsShowTopTabsOnlyItem;
			menuItem
				-edit
				-radioButton
					(`optionVar -query hyperShadePanelTabSectionsShown`
						== "showBottomTabsOnly")
				tabsShowBottomTabsOnlyItem;
			menuItem
				-edit
				-radioButton
					(`optionVar -query hyperShadePanelTabSectionsShown`
						== "showTopAndBottomTabs")
				tabsShowTopAndBottomTabsItem;
		}
	}

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;
}

proc refreshGraphMenu(
	string $panel)
{
	//
	// Description:
	//	This procedure is called after a change is made which would require the
	//	hypershade panel Graph menu to be updated to reflect a new state of the
	//	UI. For example, when the user selects a new tab, the menus may need
	//	to be refreshed so that menu items which apply only if the active tab
	//	is a graph tab may be dimmed or undimmed. This procedure is not invoked
	//	automatically when a change which affects the menus occurs, it must be
	//	explicitly called.
	//	This procedure refreshes the Graph menu as appropriate considering the
	//	current state of the UI.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	setParent $panel;

	string $menuPrefix = "hyperShadePanelMenu";
	string $menu = ($menuPrefix + "GraphMenu");

	if (`menu -exists $menu`)
	{
		setParent -menu $menu;

		// Enable some graph menu items only if a graph tab (work area) is
		// visible
		//
		int $enable;
		$enable = isGraphTabVisible($panel);

		menuItem
			-edit
			-enable $enable
			clearGraphItem;
		menuItem
			-edit
			-enable $enable
			rearrangeGraphItem;
		menuItem
			-edit
			-enable $enable
			showPreviousGraphItem;
		menuItem
			-edit
			-enable $enable
			showNextGraphItem;
	}

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;
}

global proc hyperShadePanelRefreshMenu(
	string $panel,
	string $menu)
{
	//
	// Description:
	//	This procedure is called whenever some procedure outside of this file
	//	needs to cause one of the hyperShadePanel menus to be updated.
	//	This procedure calls the appropriate local procedure to update the
	//	specified menu.
	//

	if ($menu == "Create")
	{
		refreshCreateMenu($panel);
	}
	else if ($menu == "Tabs")
	{
		refreshTabsMenu($panel);
	}
	else if ($menu == "Graph")
	{
		refreshGraphMenu($panel);
	}
	else
	{
		// Somebody is trying to refresh a menu for which there is no refresh
		// procedure.
		//
		warning (uiRes("m_hyperShadePanel.kTryingToRefreshMenu"));
	}
}

proc removeUnwantedNodes(string $ned)
{
	global string $gSoloShaderName;
	if (`objExists $gSoloShaderName`) {
		nodeEditor -e -rem $gSoloShaderName $ned;
	}
}

global proc hyperShadePanelSetActiveTabLayout(
	string $panel,
    string $tabLayout,
    string $refreshFrontPane)
{
	//
	// Description:
	//	This procedure is invoked when the focus command on the hyper
    //  shade is run; this will occur when the mouse button is released
    //  in the view.
	//

	setParent paneArrangement;

    if ($tabLayout == "firstPaneTabs")
	{
        paneLayout -e -activePaneIndex 1 paneArrangement;
	}
    else if ($tabLayout == "secondPaneTabs")
	{
		if (`paneLayout -query -configuration paneArrangement` == "single")
		{
			paneLayout -e -activePaneIndex 1 paneArrangement;
		}
		else
		{
			paneLayout -e -activePaneIndex 2 paneArrangement;
		}
	}

	string $activeTab = activeTab( $panel );

    if ($activeTab == "")
    {
        // There is no tab in this tabLayout.  Nothing to do.
        //
        return;
    }

	//	When the HyperShade is created, hidden tabs are not
	//	enabled, so we must enable them when they become visible,
	//	i.e. now.
	//
	if( isSceneTab( $activeTab ) )
	{
		string $collectionUI = lookupComponentName( $activeTab );

        // If the $collectionUI is an empty string, then it means
        // we have not created the $collectionUI for this $activeTab.
        // So we create it.
        //
        if ($collectionUI == "")
        {
            refreshSceneTabContent(
                $panel,
	            $tabLayout,
                $activeTab,
	            false);
		    $collectionUI = lookupComponentName( $activeTab );
        }
        else
        {
            // Since the tab content is not newly created, it
            // needs to be refreshed to reflect the recent update
            // of bins being selected.
            //
            if ($refreshFrontPane)
            {
                evalDeferred("refreshHyperShadePaneFrontTab "+$tabLayout+" false");
            }
        }
	}

    refreshSceneTabFilterForm($panel);
    refreshIconSize($panel, $activeTab);
	refreshViewOption($panel, $activeTab);
	refreshSortOption($panel, $activeTab);
	refreshReverseOption($panel, $activeTab);
	refreshToolbar($panel);
	refreshGraphMenu($panel);
}

proc int topTabsShown(
	string $panel)
{
	//
	// Description:
	//	This procedure determines whether the top tab section of the hypershade
	//	panel is being displayed.
	//
	// Returns:
	//	True if the top tab section is being displayed, false otherwise.
	//
	string $tabSectionsShown =
		`optionVar -query hyperShadePanelTabSectionsShown`;

	return (
			($tabSectionsShown == "showTopTabsOnly")
		||	($tabSectionsShown == "showTopAndBottomTabs"));
}

proc int bottomTabsShown(
	string $panel)
{
	//
	// Description:
	//	This procedure determines whether the bottom tab section of the
	//	hypershade panel is being displayed.
	//
	// Returns:
	//	True if the bottom tab section is being displayed, false otherwise.
	//
	string $tabSectionsShown =
		`optionVar -query hyperShadePanelTabSectionsShown`;

	return (
			($tabSectionsShown == "showBottomTabsOnly")
		||	($tabSectionsShown == "showTopAndBottomTabs"));
}

proc showTopTabsOnly(
	string $panel)
{
	//
	// Description:
	//	This procedure causes the hypershade to reconfigure so that only the
	//	top tab section is visible.
	//

	setParent $panel;
	paneLayout
		-edit
		-configuration "single"
		-setPane firstPaneTabs 1
		-activePaneIndex 1
		paneArrangement;

	// Update the option var which remembers which tab sections are shown
	//
	optionVar
		-stringValue
			hyperShadePanelTabSectionsShown
			"showTopTabsOnly";

	// Update the menus which are affected by this change
	//
    hyperShadePanelSetActiveTabLayout($panel, "firstPaneTabs", true);
	refreshTabsMenu($panel);
	refreshToolbar($panel);
}

proc showBottomTabsOnly(
	string $panel)
{
	//
	// Description:
	//	This procedure causes the hypershade to reconfigure so that only the
	//	bottom tab section is visible.
	//

	setParent $panel;
	paneLayout
		-edit
		-configuration "single"
		-setPane secondPaneTabs 1
		-activePaneIndex 1
		paneArrangement;

	// Update the option var which remembers which tab sections are shown
	//
	optionVar
		-stringValue
			hyperShadePanelTabSectionsShown
			"showBottomTabsOnly";

	// Update the menus which are affected by this change
	//
    hyperShadePanelSetActiveTabLayout($panel, "secondPaneTabs", true);
	refreshTabsMenu($panel);
	refreshToolbar($panel);
}

proc showTopAndBottomTabs(
	string $panel)
{
	//
	// Description:
	//	This procedure causes the hypershade to reconfigure so that both the
	//	top and bottom tab sections are visible.
	//

	setParent $panel;

	int $activePaneIndex;

	// Determine whether it is the top or the bottom which is currently
	// visible, and thus which pane should be active once both are displayed.
	//
	if (topTabsShown($panel))
	{
		$activePaneIndex = 1;
	}
	else
	{
		$activePaneIndex = 2;
	}

	paneLayout
		-edit
		-configuration "horizontal2" // stacked
		-setPane firstPaneTabs 1
		-setPane secondPaneTabs 2
		-activePaneIndex 1
		paneArrangement;

	// Update the option var which remembers which tab sections are shown
	//
	optionVar
		-stringValue
			hyperShadePanelTabSectionsShown
			"showTopAndBottomTabs";

	// Update the menus which are affected by this change
	//
    hyperShadePanelSetActiveTabLayout($panel, "firstPaneTabs", true);
    hyperShadePanelSetActiveTabLayout($panel, "secondPaneTabs", true);
	refreshTabsMenu($panel);
	refreshToolbar($panel);
}

proc selectTab(
	string $panel,
	string $tab)
{
	//
	// Description:
	//	This procedure selects the specified tab, bringing it to the front of
	//	its tab layout and making the pane in which it resides the active pane.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	setParent $tab;
	string $tabLayout = `setParent ..`;
	string $tabPathTokens[];

	tokenize($tab, "|", $tabPathTokens);

	string $tabShortName = $tabPathTokens[size($tabPathTokens) - 1];
	string $tabLayoutShortName = $tabPathTokens[size($tabPathTokens) - 2];

	// If the tab to be selected is in a tab section which is not currently
	// shown, we will switch to show both tab sections so the user can see the
	// tab.
	//
	if (
			(	($tabLayoutShortName == "firstPaneTabs")
			&& 	(!topTabsShown($panel)))
		||	(	($tabLayoutShortName == "secondPaneTabs")
			&& 	(!bottomTabsShown($panel))))
	{
		showTopAndBottomTabs($panel);
	}

	// Select the tab
	//
	tabLayout
		-edit
		-selectTab $tabShortName
		$tabLayout;

	// Set the active pane to the layout which contains the selected tab
	//
	setParent $panel;

	if (
			($tabLayoutShortName == "firstPaneTabs")
		||	(!topTabsShown($panel)))
	{
		paneLayout
			-edit
			-activePaneIndex 1
			paneArrangement;
	}
	else
	{
		paneLayout
			-edit
			-activePaneIndex 2
			paneArrangement;
	}

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;
}

proc revertToDefaultTabs(
	string $panel)
{
	//
	// Description:
	//	This procedure removes all tabs from the hypershade panel and creates
	//	the default set of tabs.
	//

	//	flag this as a "construction" operation.  This will prevent
	//	many unnecessary refreshes of the various tabs as they are
	//	removed.
	//
	hyperShadeStartConstruction( $panel );


	setParent $panel;
	string $mainForm = `setParent mainForm`;
	formLayout -edit -manage false $mainForm;

	// Delete all tabs
	//
	int $i;
	string $tabArray[];
	string $tab;

    // Store previous activePane.
    //
    string $previousActivePane = `paneLayout -query -activePane  paneArrangement`;

    paneLayout -edit -activePane "firstPaneTabs" paneArrangement;

	$tabArray = `tabLayout -query -childArray firstPaneTabs`;

	for ($i = 0; $i < size($tabArray); $i++)
	{
		setParent $panel;
		$tab = `setParent $tabArray[$i]`;
		removeTab($tab);
	}

    paneLayout -edit -activePane "secondPaneTabs" paneArrangement;
	$tabArray = `tabLayout -query -childArray secondPaneTabs`;

	for ($i = 0; $i < size($tabArray); $i++)
	{
		setParent $panel;
		$tab = `setParent $tabArray[$i]`;
		removeTab($tab);
	}

    // Restore previous activePane.
    //
    paneLayout -edit -activePane $previousActivePane paneArrangement;

	formLayout -edit -manage true $mainForm;

	// Create the default tabs
	//
	string $materialsTab     = (uiRes("m_hyperShadePanel.kMaterialsTab"));
	string $texturesTab      = (uiRes("m_hyperShadePanel.kTexturesTab"));
	string $utilitiesTab     = (uiRes("m_hyperShadePanel.kUtilitiesTab"));
	string $renderingTab     = (uiRes("m_hyperShadePanel.kRenderingTab"));
	string $lightsTab        = (uiRes("m_hyperShadePanel.kLightsTab"));
	string $camerasTab       = (uiRes("m_hyperShadePanel.kCamerasTab"));
	string $shadingGroupsTab = (uiRes("m_hyperShadePanel.kShadingGroupsTab"));
	string $bakeSetsTab      = (uiRes("m_hyperShadePanel.kBakeSetsTab"));
	string $projectsTab      = (uiRes("m_hyperShadePanel.kProjectsTab"));
	string $containerNodesTab = (uiRes("m_hyperShadePanel.kAssetNodesTab"));
	string $workAreaTab      = (uiRes("m_hyperShadePanel.kWorkAreaTab"));

	createSceneTab(
		$panel,
		"firstPaneTabs",
		$materialsTab,
		"MaterialsAndShaderGlow"
		);

	createSceneTab(
		$panel,
		"firstPaneTabs",
		$texturesTab,
		"Textures");

	createSceneTab(
		$panel,
		"firstPaneTabs",
		$utilitiesTab,
		"Utilities");

	createSceneTab(
		$panel,
		"firstPaneTabs",
		$renderingTab,
		"Rendering");

	createSceneTab(
		$panel,
		"firstPaneTabs",
		$lightsTab,
		"LightsAndOpticalFX"
		);

	createSceneTab(
		$panel,
		"firstPaneTabs",
		$camerasTab,
		"Cameras");

	createSceneTab(
		$panel,
		"firstPaneTabs",
		$shadingGroupsTab,
		"ShadingGroups");

	createSceneTab(
		$panel,
		"firstPaneTabs",
		$bakeSetsTab,
		"BakeSets");

	string $projectsDir = `internalVar -userWorkspaceDir`;

	createDiskTab(
		$panel,
		"firstPaneTabs",
		$projectsTab,
		$projectsDir);

	createSceneTab(
		$panel,
		"firstPaneTabs",
		$containerNodesTab,
		"ContainerNodes");

	createGraphTab(
		$panel,
		"secondPaneTabs",
		$workAreaTab,
		true);

	string $shaderLibraryDir = `getenv MAYA_SHADER_LIBRARY_PATH`;

	if ( $shaderLibraryDir != "" &&
		 `filetest -d $shaderLibraryDir` )
	{
		optionVar -intValue hyperShadeShaderLibraryTabCreated 1;
		string $shaderLibraryTab = (uiRes("m_hyperShadePanel.kShaderLibraryTab"));
		createDiskTab(
			$panel,
			"secondPaneTabs",
			$shaderLibraryTab,
			$shaderLibraryDir);
	}

	// If this is the first time the user has opened hypershade since 3.0, and
	// they have custom disk folders defined in their userPrefs, we will create
	// a tab for each of those custom disk folders.
	//
	if (	(!`optionVar -exists customFoldersConvertedForHypershade`)
		&&	(`optionVar -exists visorCustomDiskFolders`))
	{
		// Get from an optionVar the list of directories for which custom disk
		// folders were created. Create a disk tab for each.
		//
		int 	$i;
		string 	$customFolderNameArray[];

		$customFolderNameArray = `optionVar -query visorCustomDiskFolders`;

		for ($i = 0; $i < size($customFolderNameArray); $i++)
		{
			// Tokenize the path stored in $customFolderNameArray[$i] so that
			// we can have a shorter name for the tab.
			//
			string $pathTokens[];
			tokenize $customFolderNameArray[$i] "/" $pathTokens;

			createDiskTab(
				$panel,
				"secondPaneTabs",
				$pathTokens[size($pathTokens) - 1],
				$customFolderNameArray[$i]);
		}

		if (`optionVar -exists customFoldersConvertedForVisor`)
		{
			// These custom disk folders have also already been added to Visor.
			// This means that we no longer need to keep the
			// visorCustomDiskFolders optionVar around.
			// We also don't need the customFoldersConvertedForVisor optionVar
			// anymore because it has served its purpose.
			//
			optionVar -remove visorCustomDiskFolders;
			optionVar -remove customFoldersConvertedForVisor;
		}
		else
		{
			// Set an optionVar to indicate that these custom disk folders have
			// already been added to Hypershade
			//
			optionVar -intValue customFoldersConvertedForHypershade true;
		}
	}

	// Update the tab layout option vars now that the tabs have been reverted
	//
	updateTabLayoutOptionVar($panel, "firstPaneTabs");
	updateTabLayoutOptionVar($panel, "secondPaneTabs");

	// Now that we have created all the tabs we need, we delete any option vars
	// which describe tabs that did not get used.
	//
	deleteUnusedTabOptionVars($panel);

    // Refresh the scene tab filter form in the toolbar.
    //
    refreshSceneTabFilterForm($panel);

	//	Signal the end of the construction operation.  Specify
	//	that the HyperShade is still around, so the active tabs
	//	must be refreshed.
	//
	hyperShadeEndConstruction( $panel, 1 );
}

proc initTabs(string $panel)
{
	//
	// Description:
	//	This procedure is called the first time the hypershade panel is opened
	//	during a Maya session.
	//	This procedure uses the optionVars which describe the contents of the
	//	hypershade panel tab layouts and tabs in order to recreate the
	//	hypershade panel as it appeared when it was last open.
	//	If no such optionVars exist, this procedure causes the default tabs to
	//	be created.
	//

	// Clear the lookup table because we are creating a fresh visor panel
	//
	global string $gHyperShadePanelLookupTable[];
	lookupTableReset($gHyperShadePanelLookupTable);

	// In Maya 4.0, trying to reuse editors was problematic because the
	// contents of the editor would be badly positioned when hypershade was
	// reopened with a reused editor. So we will not reuse editors for 4.0, but
	// may do so in the future.
	//
	int $reuseEditors = false;

	if (!`optionVar -exists hyperShadeFirstPaneTabs`)
	{
		// The option vars which should contain the names of the option vars
		// describing the tabs in the tab layouts do not exist.
		// This indicates that this is the first time the user is using
		// this version of Maya, or that their prefs have been deleted.
		// In this situation we want to fill the shader editor with what we
		// consider to be useful and appropriate default tabs.
		//
		revertToDefaultTabs($panel);
		return;
	}

	// If we get to here, it means the user already has option vars in their
	// prefs to describe the tabs they expect to see in their shader editor.
	//
	// We will read ther user's preferred set of tabs from optionVars and
	// create them.
	//
	int $i;

    // First Pane
    //

    // If the optionVar does not exists, it means that there is no
    // tab in it.  If it exists, recreate the tabs.
    //
    if (`optionVar -exists hyperShadeFirstPaneTabs` &&
        size(`optionVar -q hyperShadeFirstPaneTabs`) != 0)
    {
	    string $firstPaneTabVars[];
	    $firstPaneTabVars = `optionVar -query hyperShadeFirstPaneTabs`;

	    setParent $panel;

	    for ($i = 0; $i < size($firstPaneTabVars); $i++)
	    {
		    string $type = recreateTab(
			    $panel,
			    "firstPaneTabs",
			    $firstPaneTabVars[$i],
			    $reuseEditors);
	    }
    }

    // Second Pane
    //

    // If the optionVar does not exists, it means that there is no
    // tab in it.  If it exists, recreate the tabs.
    //
    if (`optionVar -exists hyperShadeSecondPaneTabs` &&
        size(`optionVar -q hyperShadeSecondPaneTabs`) != 0)
    {
		string $secondPaneTabVars[];
		$secondPaneTabVars = `optionVar -query hyperShadeSecondPaneTabs`;

		setParent $panel;

		for ($i = 0; $i < size($secondPaneTabVars); $i++)
		{
			string $type = recreateTab(
				$panel,
				"secondPaneTabs",
				$secondPaneTabVars[$i],
				$reuseEditors);
		}

		// If the shader library has never been added as a hypershade tab, we will
		// check to see if it exists and add it if it does.
		// In this way, the user will always get a shader library tab created for
		// them when they install the shader library, but if they delete that tab
		// it won't come back unless they revert to default tabs or delete their
		// userPrefs.
		//
		if (!`optionVar -exists hyperShadeShaderLibraryTabCreated`)
		{
			string $shaderLibraryDir = `getenv MAYA_SHADER_LIBRARY_PATH`;

			if ( $shaderLibraryDir != ""  &&
				 `filetest -d $shaderLibraryDir` )
			{
				optionVar -intValue hyperShadeShaderLibraryTabCreated 1;
				createDiskTab(
					$panel,
					"secondPaneTabs",
					"Shader Library",
					$shaderLibraryDir);
			}
		}
    } 
	else { 
		// The hyperShadeSecondPaneTabs option var either does not exist
		// or is empty (MAYA-11671), so just create the default Work Area tab 
		string $workAreaTab = uiRes("m_hyperShadePanel.kWorkAreaTab");
		createGraphTab(
			$panel,
			"secondPaneTabs",
			$workAreaTab,
			true);
	}

	// Now that we have created all the tabs we need, we delete any option vars
	// which describe tabs that did not get used.
	//
	deleteUnusedTabOptionVars($panel);

	// Update the toolbar and menus to reflect the currently active tab.
	//
	refreshToolbar($panel);
	refreshGraphMenu($panel);
}

global proc hyperShadePanelRootDirectoryBrowse()
{
	//
	// Description:
	//	This procedure is called when the user clicks on the browse button
	//	beside the root directory text field in the create new tab dialog for
	//	disk tabs.
	//	This procedure opens a file browser so the user can browse for the
	//	directory they want the tab to point at.
	//

	setParent hyperShadePanelCreateNewTabWindow;

	string $initialDirectory = `textField -query -fileName rootDirectoryField`;

	if (`filetest -d $initialDirectory`)
	{
		workspace -dir $initialDirectory;
	}
	else
	{
		string  $workspace = `workspace -query -fullName`;
		setWorkingDirectory($workspace, "", "");
	}
    string $openTitle = (uiRes("m_hyperShadePanel.kOpen"));
	fileBrowser("hyperShadePanelRefreshRootDirectoryBrowseField", $openTitle, "", 4);
}

global proc int hyperShadePanelRefreshRootDirectoryBrowseField(
	string $directory,
	string $type)
{
	//
	// Description:
	//	This procedure is called by the file browser the user uses to choose a
	//	directory to which a new disk tab will point.
	//	This procedure confirms that the user's selection is indeed a
	//	directory. If so, this procedure updates the root directory text field
	//	of the create new tab window.
	//
	// Returns:
	//	1 if the $directory was a valid directory name, thereby causing the
	//	file browser to close.
	//	0 if the $directory was not a directory name, thereby causing the file
	//	browser to remain open.
	//

	if (`window -exists hyperShadePanelCreateNewTabWindow`)
	{
		if (`filetest -d $directory`)
		{
			setParent hyperShadePanelCreateNewTabWindow;
			textField
				-edit
				-fileName $directory
				rootDirectoryField;
			return 1;
		}
		else
		{
			confirmDialog
				-title (uiRes("m_hyperShadePanel.kInvalidDirectory"))
				-message
					(uiRes("m_hyperShadePanel.kRootDirectoryIsInvalid"))
				-messageAlign center
				-button (uiRes("m_hyperShadePanel.kRootDirectoryBrowserClose")) ;
			return 0;
		}
	}
	else
	{
		return 1;
	}
}

global proc hyperShadePanelCreateNewTabFinish(
	string $panel,
	int $dismiss)
{
	//
	// Description:
	//	This procedure is called when the user clicks on the Create button in
	//	the create new tab dialog.
	//	This procedure examines the settings of the controls in the create new
	//	tab dialog to determine the details of the tab the user wants to
	//	create, and then creates the tab.
	//

	setParent hyperShadePanelCreateNewTabWindow;
	string 	$tabLabel;
	int 	$tabTypeIndex;
	string 	$tabLayout;

	$tabLabel = `textFieldGrp -query -text newTabNameGrp`;
    if ($tabLabel == "")
    {
        // Empty string is not allowed as tab label.
        //
        warning (uiRes("m_hyperShadePanel.kEmptyStringLabel"));
        return;
    }

	$tabTypeIndex = `radioButtonGrp -query -select tabTypeGrp`;
	if (getenv("MAYA_ENABLE_LEGACY_HYPERSHADE") == "1")
	{
		int $initialPlacementIndex = `radioButtonGrp -q -select initialPlacementGrp`;

		if ($initialPlacementIndex == 1)
		{
			$tabLayout = "firstPaneTabs";
		}
		else
		{
			$tabLayout = "secondPaneTabs";
		}
	}
	else
	{
		$tabLayout = "firstPaneTabs";
	}

	string $newTab = "";

	switch ($tabTypeIndex)
	{
		case 1: // Scene
			string $filter;
			$filter = `optionMenuGrp -query -value sceneTabFilterGrp`;

			//	Take the menu item text and figure out the internal name
			//	of this type of filtered collection.
			//
			string $internalFilterName = filteredCollection_InternalName( $filter );

			//	flag this as a "construction" operation.  This will prevent
			//	many unnecessary refreshes of the various tabs as they are
			//	removed.
			//
			hyperShadeStartConstruction( $panel );

			$newTab = createSceneTab(
				$panel,
				$tabLayout,
				$tabLabel,
				$internalFilterName);
			break;
		case 2: // Disk
			string $rootDirectory =
				`textField -query -text rootDirectoryField`;
			if (!`filetest -d $rootDirectory`)
			{
				confirmDialog
					-title (uiRes("m_hyperShadePanel.kCreateNewTabInvalidDirectory"))
					-message
						(uiRes("m_hyperShadePanel.kCreateNewTabRootDirectoryIsInvalid"))
					-messageAlign center
					-parent hyperShadePanelCreateNewTabWindow
					-button (uiRes("m_hyperShadePanel.kCreateNewTabClose")) ;
				return;
			}
			int $showFilesOnly =
				`checkBoxGrp -query -value1 onlyShowFilesCheckBox`;

			if (`about -win`)
			{
				// The root directory must end in a "\" on NT otherwise weird
				// things happen.
				//
				$rootDirectory = ($rootDirectory + "\\");
			}

			$newTab = createDiskTab(
				$panel,
				$tabLayout,
				$tabLabel,
				$rootDirectory);

			// Specify whether the new tab should show directories
			//
			if ($showFilesOnly)
			{
				string $libraryUI = lookupComponentName($newTab);
				libraryUIShowFilesOnly($libraryUI);
			}
			break;
		case 3: // Graph
			$newTab = createGraphTab(
				$panel,
				$tabLayout,
				$tabLabel,
				false);
			break;
		default:
			break;
	}

	// Update the tab layout option vars now that a tab has been added
	//
	updateTabLayoutOptionVar($panel, $tabLayout);

	if ($newTab != "")
	{
		// Bring the new tab to the front
		//
		selectTab($panel, $newTab);
	}

	if( $tabTypeIndex == 1 )
	{
		//	Signal the end of the construction operation.  Specify
		//	that the HyperShade is still around, so the active tabs
		//	must be refreshed.
		//
		//	Do this here because we want to refresh the panel that
		//	is active at the end of the operation.
		//
		hyperShadeEndConstruction( $panel, 1 );
	}


	if ($dismiss)
	{
		// Close the create new tab dialog
		//
		deleteUI hyperShadePanelCreateNewTabWindow;
	}
}

global proc hyperShadePanelRefreshCreateNewTabWindow()
{
	//
	// Description:
	//	This procedure is called when the user changes the type of tab to be
	//	created in the create new tab dialog.
	//	This procedure updates the UI of the create new tab dialog to show only
	//	the options which are applicable to a tab of the user's chosen type.
	//

	setParent hyperShadePanelCreateNewTabWindow;

	int $tabTypeIndex = `radioButtonGrp -query -select tabTypeGrp`;

	switch ($tabTypeIndex)
	{
		case 1: // Scene
			optionMenuGrp
				-edit
				-manage true
				sceneTabFilterGrp;
			rowLayout
				-edit
				-manage false
				directoryNameLayout;
			checkBoxGrp
				-edit
				-manage false
				onlyShowFilesCheckBox;
			break;
		case 2: // Disk
			optionMenuGrp
				-edit
				-manage false
				sceneTabFilterGrp;
			rowLayout
				-edit
				-manage true
				directoryNameLayout;
			checkBoxGrp
				-edit
				-manage true
				onlyShowFilesCheckBox;
			break;
		case 3: // Graph
		case 4:
			optionMenuGrp
				-edit
				-manage false
				sceneTabFilterGrp;
			rowLayout
				-edit
				-manage false
				directoryNameLayout;
			checkBoxGrp
				-edit
				-manage false
				onlyShowFilesCheckBox;
			break;
		default:
			break;
	}
}

proc string getPanelWindow(
	string $panel)
{
	string $tokens[];
	string $control = `scriptedPanel -q -ctl $panel`;
	tokenize $control "|" $tokens;
	return $tokens[0];
}

proc createNewTab(
	string $panel)
{
	//
	// Description:
	//	This procedure is called when the user chooses Create New Tab... from
	//	the hypershade panel menu.
	//	This procedure builds and opens the create new tab dialog.
	//

	if (`window -exists hyperShadePanelCreateNewTabWindow`)
	{
		showWindow hyperShadePanelCreateNewTabWindow;
		return;
	}

	//
	// If we get to here, the create new tab window does not already exist, so
	// we will create it.
	//
	int $windowWidth = 450;
	int $windowHeight = 200;

	string $panelWindow = getPanelWindow($panel);
	window
		-title (uiRes("m_hyperShadePanel.kCreateNewTabTitle"))
		-width $windowWidth
		-height $windowHeight
		-iconName (uiRes("m_hyperShadePanel.kNewTab"))
		-parent $panelWindow
		hyperShadePanelCreateNewTabWindow;

	setUITemplate -pushTemplate DefaultTemplate;

	formLayout mainForm;
		scrollLayout
			-horizontalScrollBarThickness 0
			mainScroll;

			columnLayout -adj true scrollColumn;
				textFieldGrp
					-label (uiRes("m_hyperShadePanel.kNewTabName"))
					newTabNameGrp;
				string $tabTypeLabel = (uiRes("m_hyperShadePanel.kTabType"));
				string $sceneLabel = (uiRes("m_hyperShadePanel.kScene"));
				string $diskLabel = (uiRes("m_hyperShadePanel.kDisk"));
				if (getenv("MAYA_ENABLE_LEGACY_HYPERSHADE") == "1")
				{
					radioButtonGrp
						-label (uiRes("m_hyperShadePanel.kInitialPlacement"))
						-numberOfRadioButtons 2
						-label1 (uiRes("m_hyperShadePanel.kTop"))
						-label2 (uiRes("m_hyperShadePanel.kBottom"))
						-select 1 // Top is the default
						initialPlacementGrp;
					radioButtonGrp
						-label $tabTypeLabel
						-numberOfRadioButtons 3
						-label1 $sceneLabel
						-label2 $diskLabel
						-label3 (uiRes("m_hyperShadePanel.kWorkArea"))
						-changeCommand "hyperShadePanelRefreshCreateNewTabWindow"
						-select 1 // Scene is the default
						tabTypeGrp;
				}
				else
				{
					radioButtonGrp
						-label $tabTypeLabel
						-numberOfRadioButtons 2
						-label1 $sceneLabel
						-label2 $diskLabel
						-changeCommand "hyperShadePanelRefreshCreateNewTabWindow"
						-select 1 // Scene is the default
						tabTypeGrp;
				}
				separator;
				formLayout sceneTabOptionsWrap;
					optionMenuGrp
						-label (uiRes("m_hyperShadePanel.kShowNodesWhichAre"))
						sceneTabFilterGrp;

						string $sceneTabTypes[] = filteredCollection_ListTypes();
						string $st;
						for( $st in $sceneTabTypes )
						{
							menuItem -label $st;
						}

					setParent -menu ..; // from option menu
					formLayout
						-edit
						-af sceneTabFilterGrp left 0
						-af sceneTabFilterGrp right 0
						-af sceneTabFilterGrp top 0
						-af sceneTabFilterGrp bottom 0
						sceneTabOptionsWrap;
				setParent ..; // from sceneTabOptionsWrap
				formLayout diskTabOptionsWrap;
					rowLayout
						-numberOfColumns 3
						-columnWidth 2 225
						-columnWidth 3 25
						directoryNameLayout;
						text
							-label (uiRes("m_hyperShadePanel.kRootDirectory")) ;
						textField
							-width 150
							rootDirectoryField;
						symbolButton
							-width 10
							-image "navButtonBrowse.png"
							-command "hyperShadePanelRootDirectoryBrowse"
							browseButton;
					setParent ..; // from directoryNameLayout
					checkBoxGrp
						-numberOfCheckBoxes 1
						-label1 (uiRes("m_hyperShadePanel.kOnlyShowFilesHideDirectory"))
						onlyShowFilesCheckBox;
					formLayout
						-edit
						-af directoryNameLayout left 0
						-af directoryNameLayout right 0
						-af directoryNameLayout top 0
						-an directoryNameLayout bottom
						-af onlyShowFilesCheckBox left 0
						-af onlyShowFilesCheckBox right 0
						-ac onlyShowFilesCheckBox top 0 directoryNameLayout
						-af onlyShowFilesCheckBox bottom 0
						diskTabOptionsWrap;
				setParent ..; // from diskTabOptionsWrap
			setParent ..; // from scrollColumn
		setParent ..; // from mainScroll

		formLayout
			-numberOfDivisions 3
			buttonForm;

			button
				-label (uiRes("m_hyperShadePanel.kNewTabCreate"))
				-command
					("hyperShadePanelCreateNewTabFinish "
						+ $panel
						+ " "
						+ "1")
				createButton;
			button
				-label (uiRes("m_hyperShadePanel.kNewTabApply"))
				-command
					("hyperShadePanelCreateNewTabFinish "
						+ $panel
						+ " "
						+ "0")
				applyButton;
			button
				-label (uiRes("m_hyperShadePanel.kNewTabClose"))
				-command "deleteUI hyperShadePanelCreateNewTabWindow"
				closeButton;

			formLayout
				-edit
				-af createButton left 0
				-ap createButton right 2 1
				-af createButton top 0
				-af createButton bottom 0

				-ap applyButton left 3 1
				-ap applyButton right 2 2
				-af applyButton top 0
				-af applyButton bottom 0

				-ap closeButton left 3 2
				-af closeButton right 0
				-af closeButton top 0
				-af closeButton bottom 0
				buttonForm;
		setParent ..; // from buttonForm

		formLayout
			-edit

			-af mainScroll left 0
			-af mainScroll right 0
			-af mainScroll top 0
			-ac mainScroll bottom 5 buttonForm

			-af buttonForm left 5
			-af buttonForm right 5
			-an buttonForm top
			-af buttonForm bottom 5

			mainForm;
	setParent ..; // from mainForm

	setUITemplate -popTemplate;

	hyperShadePanelRefreshCreateNewTabWindow;

	showWindow hyperShadePanelCreateNewTabWindow;
}

global proc hyperShadePanelRenameTabFinish(
	string $panel)
{
	//
	// Description:
	//	This procedure is called when the user clicks on the Rename button in
	//	the rename tab dialog.
	//	This procedure examines the settings of the controls in the rename
	//	tab dialog to determine the new name for the tab, then renames the tab.
	//

	setParent hyperShadePanelRenameTabWindow;
	string 	$tabLabel;

	$tabLabel = `textFieldGrp -query -text newTabNameGrp`;

	setTabLabel(activeTab($panel), $tabLabel);
	deleteUI hyperShadePanelRenameTabWindow;
}

proc renameTab(
	string $panel)
{
	//
	// Description:
	//	This procedure is called when the user chooses Rename Tab... from
	//	the hypershade panel menu.
	//	This procedure builds and opens the rename tab dialog.
	//

	if (`window -exists hyperShadePanelRenameTabWindow`)
	{
		showWindow hyperShadePanelRenameTabWindow;
		return;
	}

	//
	// If we get to here, the rename tab window does not already exist, so
	// we will create it.
	//

	int $windowWidth = 425;
	int $windowHeight = 110;

	string $renameTab = (uiRes("m_hyperShadePanel.kRenameTabTitle"));
	string $panelWindow = getPanelWindow($panel);
	window
		-title $renameTab
		-width $windowWidth
		-height $windowHeight
		-iconName $renameTab
		-parent $panelWindow
		hyperShadePanelRenameTabWindow;

	setUITemplate -pushTemplate DefaultTemplate;

	formLayout mainForm;
		columnLayout mainColumn;
			textFieldGrp
				-label (uiRes("m_hyperShadePanel.kRenameTabOldTabName"))
				-editable false
				-text `activeTabLabel($panel)`
				oldTabNameGrp;
			textFieldGrp
				-label (uiRes("m_hyperShadePanel.kRenameTabNewTabName"))
				newTabNameGrp;
		setParent ..; // from mainColumn

		formLayout
			-numberOfDivisions 2
			buttonForm;

			button
				-label (uiRes("m_hyperShadePanel.kRename"))
				-command ("hyperShadePanelRenameTabFinish " + $panel)
				renameButton;
			button
				-label (uiRes("m_hyperShadePanel.kRenameTabClose"))
				-command "deleteUI hyperShadePanelRenameTabWindow"
				closeButton;

			formLayout
				-edit
				-af renameButton left 5
				-ap renameButton right 2 1
				-af renameButton top 5
				-af renameButton bottom 5

				-ap closeButton left 3 1
				-af closeButton right 5
				-af closeButton top 5
				-af closeButton bottom 5
				buttonForm;
		setParent ..; // from buttonForm

		formLayout
			-edit

			-af mainColumn left 0
			-af mainColumn right 0
			-af mainColumn top 0
			-af mainColumn bottom 35

			-af buttonForm left 0
			-af buttonForm right 0
			-ac buttonForm top 0 mainColumn
			-af buttonForm bottom 0

			mainForm;
	setParent ..; // from mainForm

	setUITemplate -popTemplate;

	showWindow hyperShadePanelRenameTabWindow;
}

global proc string hyperShadePanelCreate(
	string $as,
	string $type)
{
	//
	// Description:
	//	This procedure is called when the user chooses to create a node from
	//	the hyperShadePanel Create menu.
	//	This procedure creates a node of the nodeType specified in $type, and
	//	using the $as argument to hook up the new node so that it may be
	//	properly filtered within the UI.
	//	Mostly this procedure calls renderCreateNode to perform the creation.
	//
	// Returns:
	//	The name of the node which was created.
	//

	string $name;

	if ($as == "shader")
	{
		int $withShadingGroup =
			`optionVar -query createMaterialsWithShadingGroup`;

		string $dest;
		if (`getClassification -satisfies "shader/displacement" $type`)
		{
			$dest = "displacementShader";
		}
		else if (`getClassification -satisfies "shader/volume" $type`)
		{
			$dest = "volumeShader";
		}
		else
		{
			$dest = "surfaceShader";
		}

		$name =
			renderCreateNode(
				"-asShader",
				$dest,
				$type,
				"",
				0,
				0,
				1,
				$withShadingGroup,
				0,
				"");
	}
	else if ($as == "2dTexture")
	{
		int $asNormal;
		int $asProjection;
		int $asStencil;
		int $withPlacement;

		$asNormal =
			(`optionVar -query create2dTextureType` == "normal");
		$asProjection =
			(`optionVar -query create2dTextureType` == "projection");
		$asStencil =
			(`optionVar -query create2dTextureType` == "stencil");
		$withPlacement =
			(`optionVar -query createTexturesWithPlacement`);

		$name =
			renderCreateNode(
				"-as2DTexture",
				"",
				$type,
				"",
				$asProjection,
				$asStencil,
				$withPlacement,
				0,
				0,
				"");
	}
	else if ($as == "3dTexture")
	{
		int $withPlacement;
		$withPlacement = (`optionVar -query createTexturesWithPlacement`);
		$name =
			renderCreateNode(
				"-as3DTexture",
				"",
				$type,
				"",
				0,
				0,
				$withPlacement,
				0,
				0,
				"");
	}
	else if ($as == "otherTexture")
	{
		$name = `renderCreateNode "-asTexture" "" $type "" 0 0 0 0 0 ""`;
	}
	else if ($as == "light")
	{
		$name = `renderCreateNode "-asLight" "" $type "" 0 0 0 0 0 ""`;
	}
	else if ($as == "utility")
	{
		$name = `renderCreateNode "-asUtility" "" $type "" 0 0 0 0 0 ""`;
	}
	else if ($as == "rendering")
	{
		$name = `renderCreateNode "-asRendering" "" $type "" 0 0 0 0 0 ""`;
	}
	else if ($as == "camera")
	{
		string $cameraNames[];
		$cameraNames = `camera`;
		$name = $cameraNames[0];
	}
	else if ($as == "node")
	{
		$name = `createNode $type`;
	}

	return $name;
}

global proc buildCreateSubMenu(
	string $classification,
	string $callback)
{
	//
	// Description:
	//	This procedure is called from buildMainMenu().
	//	This procedure builds a menu which allows the user to create nodes of
	//	the specified classification.
	//	The specified callback script is the one which is called to do the
	//	creation of a node of a particular type.
	//

    // allow custom UI to filter out their node types based on classification
    // so they don't show up in two places if they are registered as both
    // shaders/surface and rendernode/myrenderer for example

    string $customClassificationArray[] = `callbacks -executeCallbacks -hook "hyperShadePanelBuildCreateSubMenu"`;
    // fill in the types array based on the classification filters
	string $types[];
    if (size($customClassificationArray)){
        // does the classification string match any of the filters returned?
        // (this match should be unique)
        int $found = 0;
        string $currentCustomClassificationString;
        for ($currentCustomClassificationString in $customClassificationArray){
            if (startsWith($classification, $currentCustomClassificationString)){
                $found = 1;
                break;
            }
        }

        if ($found){
            // if we have a match, then we can go ahead and return the node types without filtering
            $types = `listNodeTypes $classification`;
        }
        else{
            // if we don't have a match, we're probably looking at a basic type like shaders/surface, and
            // don't want to have the custom types like rendernode/myrenderer show up as well, so filter
            // them out
            string $filterCommand = "listNodeTypes -ex \"";
            string $filter;
            for ($filter in $customClassificationArray){
                $filterCommand += $filter + ":";
            }
            $filterCommand += "\" \"" +$classification + "\"";
            $types = eval($filterCommand);
        }
    }
    else{
        $types = `listNodeTypes $classification`;
    }

	string $annotMsg = (uiRes("m_hyperShadePanel.kAnnotMsg"));
	for($type in $types)
	{
		// Check whether node should appear in this UI, based on
		// certain variables
		if (!shouldAppearInNodeCreateUI($type)) {
			continue;
		}

		string $typeString = nodeTypeNiceName( $type );
		menuItem
			-label $typeString
			-annotation `format -s $typeString $annotMsg`
			-command ($callback + " " + $type );
	}
}

proc buildCreateNodesSubMenu(
	string $types[],
	string $callback)
{
	//
	// Description:
	//	This procedure is called from buildMainMenu().
	//	This procedure builds menu items to create nodes of the nodeTypes
	//	specified in $types[].
	//	The specified callback script is the one which is called to do the
	//	creation of a node of a particular type.
	//

	string $annotMsg = (uiRes("m_hyperShadePanel.kAnnotMsg"));
	for($type in $types)
	{
		string $typeString = `nodeTypeNiceName $type`;
		menuItem
			-label $typeString
			-annotation `format -s $typeString $annotMsg`
			-command ($callback + "(\"" + $type + "\")");
	}
}

proc buildMainMenu(
	string $panel,
	int $isPopupMenu)
//
// Description:
//	This procedure is called when the hypershade panel is first opened.
//	This procedure creates menus in the top menubar of the hypershade panel.
//
{
	string $menuPrefix;

	if ($isPopupMenu)
	{
		$menuPrefix = "hyperShadePopupMenu";
	}
	else
	{
		$menuPrefix = "hyperShadePanelMenu";
	}

	// Build the File menu
	//
	string $file = (uiRes("m_hyperShadePanel.kFile"));
	if ($isPopupMenu)
	{
		menuItem
			-subMenu true
			-label $file
			-tearOff true
			($menuPrefix + "FileMenu");
	}
	else
	{
		menu
			-label $file
			-tearOff true
			($menuPrefix + "FileMenu");
	}

		menuItem
			-label (uiRes("m_hyperShadePanel.kImport"))
			-annotation (uiRes("m_hyperShadePanel.kImportShadingNetwork"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"import\")");
		menuItem -divider true;
		menuItem
			-label (uiRes("m_hyperShadePanel.kExportSelectedNetwork"))
			-annotation (uiRes("m_hyperShadePanel.kExportSelectedNetworkAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"exportSelectedNetwork\")");

	// Build the Edit menu
	//
	string $edit = (uiRes("m_hyperShadePanel.kEdit"));
	if ($isPopupMenu)
	{
		setParent -menu ..;
		menuItem
			-postMenuCommand
				("hyperShadePanelBuildEditMenu "
					+ $panel
					+ " "
					+ $menuPrefix
					+ "EditMenu")
			-subMenu true
			-label $edit
			-allowOptionBoxes true
			-tearOff true
			($menuPrefix + "EditMenu");
	}
	else
	{
		menu
			-postMenuCommand
				("hyperShadePanelBuildEditMenu "
					+ $panel
					+ " "
					+ $menuPrefix
					+ "EditMenu")
			-label $edit
			-allowOptionBoxes true
			-tearOff true
			($menuPrefix + "EditMenu");
	}

	// Build the View menu
	//
	string $view = (uiRes("m_hyperShadePanel.kView"));
	if ($isPopupMenu)
	{
		setParent -menu ..;
		menuItem
			-subMenu true
			-label $view
			-tearOff true
			($menuPrefix + "ViewMenu");
	}
	else
	{
		menu
			-label $view
			-tearOff true
			($menuPrefix + "ViewMenu");
	}

		menuItem
			-label (uiRes("m_hyperShadePanel.kFrameAll"))
			-annotation (uiRes("m_hyperShadePanel.kFrameAllAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"frameAll\")");
		menuItem
			-label (uiRes("m_hyperShadePanel.kFrameSelected"))
			-annotation
				(uiRes("m_hyperShadePanel.kFrameSelectedAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"frameSelected\")");

		menuItem -divider true;

        radioMenuItemCollection;
            $menuItemName = "asIcons";
		    menuItem
			    -label (uiRes("m_hyperShadePanel.kAsIcons"))
                -radioButton off
			    -command
				    ("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \""+$menuItemName+"\")")
                    $menuItemName;

            $menuItemName = "asList";
		    menuItem
			    -label (uiRes("m_hyperShadePanel.kAsList"))
                -radioButton off
			    -command
				    ("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \""+$menuItemName+"\")")
                    $menuItemName;

		menuItem -divider true;

        radioMenuItemCollection;
            $menuItemName = "smallIcons";
		    menuItem
			    -label (uiRes("m_hyperShadePanel.kAsSmallSwatches"))
                -radioButton off
			    -command
				    ("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \""+$menuItemName+"\")")
                    $menuItemName;

            $menuItemName = "mediumIcons";
		    menuItem
			    -label (uiRes("m_hyperShadePanel.kAsMediumSwatches"))
                -radioButton off
			    -command
				    ("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \""+$menuItemName+"\")")
                    $menuItemName;

            $menuItemName = "largeIcons";
		    menuItem
			    -label (uiRes("m_hyperShadePanel.kAsLargeSwatches"))
                -radioButton off
			    -command
				    ("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \""+$menuItemName+"\")")
                    $menuItemName;

            $menuItemName = "superIcons";
		    menuItem
			    -label (uiRes("m_hyperShadePanel.kAsExtraLargeSwatches"))
                -radioButton off
			    -command
				    ("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \""+$menuItemName+"\")")
                    $menuItemName;

		menuItem -divider true;

        radioMenuItemCollection;
            $menuItemName = "byName";
		    menuItem
			    -label (uiRes("m_hyperShadePanel.kByName"))
                -radioButton off
			    -command
				    ("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \""+$menuItemName+"\")")
                    $menuItemName;

            $menuItemName = "byType";
		    menuItem
			    -label (uiRes("m_hyperShadePanel.kByType"))
                -radioButton off
			    -command
				    ("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \""+$menuItemName+"\")")
                    $menuItemName;

            $menuItemName = "byTime";
		    menuItem
			    -label (uiRes("m_hyperShadePanel.kByTime"))
                -radioButton off
			    -command
				    ("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \""+$menuItemName+"\")")
                    $menuItemName;

		menuItem -divider true;

		$menuItemName = "reverseOrder";
		menuItem
			-label (uiRes("m_hyperShadePanel.kReverseorder"))
            -checkBox false
			-command
				("hyperShadePanelMenuCommand(\""
				+ $panel
				+ "\", \""+$menuItemName+"\")")
                $menuItemName;

	if (getenv("MAYA_ENABLE_LEGACY_HYPERSHADE") == "1")
	{
		// Build Bookmarks menu
		//
		string $bookmarks = (uiRes("m_hyperShadePanel.kBookmarksHyperShade"));
		if ($isPopupMenu)
		{
			setParent -menu ..;
			menuItem
				-subMenu true
				-enable true
				-label $bookmarks
				-allowOptionBoxes true
				-postMenuCommand ("hyperShadePanelBuildBookmarksMenu " + $panel + " " + $menuPrefix + "BookmarksMenu")
				-tearOff true
				($menuPrefix + "BookmarksMenu");

			string $activeTab = activeTab($panel);
			if(!isGraphTab($activeTab)) { // bookmarks available only for graph tab
				menuItem -edit -enable false ($menuPrefix + "BookmarksMenu");
			}
		} else {
			menu
				-label $bookmarks
				-allowOptionBoxes true
				-postMenuCommand ("hyperShadePanelBuildBookmarksMenu " + $panel + " " + $menuPrefix + "BookmarksMenu")
				-tearOff true
				($menuPrefix + "BookmarksMenu");
		}
	}

	// Build the Create menu
	//
	string $create = (uiRes("m_hyperShadePanel.kCreate"));
	if ($isPopupMenu)
	{
		setParent -menu ..;
		menuItem
			-subMenu true
			-label $create
			-allowOptionBoxes true
	/*		-postMenuCommand (
				"hyperShadePanelBuildCreateMenu "
				+ $panel
				+ " "
				+ $menuPrefix
				+ "CreateMenu")
			-postMenuCommandOnce true*/
			-tearOff true
			($menuPrefix + "CreateMenu");
	}
	else
	{
		menu
			-label $create
			-allowOptionBoxes true
		/*	-postMenuCommand (
				"hyperShadePanelBuildCreateMenu "
				+ $panel
				+ " "
				+ $menuPrefix
				+ "CreateMenu")
			-postMenuCommandOnce false*/
			-tearOff true
			($menuPrefix + "CreateMenu");
	}

	hyperShadePanelBuildCreateMenu($panel, $menuPrefix);
	// Build the Tabs menu
	//
	string $tabs = (uiRes("m_hyperShadePanel.kTabs"));
	if ($isPopupMenu)
	{
		setParent -menu ..;
		menuItem
			-subMenu true
			-label $tabs
			-tearOff true
			($menuPrefix + "TabsMenu");
	}
	else
	{
		menu
			-label $tabs
			-tearOff true
			($menuPrefix + "TabsMenu");
	}

		menuItem
			-label (uiRes("m_hyperShadePanel.kCreateNewTab"))
			-annotation (uiRes("m_hyperShadePanel.kCreateNewTabAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"createNewTab\")");
		menuItem -divider true;
		if (getenv("MAYA_ENABLE_LEGACY_HYPERSHADE") == "1")
		{
			menuItem
				-label (uiRes("m_hyperShadePanel.kMoveTabUp"))
				-annotation
					(uiRes("m_hyperShadePanel.kMoveTabUpAnnot"))
				-command
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"moveTabUp\")")
				tabsMoveTabUpItem;
			menuItem
				-label (uiRes("m_hyperShadePanel.kMoveTabDown"))
				-annotation
					(uiRes("m_hyperShadePanel.kMoveTabDownAnnot"))
				-command
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"moveTabDown\")")
				tabsMoveTabDownItem;
		}
		menuItem
			-label (uiRes("m_hyperShadePanel.kMoveTabLeft"))
			-annotation
				(uiRes("m_hyperShadePanel.kMoveTabLeftAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"moveTabLeft\")");
		menuItem
			-label (uiRes("m_hyperShadePanel.kMoveTabRight"))
			-annotation
				(uiRes("m_hyperShadePanel.kMoveTabRightAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"moveTabRight\")");
		menuItem -divider true;
		menuItem
			-label (uiRes("m_hyperShadePanel.kRenameTab"))
			-annotation
				(uiRes("m_hyperShadePanel.kRenameTabAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"renameTab\")");
		menuItem -divider true;
		menuItem
			-label (uiRes("m_hyperShadePanel.kRemoveTab"))
			-annotation
				(uiRes("m_hyperShadePanel.kRemoveTabAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"removeTab\")");
		if (getenv("MAYA_ENABLE_LEGACY_HYPERSHADE") == "1")
		{
			menuItem
				-label (uiRes("m_hyperShadePanel.kRevertToDefaultTabs"))
				-annotation
					(uiRes("m_hyperShadePanel.kRevertToDefaultTabsAnnot"))
				-command
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"revertToDefaultTabs\")");
		}
		menuItem -divider true;

		if (getenv("MAYA_ENABLE_LEGACY_HYPERSHADE") == "1")
		{
			radioMenuItemCollection;
			menuItem
				-label (uiRes("m_hyperShadePanel.kShowTopTabsOnly"))
				-radioButton
					(`optionVar -q hyperShadePanelTabSectionsShown`
						== "showTopTabsOnly")
				-annotation
					(uiRes("m_hyperShadePanel.kShowTopTabsOnlyAnnot"))
				-command
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"showTopTabsOnly\")")
				tabsShowTopTabsOnlyItem;
			menuItem
				-label (uiRes("m_hyperShadePanel.kShowBottomTabsOnly"))
				-radioButton
					(`optionVar -q hyperShadePanelTabSectionsShown`
						== "showBottomTabsOnly")
				-annotation
					(uiRes("m_hyperShadePanel.kShowBottomTabsOnlyAnnot"))
				-command
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"showBottomTabsOnly\")")
				tabsShowBottomTabsOnlyItem;
			menuItem
				-label (uiRes("m_hyperShadePanel.kShowTopAndBottomTabs"))
				-radioButton
					(`optionVar -q hyperShadePanelTabSectionsShown`
						== "showTopAndBottomTabs")
				-annotation
					(uiRes("m_hyperShadePanel.kShowTopAndBottomTabsAnnot"))
				-command
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"showTopAndBottomTabs\")")
				tabsShowTopAndBottomTabsItem;
		}
		menuItem -divider true;
		string $currentTabMenu =
			`menuItem
				-label (uiRes("m_hyperShadePanel.kCurrentTab"))
				-subMenu true
				currentTabMenu`;
			setParent -menu ..;
		menuItem
			-edit
			-postMenuCommand
				("hyperShadePanelBuildTabOptionsMenu "
					+ $panel
					+ " "
					+ $currentTabMenu)
			$currentTabMenu;

	// Build the Graph menu
	//
	string $graph = (uiRes("m_hyperShadePanel.kGraph"));
	if ($isPopupMenu)
	{
		setParent -menu ..;
		menuItem
			-subMenu true
			-label $graph
			-tearOff true
			($menuPrefix + "GraphMenu");
	}
	else
	{
		menu
			-label $graph
			-tearOff true
			($menuPrefix + "GraphMenu");
	}

		menuItem
			-label (uiRes("m_hyperShadePanel.kGraphMaterialsOnSelectedObject"))
			-annotation
				(uiRes("m_hyperShadePanel.kGraphMaterialsOnSelectedObjectAnnot"))
			-command
				("hyperShadePanelGraphCommand(\""
					+ $panel
					+ "\", \"graphMaterials\")");
		menuItem -divider true;
		menuItem
			-label (uiRes("m_hyperShadePanel.kClearGraph"))
			-annotation (uiRes("m_hyperShadePanel.kClearGraphAnnot"))
			-command
				("hyperShadePanelGraphCommand(\""
					+ $panel
					+ "\", \"clearGraph\")")
			clearGraphItem;
		menuItem -divider true;
		menuItem
			-label (uiRes("m_hyperShadePanel.kInputandOutputConnections"))
			-annotation
				(uiRes("m_hyperShadePanel.kInputandOutputConnectionsAnnot"))
			-command
				("hyperShadePanelGraphCommand(\""
					+ $panel
					+ "\", \"showUpAndDownstream\")");
		menuItem
			-label (uiRes("m_hyperShadePanel.kInputConnections"))
			-annotation
				(uiRes("m_hyperShadePanel.kInputConnectionsAnnot"))
			-command
				("hyperShadePanelGraphCommand(\""
					+ $panel
					+ "\", \"showUpstream\")");
		menuItem
			-label (uiRes("m_hyperShadePanel.kOutputConnections"))
			-annotation
				(uiRes("m_hyperShadePanel.kOutputConnectionsAnnot"))
			-command
				("hyperShadePanelGraphCommand(\""
					+ $panel
					+ "\", \"showDownstream\")");
		menuItem -divider true;
		menuItem
			-label (uiRes("m_hyperShadePanel.kShowPreviousGraph"))
			-annotation
				(uiRes("m_hyperShadePanel.kShowPreviousGraphAnnot"))
			-command "UndoViewChange"
			showPreviousGraphItem;
		menuItem
			-label (uiRes("m_hyperShadePanel.kShowNextGraph"))
			-annotation
				(uiRes("m_hyperShadePanel.kShowNextGraphAnnot"))
			-command "RedoViewChange"
			showNextGraphItem;
		menuItem -divider true;
		menuItem
			-label (uiRes("m_hyperShadePanel.kAddSelectedtoGraph"))
			-annotation
				(uiRes("m_hyperShadePanel.kAddSelectedtoGraphAnnot"))
			-command
				("hyperShadePanelGraphCommand(\""
					+ $panel
					+ "\", \"addSelected\")");
		menuItem
			-label (uiRes("m_hyperShadePanel.kRemoveSelectedfromGraph"))
			-annotation
				(uiRes("m_hyperShadePanel.kRemoveSelectedfromGraphAnnot"))
			-command
				("hyperShadePanelGraphCommand(\""
					+ $panel
					+ "\", \"removeSelected\")");
		menuItem -divider true;
		menuItem
			-label (uiRes("m_hyperShadePanel.kRearrangeGraph"))
			-annotation
				(uiRes("m_hyperShadePanel.kRearrangeGraphAnnot"))
			-command
				("hyperShadePanelGraphCommand(\""
					+ $panel
					+ "\", \"rearrangeGraph\")")
			rearrangeGraphItem;

		if ($isPopupMenu)
		{
			// Enable some graph menu items only if a graph tab (work area) is
			// visible
			//
			int $enable;
			$enable = isGraphTabVisible($panel);

			menuItem
				-edit
				-enable $enable
				clearGraphItem;
			menuItem
				-edit
				-enable $enable
				rearrangeGraphItem;
			menuItem
				-edit
				-enable $enable
				showPreviousGraphItem;
			menuItem
				-edit
				-enable $enable
				showNextGraphItem;
		}

	// Build the Window menu
	//
	string $window = (uiRes("m_hyperShadePanel.kWindow"));
	if ($isPopupMenu)
	{
		setParent -menu ..;
		menuItem
			-subMenu true
			-label $window
			-tearOff true
			-version 2016
			($menuPrefix + "WindowMenu");
	}
	else
	{
		menu
			-label $window
			-tearOff true
			-version 2016
			($menuPrefix + "WindowMenu");
	}

        string $cmd = "HypershadeOpenBrowserWindow";
		menuItem -label (uiRes("m_hyperShadePanel.kBrowserWindowLabel"))
			-annotation (getRunTimeCommandAnnotation($cmd))
			-c ($cmd);

		$cmd = "HypershadeOpenPropertyEditorWindow";
        menuItem -label (uiRes("m_hyperShadePanel.kPropertyEditorWindowLabel"))
			-annotation (getRunTimeCommandAnnotation($cmd))
			-version 2016
			-c ($cmd);
        
        $cmd = "HypershadeOpenMaterialViewerWindow";
		menuItem -label (uiRes("m_hyperShadePanel.kShaderballWindowLabel"))
			-annotation (getRunTimeCommandAnnotation($cmd))
			-version 2016
			-c ($cmd);
        
        $cmd = "HypershadeOpenCreateWindow";
		menuItem -label (uiRes("m_hyperShadePanel.kCreateWindowLabel"))
			-annotation (getRunTimeCommandAnnotation($cmd))
			-c ($cmd);
        
        $cmd = "HypershadeOpenBinsWindow";
		menuItem -label (uiRes("m_hyperShadePanel.kBinsWindowLabel"))
			-annotation (getRunTimeCommandAnnotation($cmd))
			-c ($cmd);
		
		menuItem -divider true;
        
        $cmd = "HypershadeOpenModelEditorWindow";
		menuItem -label (uiRes("m_hyperShadePanel.kModelEditorWindowLabel"))
			-annotation (getRunTimeCommandAnnotation($cmd))
			-c ($cmd);
			
		$cmd = "HypershadeOpenRenderViewWindow";
		menuItem -label (uiRes("m_hyperShadePanel.kRenderViewWindowLabel"))
			-annotation (getRunTimeCommandAnnotation($cmd))
			-c ($cmd);
			
		$cmd = "HypershadeOpenOutlinerWindow";
		menuItem -label (uiRes("m_hyperShadePanel.kOutlinerWindowLabel"))
			-annotation (getRunTimeCommandAnnotation($cmd))
			-c ($cmd);
			
		$cmd = "HypershadeOpenUVEditorWindow";
		menuItem -label (uiRes("m_hyperShadePanel.kUVEditorWindowLabel"))
			-annotation (getRunTimeCommandAnnotation($cmd))
			-c ($cmd);
			
		$cmd = "HypershadeOpenGraphEditorWindow";
		menuItem -label (uiRes("m_hyperShadePanel.kGraphEditorWindowLabel"))
			-annotation (getRunTimeCommandAnnotation($cmd))
			-c ($cmd);

        
        $cmd = "HypershadeOpenSpreadSheetWindow";
		menuItem -label (uiRes("m_hyperShadePanel.kAttributeSpreadSheet"))
			-annotation (getRunTimeCommandAnnotation($cmd))
			-c ($cmd);

		menuItem -divider true;

		menuItem
			-label (uiRes("m_hyperShadePanel.kConnectionEditor"))
			-annotation
				(uiRes("m_hyperShadePanel.kConnectionEditorAnnot"))
			-command ("connectWindow 0 \"\" \"\"");
		menuItem
			-label (uiRes("m_hyperShadePanel.kConnectSelected"))
			-annotation
				(uiRes("m_hyperShadePanel.kConnectSelectedAnnot"))
			-command
				("string $sel[] = `ls -sl`; connectWindowWith $sel[0] $sel[1]");

	// Build the Options menu
	//
	string $options = (uiRes("m_hyperShadePanel.kOptions"));
	if ($isPopupMenu)
	{
		setParent -menu ..;
		menuItem
			-subMenu true
			-label $options
			-tearOff true
			($menuPrefix + "OptionsMenu");
	}
	else
	{
		menu
			-label $options
			-tearOff true
			($menuPrefix + "OptionsMenu");
	}

        int $value = `optionVar -q hsBinsSortShadingNodesOnly`;
        string $hsBinsSortShadingNodesOnlyItem = `menuItem
            -label (uiRes("m_hyperShadePanel.kBinsSortHyperNodeOnly"))
            -checkBox $value
            hsBinsSortShadingNodesOnlyItem`;
        setParent -menu ..;
        menuItem
            -edit
			-command
				("optionVar -intValue hsBinsSortShadingNodesOnly "
					+ "`menuItem -query -checkBox "
					+ $hsBinsSortShadingNodesOnlyItem+"`")
		    $hsBinsSortShadingNodesOnlyItem;

		menuItem -divider true;

		if (getenv("MAYA_ENABLE_LEGACY_HYPERSHADE") == "1")
		{
			string $displayMenu =
				`menuItem
					-label (uiRes("m_hyperShadePanel.kDisplayWorkAreaOnly"))
					-subMenu true
					displayMenu`;
				setParent -menu ..;
			menuItem
				-edit
				-postMenuCommand
					("hyperShadePanelBuildDisplayOptionsMenu "
						+ $panel
						+ " "
						+ $displayMenu)
				$displayMenu;
			menuItem -divider true;
		}

		int $keepSwatchesAtCurrentResolution = `optionVar -query keepSwatchesAtCurrentResolution`;
        string $keepSwatchesAtCurrentResolutionItem =
            `menuItem
                -label (uiRes("m_hyperShadePanel.kKeepSwatchesatCurrentResolution"))
                -annotation
                    (uiRes("m_hyperShadePanel.kKeepSwatchesatCurrentResolutionAnnot"))
                -checkBox $keepSwatchesAtCurrentResolution
                keepSwatchesAtCurrentResolution`;
		menuItem
			-edit
			-command
				("optionVar "
					+ "-intValue keepSwatchesAtCurrentResolution "
					+ "`menuItem -query -checkBox "
					+ $keepSwatchesAtCurrentResolutionItem
					+ "`; hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"keepSwatchesAtCurrentResolution\")")
			$keepSwatchesAtCurrentResolutionItem;

        int $batchSwatch = `optionVar -query useBatchForSwatches`;
        string $useBatchForSwatchesItem = `menuItem
            -label (uiRes("m_hyperShadePanel.kBatchSwatch"))
            -annotation (uiRes("m_hyperShadePanel.kBatchSwatchAnnot"))
            -checkBox $batchSwatch`;
  		menuItem
			-edit
			-command
				("optionVar "
					+ "-intValue useBatchForSwatches "
					+ "`menuItem -query -checkBox "
					+ $useBatchForSwatchesItem
                    + "`;"
                    + "swatchRefresh;")
			$useBatchForSwatchesItem;

        menuItem
            -label (uiRes("m_hyperShadePanel.kSwatchCamera"))
            -annotation (uiRes("m_hyperShadePanel.kSwatchCameraAnnot"));

        menuItem -divider true;
		if (getenv("MAYA_ENABLE_LEGACY_HYPERSHADE") == "1")
		{
			int $isClearBeforeSet = `optionVar -query hsClearBeforeGraphing`;
			string $clearBeforeItem =
				`menuItem
					-label (uiRes("m_hyperShadePanel.kClearBeforeGraphing"))
					-annotation
						(uiRes("m_hyperShadePanel.kClearBeforeGraphingAnnot"))
					-checkBox $isClearBeforeSet
					clearBeforeItem`;
			menuItem
				-edit
				-command
					("optionVar "
						+ "-intValue hsClearBeforeGraphing "
						+ "`menuItem -query -checkBox "
						+ $clearBeforeItem
						+ "`")
				$clearBeforeItem;
		}

		int $isShowRelationshipsSet = `optionVar -query hsShowRelationships`;
        string $showRelationshipsItem =
            `menuItem
                -label (uiRes("m_hyperShadePanel.kShowRelationshipConnections"))
                -annotation
                    (uiRes("m_hyperShadePanel.kShowRelationshipsAnnot"))
                -checkBox $isShowRelationshipsSet
                showRelationshipsItem`;
		menuItem
			-edit
			-command ("hyperShadeSetShowRelationshipsCallback " + $showRelationshipsItem + " " + $panel )
			$showRelationshipsItem;

		int $isMergeConnectionsSet = `optionVar -query hsMergeConnections`;
        string $mergeConnectionsItem =
            `menuItem
                -label (uiRes("m_hyperShadePanel.kMergeConnections"))
                -annotation
                    (uiRes("m_hyperShadePanel.kMergeConnectionsAnnot"))
                -checkBox $isMergeConnectionsSet
                mergeConnectionsItem`;
		menuItem
			-edit
			-command ("hyperShadeSetMergeConnectionsCallback " + $mergeConnectionsItem + " " + $panel )
			$mergeConnectionsItem;

		if (getenv("MAYA_ENABLE_LEGACY_HYPERSHADE") == "1")
		{
			int $isOpaqueContainersSet = `optionVar -query hsOpaqueContainers`;
			string $opaqueContainersItem =
				`menuItem
					-label (uiRes("m_hyperShadePanel.kOpaqueAssets"))
					-annotation
						(uiRes("m_hyperShadePanel.kOpaqueAssetsAnnot"))
					-checkBox $isOpaqueContainersSet
					opaqueContainersItem`;
			menuItem
				-edit
				-command ("hyperShadeSetOpaqueContainersCallback " + $opaqueContainersItem + " " + $panel )
				$opaqueContainersItem;
		}

	// Add support for the Context Sensitive Help Menu.
	//
	addContextHelpProc $panel "hyperShadePanelBuildContextHelpItems";

	// Set the menu bar visibility
	//
	int $menusOkayInPanels = `optionVar -q allowMenusInPanels`;
	panel -e -mbv $menusOkayInPanels $panel;
}

// ---------------------------------------------------------------------------
// 	Global procedures
//

global proc hyperShadePanelBuildContextHelpItems(
	string $nameRoot,
	string $menuParent)
{
	//
	// Description:
	//	This procedure is called as the Help menu for this panel is being
	//	built.
	//	This procedure builds the menu item which provides help on the
	//	Hypershade.
	//	$nameRoot is the name to use as the root of all item names
	//	$menuParent is the name of the parent of this menu
	//

	menuItem -label (uiRes("m_hyperShadePanel.kHelpOnHypershade"))
		-enableCommandRepeat false
		-command "showHelp Hypershade";
	menuItem -label (uiRes("m_hyperShadePanel.kHelpOnShaderLibrary"))
		-enableCommandRepeat false
		-command "showHelp ShaderLibrary";
}

global proc hyperShadePanelBuildEditMenu(
	string $panel,
	string $parent)
{
	//
	// Description:
	//	This procedure is called every time the Edit menu is opened.
	//	This procedure builds the Edit menu.
	//

	string $shadingGroups         = (uiRes("m_hyperShadePanel.kShadingGroupsAndMaterials"));
	string $textures              = (uiRes("m_hyperShadePanel.kTextures"));
	string $lights                = (uiRes("m_hyperShadePanel.kLights"));
	string $utilities             = (uiRes("m_hyperShadePanel.kUtilities"));
	string $camerasAndImagePlanes = (uiRes("m_hyperShadePanel.kCamerasAndImagePlanes"));
	string $bakeSets              = (uiRes("m_hyperShadePanel.kBakeSets"));

	menu -edit -deleteAllItems $parent;

	setParent -menu $parent;

	menuItem
		-label (uiRes("m_hyperShadePanel.kDelete"))
		-annotation (uiRes("m_hyperShadePanel.kDeleteAnnot"))
		-command
			("hyperShadePanelMenuCommand(\""
				+ $panel
				+ "\", \"delete\")");

	menuItem
		-label (uiRes("m_hyperShadePanel.kDeleteUnusedNodes"))
		-annotation
			(uiRes("m_hyperShadePanel.kDeleteUnusedNodesAnnot"))
		-command
			("hyperShadePanelMenuCommand(\""
				+ $panel
				+ "\", \"deleteUnusedNodes\")");

	menuItem
		-label (uiRes("m_hyperShadePanel.kDeleteDuplicateShadingNetwork"))
		-annotation
			(uiRes("m_hyperShadePanel.kDeleteDuplicateShadingNetworkAnnot"))
		-command
			("removeDuplicateShadingNetworks( 1 )");

	menuItem -label (uiRes("m_hyperShadePanel.kDeleteAllbyType"))  -subMenu true;

		menuItem
			-label $shadingGroups
			-annotation (uiRes("m_hyperShadePanel.kShadingGroupsAndMaterialsAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"deleteShadingGroupsAndMaterials\")");

		menuItem
			-label $textures
			-annotation (uiRes("m_hyperShadePanel.kDeleteAllTextures"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"deleteTextures\")");

		menuItem
			-label $lights
			-annotation (uiRes("m_hyperShadePanel.kDeleteallLights"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"deleteLights\")");

		menuItem
			-label $utilities
			-annotation (uiRes("m_hyperShadePanel.kDeleteallUtilityNodes"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"deleteUtilities\")");

		menuItem
			-label $camerasAndImagePlanes
			-annotation (uiRes("m_hyperShadePanel.kCamerasandImagePlanesAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"deleteCamerasAndImagePlanes\")");

		menuItem
			-label $bakeSets
			-annotation (uiRes("m_hyperShadePanel.kDeleteallBakeSets"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"deleteBakeSets\")");

		setParent -menu ..;

	menuItem
		-label (uiRes("m_hyperShadePanel.kRevertSelectedSwatches"))
		-annotation
			(uiRes("m_hyperShadePanel.kRevertSelectedSwatchesAnnot"))
		-command
			("hyperShadePanelMenuCommand(\""
				+ $panel
				+ "\", \"revertSelectedSwatches\")");

	menuItem -divider true;

	menuItem -label (uiRes("m_hyperShadePanel.kSelectAllbyType"))  -subMenu true;

		menuItem
			-label $shadingGroups
			-annotation (uiRes("m_hyperShadePanel.kSelectShadingGroupsAndMaterialsAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"selectShadingGroupsAndMaterials\")");

		menuItem
			-label $textures
			-annotation (uiRes("m_hyperShadePanel.kSelectAllTexturesAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"selectTextures\")");

		menuItem
			-label $lights
			-annotation (uiRes("m_hyperShadePanel.kSelectAllLightsAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"selectLights\")");

		menuItem
			-label $utilities
			-annotation (uiRes("m_hyperShadePanel.kSelectAllUtilityNodesAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"selectUtilities\")");

		menuItem
			-label $camerasAndImagePlanes
			-annotation (uiRes("m_hyperShadePanel.kSelectAllCamerasandImagePlaneAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"selectCamerasAndImagePlanes\")");

		menuItem
			-label $bakeSets
			-annotation (uiRes("m_hyperShadePanel.kSelectAllBakeSetsAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"selectBakeSets\")");

		setParent -menu ..;

	menuItem -divider true;

    menuItem -label (uiRes("m_hyperShadePanel.kSelectObjectsWithMaterials"))
             -command "hyperShade -objects \"\"";

    menuItem -label (uiRes("m_hyperShadePanel.kSelectMaterialsFromObjects"))
             -command "hyperShade -smn \"\"";

	menuItem -divider true;

	menuItem -label (uiRes("m_hyperShadePanel.kDuplicate"))  -subMenu true;

		menuItem
			-label (uiRes("m_hyperShadePanel.kShadingNetwork"))
			-annotation
				(uiRes("m_hyperShadePanel.kShadingNetworkAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"duplicateShadingNetwork\")");

		menuItem
			-label (uiRes("m_hyperShadePanel.kWithoutNetwork"))
			-annotation
				(uiRes("m_hyperShadePanel.kWithoutNetworkAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"duplicateWithoutNetwork\")");

		menuItem
			-label (uiRes("m_hyperShadePanel.kWithConnectionsToNetwork"))
			-annotation
				(uiRes("m_hyperShadePanel.kWithConnectionsToNetworkAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"duplicateWithConnections\")");

		setParent -menu ..;

	menuItem -divider true;

	menuItem
		-label
			(uiRes("m_hyperShadePanel.kConvertToFileTexture"))
		-annotation
			(uiRes("m_hyperShadePanel.kConvertToFileTextureAnnot"))
		-command
			("hyperShadePanelMenuCommand(\""
				+ $panel
				+ "\", \"convertToFileTexture\")");

	menuItem
		-optionBox true
		-command
			("hyperShadePanelMenuCommand(\""
				+ $panel
				+ "\", \"convertToFileTextureOptionBox\")");

	menuItem
		-label (uiRes("m_hyperShadePanel.kConvertPSDToLayeredTexture"))
		-annotation (uiRes("m_hyperShadePanel.kConvertPSDToLayeredTextureAnnot"))
		-command "hypergraphConvertSelectedPsdNodesToLT";

	menuItem
		-label (uiRes("m_hyperShadePanel.kConvertPSDToFileTexture"))
		-annotation (uiRes("m_hyperShadePanel.kConvertPSDToFileTextureAnnot"))
		-command "hypergraphConvertSelectedPsdNodesToFile";

	menuItem -divider true;

	menuItem -label (uiRes("m_hyperShadePanel.kCreatePSDNetwork"))
			-annotation (uiRes("m_hyperShadePanel.kCreatePSDNetworkAnnot"))
		        -c "photoShopPaintTex"
			createPsdTextureItem;
	menuItem -label (uiRes("m_hyperShadePanel.kEditPSDNetwork"))
			-annotation (uiRes("m_hyperShadePanel.kEditPSDNetworkAnnot"))
		        -c "photoshopEditTexture"
			editPsdTextureItem;
	menuItem -label (uiRes("m_hyperShadePanel.kUpdatePSDNetworks"))
			-annotation (uiRes("m_hyperShadePanel.kUpdatePSDNetworksAnnot"))
		        -c "psdUpdateTextures"
			updatePsdTextureItem;

	if (getenv("MAYA_ENABLE_LEGACY_HYPERSHADE") == "1")
	{
		menuItem -divider true;

		menuItem -label (uiRes("m_hyperShadePanel.kCreateAsset"))
				-annotation (getRunTimeCommandAnnotation("CreateContainer"))
				-aob 1
				-c ("hyperShadePanelGraphCommand(\""
							+ $panel
							+ "\", \"createContainer\")");
			menuItem -optionBox true
				-annotation (getRunTimeCommandAnnotation("CreateContainerOptions"))
				-c CreateContainerOptions;

		menuItem -label (uiRes("m_hyperShadePanel.kTransferContainer"))
			-allowOptionBoxes true
			-annotation (getRunTimeCommandAnnotation("TransferAttributeValues"))
			-c TransferAttributeValues;
		menuItem -optionBox true
			-annotation (getRunTimeCommandAnnotation("TransferAttributeValuesOptions"))
			-c TransferAttributeValuesOptions;

		menuItem -label (uiRes("m_buildAssetsMenu.kPublishConnections"))
			-annotation (getRunTimeCommandAnnotation("PublishConnections"))
			-c PublishConnections;

		string $sccSubmenu = `menuItem
			-label (uiRes("m_hyperShadePanel.kSetCurrentContainer"))
			-annotation (uiRes("m_hyperShadePanel.kSetCurrentContainerAnnot"))
			-sm true setCurrentContainerItem`;
		menu -e -pmc ("buildSetContainerMenu \"" + $sccSubmenu + "\"") setCurrentContainerItem;
		setParent -menu ..;

		menuItem -label (uiRes("m_HyperGraphEdMenu.kRemoveAsset"))
				-annotation (uiRes("m_HyperGraphEdMenu.kRemoveAssetAnnot"))
				-c ("hyperShadePanelGraphCommand(\""
							+ $panel
							+ "\", \"removeContainer\")");

		menuItem -label (uiRes("m_HyperGraphEdMenu.kCollapseAsset"))
				-annotation (uiRes("m_HyperGraphEdMenu.kCollapseAssetAnnot"))
				-c ("hyperShadePanelGraphCommand(\""
							+ $panel
							+ "\", \"collapseContainer\")");

		menuItem -label (uiRes("m_HyperGraphEdMenu.kExpandAsset"))
				-annotation (uiRes("m_HyperGraphEdMenu.kExpandAssetAnnot"))
				-c ("hyperShadePanelGraphCommand(\""
							+ $panel
							+ "\", \"expandContainer\")");
	}
	menuItem -divider true;

	menuItem
		-label (uiRes("m_hyperShadePanel.kEditTexture"))
		-annotation (getRunTimeCommandAnnotation ("EditTexture"))
		-command "EditTexture";

	menuItem
		-label (uiRes("m_hyperShadePanel.kTestTexture"))
		-annotation (getRunTimeCommandAnnotation ("TestTexture"))
		-command "TestTexture";

	menuItem
		-optionBox true
		-annotation (getRunTimeCommandAnnotation ("TestTextureOptions"))
		-command "TestTextureOptions";

	menuItem
		-label (uiRes("m_hyperShadePanel.kRenderTextureRange"))
		-annotation (getRunTimeCommandAnnotation ("RenderTextureRange"))
		-command "RenderTextureRange";

	menuItem
		-optionBox true
		-annotation (getRunTimeCommandAnnotation ("RenderTextureRangeOptions"))
		-command "RenderTextureRangeOptions";

}

global proc hyperShadePanelBuildBookmarksMenu(string $panel, string $parent)
{
	string $activeTab = activeTab($panel);
	string $component = lookupComponentName($activeTab);
	string $editor = graphUIHypershadeName($component);

	hyperBookmarkBuildMenu $editor $parent true;

	if(!isGraphTab($activeTab)) // bookmarks available only for graph tab
	{
		string $items[] = `menu -q -itemArray $parent`;
		string $item;
		for($item in $items) {
			menuItem -edit -enable false $item;
		}
	}
}

global proc hyperShadePanelBuildCreateMenu(string $panel, string $parent)
{
	//
	// Description:
	//	This procedure is called every time the Create menu is opened.
	//	This procedure builds the Create menu.
	//

//	menu -edit -deleteAllItems $parent;

//	setParent -menu $parent;

	menuItem -label (uiRes("m_hyperShadePanel.kMaterials"))  -tearOff true -subMenu true;
		buildCreateSubMenu(
			"shader/surface",
			"hyperShadePanelCreate \"shader\"");
	setParent -menu ..;

	menuItem -label (uiRes("m_hyperShadePanel.kVolumetricMaterials"))  -tearOff true -subMenu true;
		buildCreateSubMenu(
			"shader/volume",
			"hyperShadePanelCreate \"shader\"");
	setParent -menu ..;

	menuItem -divider true;

	menuItem -label (uiRes("m_hyperShadePanel.kTextures2D"))  -tearOff true -subMenu true;
		buildCreateSubMenu(
			"texture/2D",
			"hyperShadePanelCreate \"2dTexture\"");
		menuItem -divider true;
		radioMenuItemCollection;
		menuItem -label (uiRes("m_hyperShadePanel.kNormal2D"))
			-annotation (uiRes("m_hyperShadePanel.kNormal2DAnnot"))
			-radioButton
				(`optionVar -query create2dTextureType` == "normal")
			-command
				("optionVar "
					+ "-stringValue create2dTextureType \"normal\";"
					+ "refreshCreateNodeUI();")
			textureAsNormalItem;
		menuItem -label (uiRes("m_hyperShadePanel.kProjection2D"))
			-annotation (uiRes("m_hyperShadePanel.kProjection2DAnnot"))
			-radioButton
				(`optionVar -query create2dTextureType` == "projection")
			-command
				("optionVar "
					+ "-stringValue create2dTextureType \"projection\";"
					+ "refreshCreateNodeUI();")
			textureAsProjectionItem;
		menuItem -label (uiRes("m_hyperShadePanel.kStencil2D"))
			-annotation (uiRes("m_hyperShadePanel.kStencil2DAnnot"))
			-radioButton
				(`optionVar -query create2dTextureType` == "stencil")
			-command
				("optionVar "
					+ "-stringValue create2dTextureType \"stencil\";"
					+ "refreshCreateNodeUI();")
			textureAsStencilItem;
	setParent -menu ..;

	menuItem -label (uiRes("m_hyperShadePanel.kTextures3D"))  -tearOff true -subMenu true;
		buildCreateSubMenu(
			"texture/3D",
			"hyperShadePanelCreate \"3dTexture\"");
	setParent -menu ..;

	menuItem -label (uiRes("m_hyperShadePanel.kEnvironmentTextures"))  -tearOff true -subMenu true;
		buildCreateSubMenu(
			"texture/environment",
			"hyperShadePanelCreate \"3dTexture\"");
	setParent -menu ..;

	buildCreateSubMenu(
		"texture/other",
		"hyperShadePanelCreate \"otherTexture\"");

	menuItem -divider true;

	menuItem -label (uiRes("m_hyperShadePanel.kGeneralUtilities"))  -tearOff true -subMenu true;
		buildCreateSubMenu(
			"utility/general",
			"hyperShadePanelCreate \"utility\"");
	setParent -menu ..;

	menuItem -label (uiRes("m_hyperShadePanel.kScalarUtilities"))  -tearOff true -subMenu true;
		buildCreateSubMenu(
			"utility/scalar",
			"hyperShadePanelCreate \"utility\"");
	setParent -menu ..;

	menuItem -label (uiRes("m_hyperShadePanel.kSwitchUtilities"))  -tearOff true -subMenu true;
		buildCreateSubMenu(
			"utility/switch",
			"hyperShadePanelCreate \"utility\"");
	setParent -menu ..;

	menuItem -label (uiRes("m_hyperShadePanel.kColorUtilities"))  -tearOff true -subMenu true;
		buildCreateSubMenu(
			"utility/color",
			"hyperShadePanelCreate \"utility\"");
	setParent -menu ..;

	menuItem -label (uiRes("m_hyperShadePanel.kParticleUtilities"))  -tearOff true -subMenu true;
		buildCreateSubMenu(
			"utility/particle",
			"hyperShadePanelCreate \"utility\"");
	setParent -menu ..;
	menuItem -label (uiRes("m_hyperShadePanel.kGlow"))  -tearOff true -subMenu true;
		string $nodes[1];
		$nodes[0] = "opticalFX";
		buildCreateNodesSubMenu(
			$nodes,
			"hyperShadePanelCreate \"utility\"");
	setParent -menu ..;

	menuItem -divider true;

	menuItem -label (uiRes("m_hyperShadePanel.kCreateLights"))  -tearOff true -subMenu true;
		buildCreateSubMenu(
			"light",
			"hyperShadePanelCreate \"light\"");
	setParent -menu ..;

	menuItem
		-label (uiRes("m_hyperShadePanel.kCamera"))
		-annotation (uiRes("m_hyperShadePanel.kCreateCameraAnnot"))
		-command ("hyperShadePanelCreate \"camera\" \"\"");
	if (`licenseCheck -m "edit" -typ "complete"`)
	{
		menuItem -label (uiRes("m_hyperShadePanel.kImagePlane"))
			-annotation (uiRes("m_hyperShadePanel.kCreateImagePlane"))
			-command ("hyperShadePanelCreate \"node\" \"imagePlane\"");
	}
	menuItem -label (uiRes("m_hyperShadePanel.kRendering"))  -tearOff true -subMenu true;
		buildCreateSubMenu(
			"rendering",
			"hyperShadePanelCreate \"rendering\"");
	setParent -menu ..;

	menuItem -divider true;

    // call the registered UI callbacks
    // note that each of these callbacks should end with 'menuItem -divider true;'
    // in order to preserve the expected look of the Maya UI
    callbacks -executeCallbacks -hook hyperShadePanelBuildCreateMenu;

	menuItem
		-label (uiRes("m_hyperShadePanel.kCreateRenderNode"))
		-annotation (uiRes("m_hyperShadePanel.kCreateRenderNodeAnnot"))
		-command
			("hyperShadePanelMenuCommand(\""
				+ $panel
				+ "\", \"createNewNode\")");
	menuItem -divider true;

	menuItem -label (uiRes("m_hyperShadePanel.kCreateOptions"))  -subMenu true;

		$includeShadingGroupItem =
			`menuItem
				-label (uiRes("m_hyperShadePanel.kIncludeShadingGroupwithMaterials"))
				-checkBox true
				-annotation
					(uiRes("m_hyperShadePanel.kIncludeShadingGroupwithMaterialsAnnot"))
				includeShadingGroupItem`;
		menuItem
			-edit
			-checkBox
				`optionVar -query createMaterialsWithShadingGroup`
			-command
				("optionVar -intValue createMaterialsWithShadingGroup "
					+ "`menuItem -query -checkBox "
					+ $includeShadingGroupItem
					+ "`; refreshCreateNodeUI();")
			$includeShadingGroupItem;

		$createIncludePlacementItem =
			`menuItem
				-label (uiRes("m_hyperShadePanel.kIncludePlacementWithTextures"))
				-checkBox true
				-annotation
					(uiRes("m_hyperShadePanel.kIncludePlacementWithTexturesAnnot"))
				createIncludePlacementItem`;
		menuItem
			-edit
			-checkBox
				`optionVar -query createTexturesWithPlacement`
			-command
				("optionVar -intValue createTexturesWithPlacement "
					+ "`menuItem -query -checkBox "
					+ $createIncludePlacementItem
					+ "`; refreshCreateNodeUI();")
			$createIncludePlacementItem;

	//setParent ..;
	setParent -menu ..;
}

global proc hyperShadePanelShapeDisplay()
{
	if( `optionVar -q hsNoShapes` )
	{
	}
}

global proc hyperShadePanelBuildDisplayOptionsMenu(
	string $panel,
	string $menuParent)
{
	//
	// Description:
	//	This procedure is called every time the Options->Display menu
	//	item in the hypershade panel menu is selected.
	//	This procedure creates the menu items which will appear in that menu.
	//

	setParent $panel;
	setParent -menu $menuParent;
	menu
		-edit
		-deleteAllItems
		$menuParent;

		radioMenuItemCollection;

		if( !`optionVar -exists hsShapeDisplay` )
		{
			optionVar -intValue hsShapeDisplay 2;
		}
		int $shapeDisplay = `optionVar -query hsShapeDisplay`;

		menuItem
			-label (uiRes("m_hyperShadePanel.kNoShapes"))
			-radioButton ($shapeDisplay == 0)
			-annotation
				(uiRes("m_hyperShadePanel.kNoShapesAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"displayNoShapes\")");
		menuItem
			-label (uiRes("m_hyperShadePanel.kAllShapesExceptShadingGroupMembers"))
			-radioButton ($shapeDisplay == 1)
			-annotation
				(uiRes("m_hyperShadePanel.kAllShapesExceptShadingGroupMembersAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"displayInterestingShapes\")");
		menuItem
			-label (uiRes("m_hyperShadePanel.kAllShapes"))
			-radioButton ($shapeDisplay == 2)
			-annotation
				(uiRes("m_hyperShadePanel.kAllShapesAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"displayAllShapes\")");


		menuItem -divider true;

		if( !`optionVar -exists hsTransformDisplay` )
		{
			optionVar -intValue hsTransformDisplay 1;
		}
		int $transformDisplay = `optionVar -query hsTransformDisplay`;

		menuItem
			-label (uiRes("m_hyperShadePanel.kTransforms"))
			-checkBox $transformDisplay
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"toggleTransformDisplay\")");

	setParent -menu ..;
}


global proc hyperShadePanelBuildTabOptionsMenu(
	string $panel,
	string $menuParent)
{
	//
	// Description:
	//	This procedure is called every time the Tabs->Current Tab Options menu
	//	item in the hypershade panel menu is selected.
	//	This procedure creates the menu items which will appear in that menu,
	//	such that they are the appropriate ones for the active tab type.
	//

	setParent $panel;
	setParent -menu $menuParent;
	menu
		-edit
		-deleteAllItems
		$menuParent;

	string $activeTab = activeTab($panel);

	if (isDiskTab($activeTab))
	{
		string $libraryUI = lookupComponentName($activeTab);
		int $onlyDirectoriesShown = false;
		int $onlyFilesShown = false;
		int $bothShown = false;

		if (
				libraryUIDirectoriesShown($libraryUI)
			&&	libraryUIFilesShown($libraryUI))
		{
			$bothShown = true;
		}
		else if (libraryUIDirectoriesShown($libraryUI))
		{
			$onlyDirectoriesShown = true;
		}
		else if (libraryUIFilesShown($libraryUI))
		{
			$onlyFilesShown = true;
		}

		radioMenuItemCollection;
		menuItem
			-label (uiRes("m_hyperShadePanel.kShowDirectoriesOnly"))
			-radioButton $onlyDirectoriesShown
			-annotation
				(uiRes("m_hyperShadePanel.kShowDirectoriesOnlyAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"showDirectoriesOnly\")");
		menuItem
			-label (uiRes("m_hyperShadePanel.kShowFilesOnly"))
			-radioButton $onlyFilesShown
			-annotation
				(uiRes("m_hyperShadePanel.kShowFilesOnlyAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"showFilesOnly\")");
		menuItem
			-label (uiRes("m_hyperShadePanel.kShowBoth"))
			-radioButton $bothShown
			-annotation
				(uiRes("m_hyperShadePanel.kShowBothAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"showDirectoriesAndFiles\")");
		menuItem -divider true;
		menuItem
			-label (uiRes("m_hyperShadePanel.kRefreshFileListing"))
			-annotation
				(uiRes("m_hyperShadePanel.kRefreshFileListingAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"refreshFileListing\")");
		menuItem
			-label (uiRes("m_hyperShadePanel.kRefreshSelectedSwatches"))
			-annotation
				(uiRes("m_hyperShadePanel.kRefreshSelectedSwatchesAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"refreshSelectedSwatches\")");
		menuItem
			-label (uiRes("m_hyperShadePanel.kRefreshAllSwatches"))
			-annotation
				(uiRes("m_hyperShadePanel.kRefreshAllSwatchesAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"refreshAllSwatches\")");
		menuItem -divider true;
		menuItem
			-label (uiRes("m_hyperShadePanel.kGenerateSwatchFilesForImages"))
			-annotation
				(uiRes("m_hyperShadePanel.kGenerateSwatchFilesForImagesAnnot"))
			-command
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"saveSwatchesToDisk\")");
	}
	else
	{
		menuItem
			-label (uiRes("m_hyperShadePanel.kNoOptionsAvailable"))
			-enable false;
	}

	setParent -menu ..;
}

global proc hyperShadePanelGraphCommand(
	string $panel,
	string $command)
{
	// Determine which graph tab (work area) would be the most appropriate
	// tab to perform this operation in. This will be called the target tab.
	//
	string $targetTab;

	$targetTab = targetGraphTab($panel);

	// Get the name of the hypershade in the target graph tab so that we
	// can graph into it.
	//
	string $graphUI;

	$graphUI = lookupComponentName($targetTab);

    global string $gHypershadeNodeEditor;	
    int $isNodeEditor = `nodeEditor -exists $gHypershadeNodeEditor`;
  

	string $nothingSelected = (uiRes("m_hyperShadePanel.kNothingSelected"));

	if ($command == "graphMaterials")
	{
		if (size(`ls -sl`) != 0)
		{
			graphUIGraphMaterials($graphUI);
			
			if ($isNodeEditor != 0)
			{
				nodeEdGraphControl($gHypershadeNodeEditor, "nodeEditor -e -shaderNetworks");
				removeUnwantedNodes($gHypershadeNodeEditor);
			}
		}
		else
		{
			warning $nothingSelected;
		}
	}
	else if ($command == "clearGraph")
	{
		graphUIClearGraph($graphUI);
		if ($isNodeEditor != 0)
			nodeEditor -e -rootNode "" $gHypershadeNodeEditor;
	}
	else if ($command == "showUpAndDownstream")
	{
		if (size(`ls -sl`) != 0)
		{
			graphUIShowUpAndDownstream($graphUI);
			if ($isNodeEditor != 0)
			{
				nodeEdGraphControl($gHypershadeNodeEditor, "nodeEditor -e -rfs -ups -ds");
				removeUnwantedNodes($gHypershadeNodeEditor);
			}
		}
		else
		{
			warning $nothingSelected;
		}
	}
	else if ($command == "showUpstream")
	{
		if (size(`ls -sl`) != 0)
		{
			graphUIShowUpstream($graphUI);
			if ($isNodeEditor != 0)
			{
				nodeEdGraphControl($gHypershadeNodeEditor, "nodeEditor -e -rfs -ups");
				removeUnwantedNodes($gHypershadeNodeEditor);
			}
		}
		else
		{
			warning $nothingSelected;
		}
	}
	else if ($command == "showDownstream")
	{
		if (size(`ls -sl`) != 0)
		{
			graphUIShowDownstream($graphUI);
			if ($isNodeEditor != 0)
			{
				nodeEdGraphControl($gHypershadeNodeEditor, "nodeEditor -e -rfs -ds");	
				removeUnwantedNodes($gHypershadeNodeEditor);
			}
		}
		else
		{
			warning $nothingSelected;
		}
	}
	else if ($command == "rearrangeGraph")
	{
		graphUIRearrangeGraph($graphUI);
		if ($isNodeEditor != 0)
			nodeEditor -e -frameAll -layout $gHypershadeNodeEditor;
	}
	else if ($command == "showPreviousGraph")
	{
		graphUIShowPreviousGraph($graphUI);
	}
	else if ($command == "showNextGraph")
	{
		graphUIShowNextGraph($graphUI);
	}
	else if ($command == "addSelected")
	{
		graphUIAddSelected($graphUI);
		if ($isNodeEditor != 0)
			nodeEdGraphControl($gHypershadeNodeEditor, "nodeEditor -e -gsl -agm 1 ");
	}
	else if ($command == "removeSelected")
	{
		graphUIRemoveSelected($graphUI);
		if ($isNodeEditor != 0)
			nodeEditor -e -rem "" $gHypershadeNodeEditor;
	}
	else if ($command == "createContainer")
	{
		graphUICreateContainer($graphUI);
	}
	else if ($command == "removeContainer")
	{
		graphUIRemoveContainer($graphUI);
	}
	else if ($command == "collapseContainer")
	{
		graphUICollapseContainer($graphUI);
	}
	else if ($command == "expandContainer")
	{
		graphUIExpandContainer($graphUI);
	}

	refreshToolbar($panel);
	refreshGraphMenu($panel);
}

// Procedure for when pause button is pressed.
global proc hyperShadePanelPauseButtonCommand(string $panel)
{
	// Toggle the current status (this will update the button accordingly)
	int $state = `renderThumbnailUpdate -q`;
	int $new_state = $state == 0 ? 1 : 0;
	renderThumbnailUpdate $new_state;
}

global proc hyperShadePanelMenuCommand(
	string $panel,
	string $command)
{
	//
	// Description:
	//	This procedure is called whenever a menu item is chosen from the
	//	hypershade panel menu.
	//	This procedure is the single global procedure entry point to all
	//	functionality invoked by the menu items. This avoids cluttering the
	//	global procedure namespace with a global procedure for each menu item.
	//	This procedure causes the expected action to be performed. Typically
	//	this will mean calling some local procedure within this file to perform
	//	the action the user expects when they choose the menu item.
	//

	string $yes = (uiRes("m_hyperShadePanel.kYes"));
	string $no  = (uiRes("m_hyperShadePanel.kNo"));

	if ($command == "")
	{
	}
	else if ($command == "import")
	{
		Import;
	}
	else if (
			($command == "importSelectedSceneFiles")
		||	($command == "importSelectedImageFilesAsNormal")
		||	($command == "importSelectedImageFilesAsProjection")
		||	($command == "importSelectedImageFilesAsStencil"))
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab))
		{
			string $libraryUI;
			$libraryUI = lookupComponentName($activeTab);

			string $filesVisor;
			$filesVisor = libraryUIFilesVisor($libraryUI);

			string $filesToImport[];
			$filesToImport = `visor -query -selectedGadgets $filesVisor`;

			int $asProjection;
			int $asStencil;
			int $withPlacement;

			if ($command == "importSelectedImageFilesAsNormal")
			{
				$asProjection = false;
				$asStencil = false;
			}
			else if ($command == "importSelectedImageFilesAsProjection")
			{
				$asProjection = true;
				$asStencil = false;
			}
			else if ($command == "importSelectedImageFilesAsStencil")
			{
				$asProjection = false;
				$asStencil = true;
			}

			$withPlacement =
				(`optionVar -query createTexturesWithPlacement`);

			int $i;

			for ($i = 0; $i < size($filesToImport); $i++)
			{
				string $fileTypesArray[] =
					`file -query -type $filesToImport[$i]`;
				string $fileType = $fileTypesArray[0];

				if (
						($command == "importSelectedSceneFiles")
					&& 	(	($fileType == "mayaBinary")
						||	($fileType == "FBX")
						|| 	($fileType == "mayaPLE")
						|| 	($fileType == "mayaAscii")))
				{
					file -import $filesToImport[$i];
					string $printMsg = (uiRes("m_hyperShadePanel.kImpoted"));
					print(`format -s $filesToImport[$i] $printMsg`);
				}
				else if ($fileType == "image")
				{
					importImageFile(
						$filesToImport[$i],
						$asProjection,
						$asStencil,
						$withPlacement);
				}
			}
		}
	}
	else if ($command == "exportSelectedNetwork")
	{
		global string		$gv_operationMode;
		string				$filetype;
		string				$ws = `workspace -q -fn`;

		// Old projects saved their shaders in a directory called "lights".
		// New projects save both lights and shaders in a directory called
		// "shaders". We have to continue to specify that the shading network
		// be stored in whatever directory is used to store lights, just in
		// case this is an old project.
		//
		setWorkingDirectory $ws "image" "lights";

		if (`optionVar -exists defaultFileExportActiveType`)
		{
			$filetype = `optionVar -q defaultFileExportActiveType`;
		}
		else
		{
			$filetype = "mayaBinary";
		}

		$gv_operationMode = "ExportActive";

		// Open the file browser to export the selection
		//
		string $exportSelection = (uiRes("m_hyperShadePanel.kExportSelection"));
		fileBrowser "pv_performAction" $exportSelection $filetype 1;
	}
	else if ($command == "toggleRenderCreateBar")
	{
		int $manage = !`formLayout -q -manage createBarWrapForm`;
		optionVar -intValue hyperShadePanelCreateBarShown $manage;

		formLayout -e -manage $manage createBarWrapForm;

		setParent $panel;

		refreshCreateMenu($panel);
	}
	else if( $command == "displayNoShapes" )
	{
		optionVar -intValue hsShapeDisplay 0;
	}
	else if( $command == "displayInterestingShapes" )
	{
		optionVar -intValue hsShapeDisplay 1;
	}
	else if( $command == "displayAllShapes" )
	{
		optionVar -intValue hsShapeDisplay 2;
	}
	else if( $command == "toggleTransformDisplay" )
	{
		if( !`optionVar -exists hsTransformDisplay` )
		{
			optionVar -intValue hsTransformDisplay 1;
		}
		int $curVal = `optionVar -q hsTransformDisplay`;
		int $newVal;
		if( $curVal )
		{
			$newVal = 0;
		}
		else
		{
			$newVal = 1;
		}

		optionVar -intValue hsTransformDisplay $newVal;
	}
	else if ($command == "createNewNode")
	{
		createRenderNode("-all", "", "");
	}
	else if ($command == "duplicateShadingNetwork")
	{
		hyperShade -duplicate;
	}
	else if ($command == "duplicateWithoutNetwork")
	{
		duplicate;
	}
	else if ($command == "duplicateWithConnections")
	{
		duplicate -inputConnections;
	}
	else if ($command == "deleteShadingGroupsAndMaterials")
	{
		string $cmd;
		string $items[];
		string $item;

		$cmd = "delete ";
		$items = `lsThroughFilter DefaultShadingGroupsAndMaterialsFilter`;

		if (size($items) > 0)
		{
			for ($item in $items)
			{
				$cmd = ($cmd + " " + $item);
			}
			eval $cmd;
		}
	}
	else if ($command == "deleteTextures")
	{
		string $cmd;
		string $items[];
		string $item;

		$cmd = "delete ";
		$items = `lsThroughFilter DefaultTexturesFilter`;

		if (size($items) > 0)
		{
			for ($item in $items)
			{
				$cmd = ($cmd + " " + $item);
			}
			eval $cmd;
		}
	}
	else if ($command == "deleteLights")
	{
		string $cmd;
		string $items[];
		string $item;

		$cmd = "delete ";
		$items = `lsThroughFilter DefaultAllLightsFilter`;

		if (size($items) > 0)
		{
			for ($item in $items)
			{
				$cmd = ($cmd + " " + $item);
			}
			eval $cmd;
		}
	}
	else if ($command == "deleteUtilities")
	{
		string $cmd;
		string $items[];
		string $item;

		$cmd = "delete ";
		$items = `lsThroughFilter DefaultRenderUtilitiesFilter`;

		if (size($items) > 0)
		{
			for ($item in $items)
			{
				$cmd = ($cmd + " " + $item);
			}
			eval $cmd;
		}
	}
	else if ($command == "deleteCamerasAndImagePlanes")
	{
		string $cmd;
		string $items[];
		string $item;

		$cmd = "delete ";
		$items = `lsThroughFilter DefaultCameraShapesImagePlanesFilter`;

		if (size($items) > 0)
		{
			for ($item in $items)
			{
				$cmd = ($cmd + " " + $item);
			}
			eval $cmd;
		}
	}
	else if ($command == "deleteBakeSets")
	{
		string $cmd;
		string $items[];
		string $item;

		$cmd = "delete ";
		$items = `lsThroughFilter DefaultBakeSetsFilter`;

		if (size($items) > 0)
		{
			for ($item in $items)
			{
				$cmd = ($cmd + " " + $item);
			}
			eval $cmd;
		}
	}
	else if ($command == "selectShadingGroupsAndMaterials")
	{
		select
			-noExpand
			-replace
			`lsThroughFilter DefaultShadingGroupsAndMaterialsFilter`;
	}
	else if ($command == "selectTextures")
	{
		select
			-noExpand
			-replace
			`lsThroughFilter DefaultTexturesFilter`;
	}
	else if ($command == "selectLights")
	{
		select
			-noExpand
			-replace
			`lsThroughFilter DefaultAllLightsFilter`;
	}
	else if ($command == "selectUtilities")
	{
		select
			-noExpand
			-replace
			`lsThroughFilter DefaultRenderUtilitiesFilter`;
	}
	else if ($command == "selectCamerasAndImagePlanes")
	{
		select
			-noExpand
			-replace
			`lsThroughFilter DefaultCameraShapesImagePlanesFilter`;
	}
	else if ($command == "selectBakeSets")
	{
		select
			-noExpand
			-replace
			`lsThroughFilter DefaultBakeSetsFilter`;
	}
	else if ($command == "revertSelectedSwatches")
	{
		hyperShade -resetSwatch;
	}
	else if ($command == "convertToFileTexture")
	{
		performConvertSolidTx false;
	}
	else if ($command == "convertToFileTextureOptionBox")
	{
		performConvertSolidTx true;
	}
	else if ($command == "delete")
	{
		delete;
	}
	else if ($command == "deleteUnusedNodes")
	{
		MLdeleteUnused;
	}
	else if ($command == "createNewTab")
	{
		createNewTab($panel);
	}
	else if ($command == "moveTabUp")
	{
		moveTab($panel, "up");
	}
	else if ($command == "moveTabDown")
	{
		moveTab($panel, "down");
	}
	else if ($command == "moveTabLeft")
	{
		moveTab($panel, "left");
	}
	else if ($command == "moveTabRight")
	{
		moveTab($panel, "right");
	}
	else if ($command == "renameTab")
	{
		renameTab($panel);
	}
	else if ($command == "showTopTabsOnly")
	{
		showTopTabsOnly($panel);
	}
	else if ($command == "showBottomTabsOnly")
	{
		showBottomTabsOnly($panel);
	}
	else if ($command == "showTopAndBottomTabs")
	{
		showTopAndBottomTabs($panel);
	}
	else if ($command == "removeTab")
	{
		string $currentLabel = activeTabLabel($panel);
		string $msg = (uiRes("m_hyperShadePanel.kRemoveMsg"));
		string $displayMsg = `format -s $currentLabel $msg`;
		string $confirm =
			`confirmDialog
				-title (uiRes("m_hyperShadePanel.kConfirmRemoveCurrentTab"))
				-message $displayMsg
				-button $yes
				-button $no
				-defaultButton $no
				-cancelButton $no`;
		if ($confirm == $yes)
		{
			removeActiveTab($panel);
		}
	}
	else if ($command == "revertToDefaultTabs")
	{
		string $tabs[] = {"m_hyperShadePanel.kMaterialsTab",
						  "m_hyperShadePanel.kTexturesTab",
						  "m_hyperShadePanel.kUtilitiesTab",
						  "m_hyperShadePanel.kRenderingTab",
						  "m_hyperShadePanel.kLightsTab",
						  "m_hyperShadePanel.kCamerasTab",
						  "m_hyperShadePanel.kBakeSetsTab",
						  "m_hyperShadePanel.kProjectsTab",
						  "m_hyperShadePanel.kAssetNodesTab",
						  "m_hyperShadePanel.kWorkAreaTab",
						  "m_hyperShadePanel.kShaderLibraryTab" };

		string $defaultTabs = "" ;
		string $lastTab = "" ;
		int $tabCounter = 0;

		//
		//Add some elements from the tabs array
		//
		$defaultTabs += ( uiRes( $tabs[$tabCounter++] ) + ", " );
		$defaultTabs += ( uiRes( $tabs[$tabCounter++] ) + "\n" );

		//
		//The remaining elements from the tabs array (excluding the last) are added
		//
		for(/*Nothing here*/;$tabCounter < ( size($tabs)-1 );$tabCounter++)
		{
		//
		//Here the check has been made to avoid
		//adding comma (,) to the end of last but one string in the tabs array.
		//
			if($tabCounter == (size($tabs)-2) )
			{
				$defaultTabs += ( uiRes( $tabs[$tabCounter] ) );
			}
			else
			{
				$defaultTabs += ( uiRes( $tabs[$tabCounter] ) + ", " );
			}
		}

		//
		//Add the last element from the tabs array
		//
		$lastTab += ( uiRes( $tabs[size($tabs) - 1] ) );

		string $formatString = (uiRes("m_hyperShadePanel.kRevertAll"));
		string $displayMsg = `format -s $defaultTabs -s $lastTab $formatString`;
		string $confirm =
			`confirmDialog
				-title (uiRes("m_hyperShadePanel.kConfirmReverttoDefaultTabs"))
				-message $displayMsg
				-button $yes
				-button $no
				-defaultButton $no
				-cancelButton $no`;
		if ($confirm == $yes)
		{
			revertToDefaultTabs($panel);
		}
	}
	else if ($command == "showDirectoriesOnly")
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab))
		{
			string $libraryUI = lookupComponentName($activeTab);
			libraryUIShowDirectoriesOnly($libraryUI);
			string $tabOptionVar = lookupTabOptionVar($activeTab);
			updateTabOptionVar($tabOptionVar, $activeTab);
		}
	}
	else if ($command == "showFilesOnly")
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab))
		{
			string $libraryUI = lookupComponentName($activeTab);
			libraryUIShowFilesOnly($libraryUI);
			string $tabOptionVar = lookupTabOptionVar($activeTab);
			updateTabOptionVar($tabOptionVar, $activeTab);
		}
	}
	else if ($command == "showDirectoriesAndFiles")
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab))
		{
			string $libraryUI = lookupComponentName($activeTab);
			libraryUIShowDirectoriesAndFiles($libraryUI);
			string $tabOptionVar = lookupTabOptionVar($activeTab);
			updateTabOptionVar($tabOptionVar, $activeTab);
		}
	}
	else if ($command == "refreshFileListing")
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab))
		{
			string $libraryUI = lookupComponentName($activeTab);
			libraryUIRefreshFileListing($libraryUI);
		}
	}
	else if ($command == "refreshSelectedSwatches")
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab))
		{
			string $libraryUI = lookupComponentName($activeTab);
			libraryUIRefreshSelectedSwatches($libraryUI);
		}
	}
	else if ($command == "refreshAllSwatches")
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab))
		{
			string $libraryUI = lookupComponentName($activeTab);
			libraryUIRefreshAllSwatches($libraryUI);
		}
	}
	else if ($command == "saveSwatchesToDisk")
	{
		string $activeTab = activeTab($panel);
		if (isDiskTab($activeTab))
		{
			string $libraryUI = lookupComponentName($activeTab);
			libraryUISaveSwatchesToDisk($libraryUI);
		}
	}
	else if ($command == "frameSelected")
	{
		string $activeTab = activeTab($panel);
		string $component = lookupComponentName($activeTab);
		string $editor;

		if (isGraphTab($activeTab))
		{
			$editor = graphUIHypershadeName($component);
		}
		else if (isSceneTab($activeTab))
		{
			$editor = collectionUIHypershadeName($component);
		}
		else if (isDiskTab($activeTab))
		{
			$editor = libraryUIFilesVisor($component);
		}

        global string $gHypershadeNodeEditor;
   		nodeEditor -e -frameSelected $gHypershadeNodeEditor;

		if (size($editor) > 0)
		    hyperGraph -edit -frame $editor;
	}
	else if ($command == "frameAll")
	{
		string $activeTab = activeTab($panel);
		string $component = lookupComponentName($activeTab);
		string $editor;

		if (isGraphTab($activeTab))
		{
			$editor = graphUIHypershadeName($component);
		}
		else if (isSceneTab($activeTab))
		{
			$editor = collectionUIHypershadeName($component);
		}
		else if (isDiskTab($activeTab))
		{
			$editor = libraryUIFilesVisor($component);
		}

        global string $gHypershadeNodeEditor;
        nodeEditor -e -frameAll $gHypershadeNodeEditor;

		if (size($editor) > 0)
		    hyperGraph -edit -frameGraph $editor;
	}
	else if ($command == "keepSwatchesAtCurrentResolution")
	{
		hyperShade
			-fixRenderSize `optionVar -query keepSwatchesAtCurrentResolution`;
	}
	else if ($command == "smallIcons" || $command == "mediumIcons" || $command == "largeIcons" || $command == "superIcons")
	{
		string $activeTab = activeTab($panel);
		string $component = lookupComponentName($activeTab);
		string $editor;
		if (isSceneTab($activeTab))
		{
			$editor = collectionUIHypershadeName($component);
		    hyperGraph -edit -iconSize $command $editor;
	        string $optionVar = lookupTabOptionVar($activeTab);
		    optionVar
			    -stringValue ($optionVar + "IconSize")
		        $command;

			// Refresh both menu and icon
			refreshIconSize( $panel, $activeTab );

		}
        else
        {
            warning (uiRes("m_hyperShadePanel.kIconSizeChangeOperationNotImplemented"));
        }

	}
	else if ($command == "asIcons" || $command == "asList")
	{
		string $activeTab = activeTab($panel);
		string $component = lookupComponentName($activeTab);
		string $editor;
		if (isSceneTab($activeTab))
		{
			$editor = collectionUIHypershadeName($component);
			hyperGraph -edit -viewOption $command $editor;
			string $optionVar = lookupTabOptionVar($activeTab);
			optionVar
				-stringValue ($optionVar + "ViewOption")
				$command;
			registerViewOption($component, $command);

			// Refresh both menu and icon
			refreshViewOption( $panel, $activeTab );

		}
		else
        {
            warning (uiRes("m_hyperShadePanel.kListViewFunctionalityNotImplemented"));
        }
	}
	else if ($command == "byName" || $command == "byType" || $command == "byTime")
	{
		string $activeTab = activeTab($panel);
		string $component = lookupComponentName($activeTab);
		if (isSceneTab($activeTab))
		{
			string $optionVar = lookupTabOptionVar($activeTab);
			optionVar
				-stringValue ($optionVar + "SortOption")
				$command;

			// Register this in the colletionUIlookupTable
			registerSortOption($component, $command);

			// Refresh both menu and icon
			refreshSortOption( $panel, $activeTab );

			// Need to refresh the command action of the current visor.
			// First, remove any folders in the HyperShade.
			//
			string $hypershadeName = lookupHypershadeName( $component );
			string $fl[] = `visor -q -fl $hypershadeName`;
			string $f;
			for( $f in $fl )
			{
				visor -deleteFolder $f $hypershadeName;
			}

			// Second, create a new folder that orders nodes
			// according to our sorting method.
			// Account for both the sort and reverse flag.
			//
			string $filter = collectionUIAdvancedFilter( $component );
			string $reverse = collectionUIReverseOption( $component );
			string $cmd = "lsThroughFilter -na " + $filter
				+ " -sort " + $command
				+ " -reverse " + $reverse;
			visor
				-addFolder
				-name "foobar"
				-type command
				-cmd $cmd
				$hypershadeName;
		}
		else
        {
            warning (uiRes("m_hyperShadePanel.kSortOrderFunctionalityNotImplemented"));
        }
	}
	else if ($command == "reverseOrder")
	{
		string $activeTab = activeTab($panel);
		string $component = lookupComponentName($activeTab);
		if (isSceneTab($activeTab))
		{
			// Reverse the current option and register this in the
			// colletionUIlookupTable
			//
			string $reverse = collectionUIReverseOption( $component );
			$reverse = ($reverse == "true") ? "false" : "true";
			string $optionVar = lookupTabOptionVar($activeTab);
			optionVar
				-stringValue ($optionVar + "ReverseOption")
				$reverse;
			registerReverseOption($component, $reverse);

			// Refresh both menu and icon
			refreshReverseOption( $panel, $activeTab );

			// Need to refresh the command action of the current visor.
			// First, remove any folders in the HyperShade.
			//
			string $hypershadeName = lookupHypershadeName( $component );
			string $fl[] = `visor -q -fl $hypershadeName`;
			string $f;
			for( $f in $fl )
			{
				visor -deleteFolder $f $hypershadeName;
			}

			// Second, create a new folder that orders nodes
			// according to our sorting method.
			// Account for both the sort and reverse flag.
			//
			string $filter = collectionUIAdvancedFilter( $component );
			string $sort = collectionUISortOption( $component );
			string $cmd = "lsThroughFilter -na " + $filter
				+ " -sort " + $sort
				+ " -reverse " + $reverse;
			visor
				-addFolder
				-name "foobar"
				-type command
				-cmd $cmd
				$hypershadeName;
		}
		else
        {
            warning( (uiRes("m_hyperShadePanel.kNotASceneTabWarn")));
        }
	}

	else
	{
		string $errorMsg = (uiRes("m_hyperShadePanel.kCommandNotImplemented"));
		error
			-showLineNumber true
			(`format -s $command $errorMsg`);
	}
}

global proc hyperShadePanelGraphNodeNetwork(
	string $panel,
	string $hypershade,
	string $node)
{
	//
	// Description:
	//	This procedure is called from the RMB popup menu of a node in a
	//	scene or graph tab in the shader editor.
	//	This method determines what tab the RMB menu is being invoked from,
	//	what tab the graph should be displayed in, and displays the graph.
	//

    //
    // First we graph the node in the node editor if it exists.
    //
    global string $gHypershadeNodeEditor;	
    int $isNodeEditor = `nodeEditor -exists $gHypershadeNodeEditor`;
  	if ($isNodeEditor != 0)
	{
	    nodeEdGraphControl($gHypershadeNodeEditor, "nodeEditor -e -rootNode " + $node + " -ups -ds");
	    removeUnwantedNodes($gHypershadeNodeEditor);
	}

	//
	// To determine what tab the RMB is being invoked from is a bit ugly. We
	// will search up the parent structure from the hypershade which has been
	// provided, looking for firstPaneTabs or secondPaneTabs. We keep track of
	// the layout we just came from so that when we find firstPaneTabs or
	// secondPaneTabs we know what tab contained the hypershade.
	//

	setParent $panel;
	string $firstPaneTabs = `setParent firstPaneTabs`;
	setParent $panel;
	string $secondPaneTabs = `setParent secondPaneTabs`;

	string $parent = `hyperGraph -query -parent $hypershade`;
	string $child;

	setParent $parent;

	while (($parent != $firstPaneTabs) && ($parent != $secondPaneTabs))
	{
		$child = $parent;
		$parent = `setParent ..`;
		if ($parent == "") break;
	}

	if (($parent != $firstPaneTabs) && ($parent != $secondPaneTabs))
	{
		error
			-showLineNumber true
			(uiRes("m_hyperShadePanel.kErrorMsg"));
	}

	// When we get to here, the name of the tab from which the menu was invoked
	// is stored in $child. To make things a little easier to understand, we
	// will store that name in $activeTab.
	//
	string $activeTab = $child;
	string $tabType = lookupTabType($activeTab);

	if (($tabType == "graph") || ($tabType == "protected graph"))
	{
		// The user is already in a graph, so we will graph the network in this
		// graph.
		//
		if (`optionVar -query hsClearBeforeGraphing` == 1)
		{
			hyperShade -clearWorkArea $hypershade;
		}

		hyperShade -shaderNetwork $node $hypershade;

		if (`optionVar -query hsClearBeforeGraphing` == 1)
		{
			hyperGraph -edit -frameGraph $hypershade;
		}
	}
	else if ($tabType == "scene")
	{
		// The user is in a scene graph, so we will graph the network in the
		// protected graph (default Work Area)
		//
		string $protectedGraphTab = `optionVar -q hyperShadePanelWorkAreaTab`;
        if ($protectedGraphTab != "")
        {
		    // Get the name of the hypershade in the protected graph tab so that we
		    // can graph into it.
		    //
		    string $graphUI;
		    string $hypershadeName;

		    $graphUI = lookupComponentName($protectedGraphTab);
		    $hypershadeName = graphUIHypershadeName($graphUI);

		    if (`optionVar -query hsClearBeforeGraphing` == 1)
		    {
			    hyperShade -clearWorkArea $hypershadeName;
		    }

		    hyperShade -shaderNetwork $node $hypershadeName;
		    hyperGraph -edit -frameGraph $hypershadeName;
        }
	}
}

global proc hyperShadePanelSceneAndGraphTabPopupMenu(
	string $panel,
	string $hypershade,
	string $popupMenuName)
{
	//
	// Description:
	//	This procedure is called when the user RMB clicks in a scene or graph
	//	tab hypershade editor.
	//	This procedure builds the menu items which will appear in the popup
	//	menu.
	//	If the cursor is over a node, this procedure calls
	//	sceneAndGraphTabNodePopupMenu() to build the node-specific menu items.
	//

	if (!`popupMenu -e -exists $popupMenuName`) return;

	// Delete the existing menu items from the popup menu.
	//
	popupMenu -edit -deleteAllItems $popupMenuName;
	setParent -menu $popupMenuName;

	string $node = `hyperGraph -query -feedbackNode $hypershade`;
	string $gadget = `hyperGraph -query -feedbackGadget $hypershade`;

	if ($gadget == "Outputs")
	{
		hypergraphOutputsMenu($hypershade, $popupMenuName, $node);
		return;
	}

	if ($node != "")
	{
		menuItem
			-label (uiRes("m_hyperShadePanel.kGraphNetwork"))
			-radialPosition "S"
			-command
				("hyperShadePanelGraphNodeNetwork "
					+ $panel
					+ " "
					+ $hypershade
					+ " "
					+ $node);

		buildHypergraphNodePopupMenuItems($hypershade, $node);

		menuItem -divider true;

		string $nodeType = `nodeType $node`;
		string $helpLabel = (uiRes("m_hyperShadePanel.kHelpMenuLabel"));
		menuItem
			-label `format -s $nodeType $helpLabel`
			-enableCommandRepeat false
			-command ("showHelp -docs \"Nodes/" + $nodeType + ".html\"");
	}
	else
	{
		// There is no node under the cursor.
		//
		buildMainMenu(
			$panel,
			true); // popup menu
	}
}

global proc hyperShadePanelDiskTabPopupMenu(
	string $panel,
	string $editor,
	string $popupMenu)
{
	//
	// Description:
	//	This procedure is called when the user RMB clicks in a disk tab visor.
	//	This procedure builds the menu items which will appear in the popup
	//	menu.
	//	The contents of the menu can vary based on the type of file the cursor
	//	is positioned over.
	//

	if (!`popupMenu -e -exists $popupMenu`) return;

	// Delete the existing menu items from the popup menu.
	//
	popupMenu -edit -deleteAllItems $popupMenu;
	setParent -menu $popupMenu;

	// Determine what file is under the mouse pointer, if any
	//
	string $filePath = `hyperGraph -query -feedbackNode $editor`;

	if ($filePath != "")
	{
		buildHypergraphFilePopupMenuItems($editor, $popupMenu, $filePath);
	}
	else
	{
		// There is no file under the cursor.
		//
		buildMainMenu(
			$panel,
			true); // popup menu
	}
}

proc framePane(
	string $panel,
    string $paneTabsName,
	string $frameOperation)
{
	//
	// Description:
	//	This procedure is called from frame() when
	//	the user presses a hotkey to frame the contents of a tab in the
	//	hypershade panel.
	//	This procedure determines for the pane specified by the given
    //  $paneTabsName what tab the user's cursor is over, and
	//	performs a frame all or frame selected operation on the component UI in
	//	that tab as requested by the $frameOperation.
	//

    global string $gHypershadeNodeEditor;
    if (`nodeEditor -exists $gHypershadeNodeEditor`)
    {
		if ($frameOperation == "all")
		{
            nodeEditor -e -frameAll $gHypershadeNodeEditor;
        }
        else if ($frameOperation == "selected")
		{
		    nodeEditor -e -frameSelected $gHypershadeNodeEditor;
		}
    }

	setParent $panel;
	string $paneTabs = `setParent $paneTabsName`;

	string $paneTab = `tabLayout -query -selectTab $paneTabs`;

    if ($paneTab == "")
    {
        // No tab is in this pane.  Do nothing.
        //
        return;
    }

    $paneTab = `setParent $paneTab`;

	string $paneHypergraph;

	string $componentName;

	$componentName = lookupComponentName($paneTab);

    if ($componentName == "")
    {
        // The component has not been created yet.  So this
        // can not be the hot key target.
        //
        return;
    }

	if (isDiskTab($paneTab))
	{
		$paneHypergraph = libraryUIFilesVisor($componentName);
	}
	else if (isGraphTab($paneTab))
	{
		$paneHypergraph = graphUIHypershadeName($componentName);
	}
	else if (isSceneTab($paneTab))
	{
		$paneHypergraph = collectionUIHypershadeName($componentName);
	}

	if (`hyperGraph -query -isHotkeyTarget $paneHypergraph`)
	{
		if ($frameOperation == "all")
		{
			hyperGraph
				-edit
				-frameGraph
				$paneHypergraph;
		}
		else if ($frameOperation == "selected")
		{
			hyperGraph
				-edit
				-frame
				$paneHypergraph;
		}

		// Set focus to the tab layout which received the frame command
		//
		hyperShadePanelSetActiveTabLayout($panel, $paneTabsName, false);
	}
}

proc frame(
	string $panel,
	string $frameOperation)
{
	//
	// Description:
	//	This procedure is called from frameAll() or frameSelected() when
	//	the user presses a hotkey to frame the contents of a tab in the
	//	hypershade panel.
	//	This procedure determines what tab the user's cursor is over, and
	//	performs a frame all or frame selected operation on the component UI in
	//	that tab as requested by the $frameOperation.
	//

	// Determine which tab layout is currently active
	//
	string 	$activeTabLayout;
	string 	$inactiveTabLayout;
	if (activePaneIndex($panel) == 1)
	{
		$activeTabLayout = "firstPaneTabs";
		$inactiveTabLayout = "secondPaneTabs";
	}
	else
	{
		$inactiveTabLayout = "firstPaneTabs";
		$activeTabLayout = "secondPaneTabs";
	}
    
    // frame both panes.  The hotkey handling will figure out which pane the mouse if over.
    framePane($panel, $activeTabLayout, $frameOperation);
    framePane($panel, $inactiveTabLayout, $frameOperation);
}

global proc hyperShadePanelFrameAll(
	string $panel)
{
	//
	// Description:
	//	This procedure is typically called from fitPanel() in fitPanel.mel when
	//	the user presses a hotkey to frame the contents of a tab in the
	//	hypershade panel.
	//	This procedure calls frame() to perform the operation.
	//
	frame($panel, "all");
}

global proc hyperShadePanelFrameSelected(
	string $panel)
{
	//
	// Description:
	//	This procedure is typically called from fitPanel() in fitPanel.mel when
	//	the user presses a hotkey to frame the selected items in a tab in the
	//	hypershade panel.
	//	This procedure calls frame() to perform the operation.
	//
	frame($panel, "selected");
}

global proc hyperShadePanelRebuildCreateBarUI(
	string $panel)
{
	//
	// Description:
	//	This procedure is called when the contents of the hypershade create bar
	//	no longer accurately reflect what can be created. Usually this is
	//	because a plugin has been loaded or unloaded.
	//	This procedure deletes the UI in the create bar and rebuilds it.
	//

	// Get the name of the layout containing the create bar UI
	//
	string $renderCreateBarUI = renderCreateBarUIName($panel);
    if ($renderCreateBarUI == "")
        return;

	int $managed = `formLayout -q -manage createBarWrapForm`;

	// Hide the section of the hyperShadePanel which contains the
	// create bar until it has finished building
	//
	if ($managed)
	{
		// The create bar is currently being displayed.
		// In order to update it without things looking bad in the process,
		// we will collapse the pane which contains the create bar and
		// expand it after we are finished.
		//
		setParent $panel;
		formLayout -e -manage false createBarWrapForm;
	}

	// Delete the existing UI
	//
	deleteUI $renderCreateBarUI;

	// Build the new create bar
	//
    string $createBarForm = hyperShadeCreateBarForm($panel);
    $createBarForm = `setParent $createBarForm`;
	renderCreateBarUI($createBarForm);

	// Show the create bar again, if it was being shown before
	//
	if ($managed)
	{
		formLayout -e -manage true createBarWrapForm;
	}
}

proc int isLookdevType(string $type, string $changeType)
{
	// Determine the classification(s) of each node type. Note that nodes
	// can have multiple classifications.
	//
	string $classificationArray[] = `getClassification $type`;
	for ($classification in $classificationArray) {
		string $classificationChunks[];
		int $numChunks = tokenize($classification, ":", $classificationChunks);
		for ($classificationChunk in $classificationChunks) {
			string $tokenArray[];
			int $numTokens = tokenize($classificationChunk, "/", $tokenArray);
			// pass the classification chunk to the callbacks to see if a rebuild is required for a plugin
			int $pluginRebuildRequiredResultArray[] = `callbacks -executeCallbacks -hook hyperShadePanelPluginChange $classificationChunk $changeType`;
			for ($currentPluginRebuildResult in $pluginRebuildRequiredResultArray) {
				if ($currentPluginRebuildResult) {
					return 1;
				}
			}
			if (	($tokenArray[0] == "texture")
				||	($tokenArray[0] == "shader")
				||	($tokenArray[0] == "light")
				||	($tokenArray[0] == "utility")
				||	($tokenArray[0] == "imageplane")
				||	($tokenArray[0] == "postprocess") ) {
				return 1;
			}
		}
	}
	return 0;
}

global proc string[] lookdevNodeTypes(string $typesIn[])
{
	int $pos = 0;
	string $typesOut[];
	for($type in $typesIn) {
		if(isLookdevType($type, "loadPlugin")) {
			$typesOut[$pos++] = $type;
		}
	}
	return $typesOut;
}

proc pluginChange(
	string $panel,
	string $changeType,
	string $plugin)
{
	//
	// Description:
	//	This procedure is called from hyperShadePanelLoadPluginCallback() or
	//	from hyperShadePanelUnloadPluginCallback(). If this method is being
	//	called because a plugin has been loaded, $changeType should be
	//	"loadPlugin". If this method is being called because a plugin is
	//	about to be unloaded, $changeType should be "unloadPlugin". There
	//	are no other valid values for $changeType.
	//	This method determines if the create bar UI needs to be updated as a
	//	result of the loading or unloading of the specified plugin, and if so,
	//	deletes and rebuilds the create bar UI.
	//

	// Get a list of all node types loaded by the plugin
	//
	string $pluginNodeTypeArray[] = `pluginInfo -query -dependNode $plugin`;

	string $nodeType;

	for ($nodeType in $pluginNodeTypeArray)
	{
		if (isLookdevType($nodeType, $changeType))
		{
			// The node type is classified as something which appears
			// within the create bar, so we need to refresh
			// that window.
			//
			// Note that the above list needs to be kept in sync with the
			// types of nodes which appear in the create bar.
			//
			if ($changeType == "loadPlugin")
			{
				hyperShadePanelRebuildCreateBarUI($panel);
				return;
			}
			else if ($changeType == "unloadPlugin")
			{
				// The plugin is being unloaded, but is not yet gone. We
				// want to refresh the create bar but not until
				// after the plugin has finished unloading. If we don't
				// wait until the plugin has finished unloading, then the
				// refreshed create bar will still contain the node types
				// defined by the plugin.
				//
				// To make sure the plugin has finished unloading before we
				// refresh the create bar, we will defer the evaluation of
				// the refresh command until idle time.
				//
				evalDeferred(
					"hyperShadePanelRebuildCreateBarUI "
					+ $panel);

				return;
			}
		}
	}
}

global proc hyperShadePanelLoadPluginCallback(
	string $panel,
	string $pluginName)
{
	//
	// Description:
	//	This procedure is called when a plugin has been loaded.
	//	This procedure calls pluginChange(), which will update the create bar
	//	if necessary as a result of the newly loaded plugin.
	//

	pluginChange($panel, "loadPlugin", $pluginName);
}

global proc hyperShadePanelUnloadPluginCallback(
	string $panel,
	string $pluginName)
{
	//
	// Description:
	//	This procedure is called when a plugin is about to be unloaded.
	//	This procedure calls pluginChange(), which will update the create bar
	//	if necessary as a result of the unloading of the plugin.
	//
	pluginChange($panel, "unloadPlugin", $pluginName);
}


// ---------------------------------------------------------------------------
// 	Scripted panel support
//

global proc createHyperShadePanel(string $panel)
{
	//
	// Description:
	//	This procedure is called the first time the shader editor is opened.
	//	This procedure creates the various UI entities that the shader
	//	editor will use, except for those UI entities which are controls.
	//
}

// Description: Copy the bin list from the render globals attribute to
// the mel global variable.
//
proc initHyperShadeBinList()
{
    if( !`optionVar -exists hsBinsSortShadingNodesOnly` )
    {
        optionVar -intValue hsBinsSortShadingNodesOnly 1;
    }
}

global proc initHyperShadePanel(string $panel)
{
    // Copy the bin list from the render globals attribute to
    // the mel global variable.
    //
    initHyperShadeBinList();

	// This is called when the file changes to make sure that everything
	// is up-to-date with the new file.
	//
    if (`exists hyperShadeUpdateBinsUISceneOpenCallback`)
    {
        hyperShadeUpdateBinsUISceneOpenCallback();
    }

	// Create the lookup table which will keep track of the tabs, their types,
	// and their associated components.
	//
	createHyperShadePanelLookupTable();

	// Update the state of paneles in Hypershade.
	// Some panel types are deleted by an file-new operation
	// so this is a chance to restore those panels if they where open.
	// The call must be done after the file-new operations is completed
	// so we use an evalDeferred here.
	// 
	evalDeferred -lowPriority "updateHyperShadePanelState";
}

global int $gHypershadePluginCallbacksRegistered = false;

// Description:  This procedure is called to create the content for
//      the HyperShade Node Editor toolbar.
//
proc createHypershadeNodeEditorToolbarFormContent(string $panel, string $toolbarForm)
{
    string $oldParent = `setParent -q`;

	setParent $toolbarForm;

	int $iconSize = 26;

	if (getenv("MAYA_ENABLE_LEGACY_HYPERSHADE") == "1")
	{
		iconTextRadioCollection;
		iconTextRadioButton
			-image1 "hsShowTopTabsOnly.png"
			-width $iconSize
			-height $iconSize
			-annotation (uiRes("m_hyperShadePanel.kShowTopTabsIconAnnot"))
			-onCommand
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"showTopTabsOnly\")")
			showTopTabsOnlyButton;

		iconTextRadioButton
			-image1 "hsShowBottomTabsOnly.png"
			-width $iconSize
			-height $iconSize
			-annotation (uiRes("m_hyperShadePanel.kShowBottomTabsIconAnnot"))
			-onCommand
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"showBottomTabsOnly\")")
			showBottomTabsOnlyButton;

		iconTextRadioButton
			-image1 "hsShowTopAndBottomTabs.png"
			-width $iconSize
			-height $iconSize
			-annotation (uiRes("m_hyperShadePanel.kShowTopAndBottomTabsIconAnnot"))
			-onCommand
				("hyperShadePanelMenuCommand(\""
					+ $panel
					+ "\", \"showTopAndBottomTabs\")")
			showTopAndBottomTabsButton;
	}
	
	// Create the expand/collapse button separators
	iconTextButton -vis true -w 9 -h $iconSize
		-annotation (uiRes("m_hyperShadePanel.kShowHideNodeEditorRegraph")) 
		-i1 openBar.png
		-c ("hyperShadeToggleRegraphButtons(-1)")
		regraphCollapseButton;

	iconTextButton
		-image1 "hsUpStreamCon.png"
		-width $iconSize
		-height $iconSize
		-annotation (uiRes("m_hyperShadePanel.kInputConnectionsIconAnnot"))
		-command
			("hyperShadePanelGraphCommand(\""
				+ $panel
				+ "\", \"showUpstream\")")
		showUpstreamButton;

	iconTextButton
		-image1 "hsUpDownStreamCon.png"
		-width $iconSize
		-height $iconSize
		-annotation (uiRes("m_hyperShadePanel.kInputOutputConnectionsIconAnnot"))
		-command
			("hyperShadePanelGraphCommand(\""
				+ $panel
				+ "\", \"showUpAndDownstream\")")
		showUpAndDownstreamButton;

	iconTextButton
		-image1 "hsDownStreamCon.png"
		-width $iconSize
		-height $iconSize
		-annotation (uiRes("m_hyperShadePanel.kOutputConnectionsIconAnnot"))
		-command
			("hyperShadePanelGraphCommand(\""
				+ $panel
				+ "\", \"showDownstream\")")
		showDownstreamButton;

	// Expand/collapse button separators based upon option var
	if (`optionVar -exists "hypershadeShowRegraphButtons"`) {
		int $state = `optionVar -q "hypershadeShowRegraphButtons"`;
		hyperShadeToggleRegraphButtons($state);
	}

	// Create the expand/collapse button separators
	iconTextButton -vis true -w 9 -h $iconSize
		-annotation (uiRes("m_hyperShadePanel.kShowHideNodeEditorLayout")) 
		-i1 openBar.png
		-c ("hyperShadeToggleLayoutButtons(-1)")
		layoutCollapseButton;

	iconTextButton
		-image1 "hsClearView.png"
		-width $iconSize
		-height $iconSize
		-annotation (uiRes("m_hyperShadePanel.kClearGraphIconAnnot"))
		-command
			("hyperShadePanelGraphCommand(\""
				+ $panel
				+ "\", \"clearGraph\")")
		clearGraphButton;

	string $cmd = "HypershadeGraphAddSelected";
	iconTextButton
		-image1 "nodeGrapherAddNodes.png"
		-w $iconSize -h $iconSize
		-annotation (getRunTimeCommandAnnotation( $cmd ))
		-command $cmd
		addSelectedButton;
	
	$cmd = "HypershadeGraphRemoveSelected";
	iconTextButton
		-image1 "nodeGrapherRemoveNodes.png"
		-width $iconSize
		-height $iconSize
		-annotation (getRunTimeCommandAnnotation( $cmd ))
		-command $cmd
		removeSelectedButton;

	iconTextButton
		-image1 "hsRearrange.png"
		-width $iconSize
		-height $iconSize
		-annotation (uiRes("m_hyperShadePanel.kRearrangeGraphIconAnnot"))
		-command
			("hyperShadePanelGraphCommand(\""
				+ $panel
				+ "\", \"rearrangeGraph\")")
		rearrangeGraphButton;

	iconTextButton
		-image1 "hsGraphMaterial.png"
		-width $iconSize
		-height $iconSize
		-annotation (uiRes("m_hyperShadePanel.kGraphMaterialsOnSelectedObjectIconAnnot"))
		-command
			("hyperShadePanelGraphCommand(\""
				+ $panel
				+ "\", \"graphMaterials\")")
		graphMaterialsButton;

	// Expand/collapse button separators based upon option var
	if (`optionVar -exists "hypershadeShowLayoutButtons"`) {
		int $state = `optionVar -q "hypershadeShowLayoutButtons"`;
		hyperShadeToggleLayoutButtons($state);
	}

	// Create the expand/collapse button separators
	iconTextButton -vis true -w 9 -h $iconSize
		-annotation (uiRes("m_hyperShadePanel.kShowHideNodeEditorLod")) 
		-i1 openBar.png
		-c ("hyperShadeToggleLODButtons(-1)")
		LODCollapseButton;

	iconTextButton
		-i1 "nodeGrapherModeSimpleLarge.png"
		-w $iconSize -h $iconSize
		-annotation (getRunTimeCommandAnnotation( "NodeEditorHideAttributes" ))
		-command "nodeEditor -e -nodeViewMode \"simple\" \"hyperShadePrimaryNodeEditor\""
		LODSimpleModeButton;

	iconTextButton
		-i1 "nodeGrapherModeConnectedLarge.png" 
		-w $iconSize -h $iconSize
		-annotation (getRunTimeCommandAnnotation( "NodeEditorShowConnectedAttrs" ))
		-command "nodeEditor -e -nodeViewMode \"connected\" \"hyperShadePrimaryNodeEditor\""
	LODConnectedModeButton;

	iconTextButton
		-i1 "nodeGrapherModeAllLarge.png" 
		-w $iconSize -h $iconSize
		-annotation (getRunTimeCommandAnnotation( "NodeEditorShowAllAttrs" ))
		-command "nodeEditor -e -nodeViewMode \"all\" \"hyperShadePrimaryNodeEditor\""
		LODShowAllButton;

	iconTextButton
		-i1 "nodeGrapherModeCustomLarge.png" 
		-w $iconSize -h $iconSize
		-annotation (getRunTimeCommandAnnotation( "NodeEditorShowCustomAttrs" ))
		-command "nodeEditor -e -nodeViewMode \"custom\" \"hyperShadePrimaryNodeEditor\""
		LODShowCustomButton;

	iconTextButton
		-i1 "search.png" 
		-w $iconSize -h $iconSize
		-annotation (getRunTimeCommandAnnotation( "NodeEditorToggleAttrFilter" ))
		-command "nodeEditor -e -toggleAttrFilter \"hyperShadePrimaryNodeEditor\""
		-version 2016
		attrFilterToggleButton;

	iconTextButton
		-i1 "nodeGrapherSwatchToggle.png" 
		-w $iconSize -h $iconSize
		-annotation (getRunTimeCommandAnnotation( "NodeEditorToggleNodeSwatchSize" ))
		-command "nodeEditor -e -toggleSwatchSize \"\" \"hyperShadePrimaryNodeEditor\""
		-version 2016
		swatchSizeToggleButton;

	// Expand/collapse button separators based upon option var
	if (`optionVar -exists "hypershadeShowLODButtons"`) {
		int $state = `optionVar -q "hypershadeShowLODButtons"`;
		hyperShadeToggleLODButtons($state);
	}

	// Create the expand/collapse button separators
	iconTextButton -vis true -w 9 -h $iconSize
		-annotation (uiRes("m_hyperShadePanel.kShowHideNodeEditorGrid")) 
		-i1 openBar.png
		-c ("hyperShadeToggleGridButtons(-1)")
		gridCollapseButton;

	$cmd = "HypershadeGridToggleVisibility; optionVar -iv \"HypershadeGridVisibility\" `iconTextCheckBox -q -v gridToggleVisibilityButton`";
	iconTextCheckBox
		-i1 "gridDisplay.png" 
		-w $iconSize -h $iconSize
		-annotation (getRunTimeCommandAnnotation( $cmd ))
		-cc $cmd
		gridToggleVisibilityButton;
	if (`optionVar -exists "HypershadeGridVisibility"`) {
		iconTextCheckBox -e -v `optionVar -q "HypershadeGridVisibility"` gridToggleVisibilityButton;
	} else {
		optionVar -iv "HypershadeGridVisibility" `iconTextCheckBox -q -v gridToggleVisibilityButton`;
	}

	$cmd = "HypershadeGridToggleSnap; optionVar -iv \"HypershadeGridSnap\" `iconTextCheckBox -q -v gridToggleSnapButton`";
	iconTextCheckBox
		-i1 "snapGrid.png" 
		-w $iconSize -h $iconSize
		-annotation (getRunTimeCommandAnnotation( $cmd ))
		-cc $cmd
		gridToggleSnapButton;
	if (`optionVar -exists "HypershadeGridSnap"`) {
		iconTextCheckBox -e -v `optionVar -q "HypershadeGridSnap"` gridToggleSnapButton;
	} else {
		optionVar -iv "HypershadeGridSnap" `iconTextCheckBox -q -v gridToggleSnapButton`;
	}


	iconTextButton
		-i1 "restoreClosedTab.png" 
		-w $iconSize -h $iconSize
		-annotation (getRunTimeCommandAnnotation( "NodeEditorRestoreLastClosedTab" ))
		-command "nodeEditor -e -restoreLastClosedTab \"hyperShadePrimaryNodeEditor\"; iconTextButton -e -enable false tabsRLCTButton;"
		-enable false
		-version 2016
		tabsRLCTButton;

	// Expand/collapse button separators based upon option var
	if (`optionVar -exists "hypershadeShowGridButtons"`) {
		int $state = `optionVar -q "hypershadeShowGridButtons"`;
		hyperShadeToggleGridButtons($state);
	}

	//
	// Filter UI
	//

	// Create the expand/collapse button separators
	iconTextButton -vis true -w 9 -h $iconSize
		-annotation (uiRes("m_hyperShadePanel.kShowHideNodeEditorFilter")) 
		-i1 openBar.png
		-c ("hypershadeNEToggleFilterUI(-1)")
		hypershadeNEFilterCollapseButton;

	string $layout = ("hypershadeNEFilterUIForm");
    formLayout $layout;

    setParent $oldParent;

	// Expand/collapse button separators based upon option var
	if (`optionVar -exists "hypershadeNEShowFilter"`) {
		int $state = `optionVar -q "hypershadeNEShowFilter"`;
		hypershadeNEToggleFilterUI($state);
	}
}

global string $gPauseButtonPanel = "";

global proc refreshPauseButtonCmd(int $state)
{
	optionVar -intValue hypershadeSwatchPauseButtonState $state;

	global string $gPauseButtonPanel;
	if(`layout -ex $gPauseButtonPanel`)
	{
		string $oldParent = `setParent -q`;
		setParent $gPauseButtonPanel;

		setParent browserButtons;
		string $image = ($state == 0 ? "hyper_s_OFF.png" : "hyper_s_ON.png");
		iconTextButton -edit -image1 $image togglePauseBrowserButton;

		setParent $oldParent;
	}
}

global proc hyperShadeToggleLayoutButtons (int $arg)
//
// Show and Hide the layout buttons
// $arg = 1 means show, 0 means hide, -1 means use optionVar
//
{
	int $state = $arg;
	if ($state < 0) 
	{
	    if (!`optionVar -exists hypershadeShowLayoutButtons`)
	        $state = 0;
	    else
	        $state = (!`optionVar -q hypershadeShowLayoutButtons`);
    }

	iconTextButton -edit -manage $state clearGraphButton;
	iconTextButton -edit -manage $state addSelectedButton;
	iconTextButton -edit -manage $state removeSelectedButton;
	iconTextButton -edit -manage $state rearrangeGraphButton;
	iconTextButton -edit -manage $state graphMaterialsButton;

	if ($state) {	
		iconTextButton -edit -i1 openBar.png layoutCollapseButton;
	} else {
		iconTextButton -edit -i1 closeBar.png layoutCollapseButton;
	}
	optionVar -intValue "hypershadeShowLayoutButtons" $state;
}

global proc hyperShadeToggleRegraphButtons (int $arg)
//
// Show and Hide the re-graph buttons
// $arg = 1 means show, 0 means hide, -1 means use optionVar
//
{
	int $state = $arg;
	if ($state < 0) 
	{
	    if (!`optionVar -exists hypershadeShowRegraphButtons`)
	        $state = 0;
	    else
	        $state = (!`optionVar -q hypershadeShowRegraphButtons`);
    }

	iconTextButton -edit -manage $state showUpstreamButton;
	iconTextButton -edit -manage $state showUpAndDownstreamButton;
	iconTextButton -edit -manage $state showDownstreamButton;

	if ($state) {	
		iconTextButton -edit -i1 openBar.png regraphCollapseButton;
	} else {
		iconTextButton -edit -i1 closeBar.png regraphCollapseButton;
	}
	optionVar -intValue "hypershadeShowRegraphButtons" $state;
}

global proc hyperShadeToggleLODButtons (int $arg)
//
// Show and Hide the LOD buttons
// $arg = 1 means show, 0 means hide, -1 means use optionVar
//
{
	int $state = $arg;
	if ($state < 0) 
	{
	    if (!`optionVar -exists hypershadeShowLODButtons`)
	        $state = 0;
	    else
	        $state = (!`optionVar -q hypershadeShowLODButtons`);
    }

	iconTextButton -edit -manage $state LODSimpleModeButton;
	iconTextButton -edit -manage $state LODConnectedModeButton;
	iconTextButton -edit -manage $state LODShowAllButton;
	iconTextButton -edit -manage $state LODShowCustomButton;
	iconTextButton -edit -manage $state attrFilterToggleButton;
	iconTextButton -edit -manage $state swatchSizeToggleButton;

	if ($state) {	
		iconTextButton -edit -i1 openBar.png LODCollapseButton;
	} else {
		iconTextButton -edit -i1 closeBar.png LODCollapseButton;
	}
	optionVar -intValue "hypershadeShowLODButtons" $state;
}

global proc hyperShadeToggleGridButtons (int $arg)
//
// Show and Hide the grid buttons
// $arg = 1 means show, 0 means hide, -1 means use optionVar
//
{
	int $state = $arg;
	if ($state < 0) 
	{
	    if (!`optionVar -exists hypershadeShowGridButtons`)
	        $state = 0;
	    else
	        $state = (!`optionVar -q hypershadeShowGridButtons`);
    }

	iconTextCheckBox -edit -manage $state gridToggleVisibilityButton;
	iconTextCheckBox -edit -manage $state gridToggleSnapButton;
	iconTextButton -edit -manage $state tabsRLCTButton;

	if ($state) {	
		iconTextButton -edit -i1 openBar.png gridCollapseButton;
	} else {
		iconTextButton -edit -i1 closeBar.png gridCollapseButton;
	}
	optionVar -intValue "hypershadeShowGridButtons" $state;
}

global proc hypershadeNEToggleFilterUI (int $arg)
//
// Show and Hide the grid buttons
// $arg = 1 means show, 0 means hide, -1 means use optionVar
//
{
	int $state = $arg;
	if ($state < 0) 
	{
	    if (!`optionVar -exists hypershadeNEShowFilter`)
	        $state = 0;
	    else
	        $state = (!`optionVar -q hypershadeNEShowFilter`);
    }

	formLayout -edit -manage $state hypershadeNEFilterUIForm;

	if ($state) {	
		iconTextButton -edit -i1 openBar.png hypershadeNEFilterCollapseButton;
	} else {
		iconTextButton -edit -i1 closeBar.png hypershadeNEFilterCollapseButton;
	}
	optionVar -intValue "hypershadeNEShowFilter" $state;
}

global proc hyperShadeToggleSwatchPauseButton (int $arg)
//
// Show and Hide the swatch pause button
// $arg = 1 means show, 0 means hide, -1 means use optionVar
//
{
	int $state = $arg;
	if ($state < 0) 
	{
	    if (!`optionVar -exists hypershadeShowSwatchPauseButton`)
	        $state = 0;
	    else
	        $state = (!`optionVar -q hypershadeShowSwatchPauseButton`);
    }

	iconTextButton -edit -manage $state togglePauseBrowserButton;

	if ($state) {	
		iconTextButton -edit -i1 openBar.png pauseCollapseButton;
	} else {
		iconTextButton -edit -i1 closeBar.png pauseCollapseButton;
	}
	optionVar -intValue "hypershadeShowSwatchPauseButton" $state;
}
				
global proc hyperShadeToggleSwatchIcons (int $arg)
//
// Show and Hide the swatch display icons
// $arg = 1 means show, 0 means hide, -1 means use optionVar
//
{
	int $state = $arg;
	if ($state < 0) 
	{
	    if (!`optionVar -exists hypershadeShowSwatchIcons`)
	        $state = 0;
	    else
	        $state = (!`optionVar -q hypershadeShowSwatchIcons`);
    }

	iconTextRadioButton -edit -manage $state asIconsBrowserButton;
	iconTextRadioButton -edit -manage $state asListBrowserButton;

	if ($state) {	
		iconTextButton -edit -i1 openBar.png swatchCollapseButtons;
	} else {
		iconTextButton -edit -i1 closeBar.png swatchCollapseButtons;
	}
	optionVar -intValue "hypershadeShowSwatchIcons" $state;
}

global proc hyperShadeToggleSwatchSizeIcons (int $arg)
//
// Show and Hide the swatch size icons
// $arg = 1 means show, 0 means hide, -1 means use optionVar
//
{
	int $state = $arg;
	if ($state < 0) 
	{
	    if (!`optionVar -exists hypershadeShowSwatchSizeIcons`)
	        $state = 0;
	    else
	        $state = (!`optionVar -q hypershadeShowSwatchSizeIcons`);
    }

	iconTextRadioButton -edit -manage $state smallIconsBrowserButton;
	iconTextRadioButton -edit -manage $state mediumIconsBrowserButton;
	iconTextRadioButton -edit -manage $state largeIconsBrowserButton;
	iconTextRadioButton -edit -manage $state superIconsBrowserButton;

	if ($state) {	
		iconTextButton -edit -i1 openBar.png swatchSizeCollapseButtons;
	} else {
		iconTextButton -edit -i1 closeBar.png swatchSizeCollapseButtons;
	}
	optionVar -intValue "hypershadeShowSwatchSizeIcons" $state;
}

global proc hyperShadeToggleSwatchSortIcons (int $arg)
//
// Show and Hide the swatch sorting icons
// $arg = 1 means show, 0 means hide, -1 means use optionVar
//
{
	int $state = $arg;
	if ($state < 0) 
	{
	    if (!`optionVar -exists hypershadeShowSwatchSortIcons`)
	        $state = 0;
	    else
	        $state = (!`optionVar -q hypershadeShowSwatchSortIcons`);
    }

	iconTextRadioButton -edit -manage $state byNameBrowserButton;
	iconTextRadioButton -edit -manage $state byTypeBrowserButton;
	iconTextRadioButton -edit -manage $state byTimeBrowserButton;
	iconTextCheckBox -edit -manage $state reverseOrderBrowserButton;

	if ($state) {	
		iconTextButton -edit -i1 openBar.png swatchSortCollapseButtons;
	} else {
		iconTextButton -edit -i1 closeBar.png swatchSortCollapseButtons;
	}
	optionVar -intValue "hypershadeShowSwatchSortIcons" $state;
}

global proc hyperShadeToggleSceneTabFilter (int $arg)
//
// Show and Hide the scene tab filter
// $arg = 1 means show, 0 means hide, -1 means use optionVar
//
{
	int $state = $arg;
	if ($state < 0) 
	{
	    if (!`optionVar -exists hypershadeShowSceneTabFilter`)
	        $state = 0;
	    else
	        $state = (!`optionVar -q hypershadeShowSceneTabFilter`);
    }

	formLayout -edit -manage $state sceneTabFilterForm;

	if ($state) {	
		iconTextButton -edit -i1 openBar.png collapseSceneTabFilter;
	} else {
		iconTextButton -edit -i1 closeBar.png collapseSceneTabFilter;
	}
	optionVar -intValue "hypershadeShowSceneTabFilter" $state;
}

// Description:  This procedure is called to create the content for
//      the browserButtons.
//
proc createHypershadeBrowserToolbarFormContent(string $panel, string $browserButtons)
{
    string $oldParent = `setParent -q`;

            setParent $browserButtons;

			int $iconSize = 26;

	        // Create the expand/collapse button separators
	        iconTextButton -vis true -w 9 -h $iconSize
		        -annotation (uiRes("m_hyperShadePanel.kShowHideSwatchPauseButton")) 
		        -i1 openBar.png
		        -c ("hyperShadeToggleSwatchPauseButton(-1)")
		        pauseCollapseButton;

			// Create pause button
			iconTextButton
				-image1 "hyper_s_ON.png"
				-width $iconSize
				-height $iconSize
				-annotation (uiRes("m_hyperShadePanel.kSwtachRenderingPausedAnnot"))
				-command	("hyperShadePanelPauseButtonCommand(\"" + $panel + "\")")
				-version 2016
				togglePauseBrowserButton;
			
			// Save the panel name. Used to later sync button icon with state.
			global string $gPauseButtonPanel;
			$gPauseButtonPanel = $panel;

			// Get the saved state of the button
			int $state = `renderThumbnailUpdate -q`;

			// Update the button
			refreshPauseButtonCmd($state);

			// Expand/collapse button separators based upon option var
			if (`optionVar -exists "hypershadeShowSwatchPauseButton"`) {
				int $state = `optionVar -q "hypershadeShowSwatchPauseButton"`;
				hyperShadeToggleSwatchPauseButton($state);
			}

	        // Create the expand/collapse button separators
	        iconTextButton -vis true -w 9 -h $iconSize
		        -annotation (uiRes("m_hyperShadePanel.kShowHideSwatchIcons")) 
		        -i1 openBar.png
		        -c ("hyperShadeToggleSwatchIcons(-1)")
		        swatchCollapseButtons;
				
			// Buttons for View as Icons/List
			iconTextRadioCollection;
			iconTextRadioButton
				-image1 "viewIcon.png"
				-width $iconSize
				-height $iconSize
				-annotation (uiRes("m_hyperShadePanel.kViewAsIconsAnnot"))
				-onCommand
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"asIcons\")")
				asIconsBrowserButton;

			iconTextRadioButton
				-image1 "viewList.png"
				-width $iconSize
				-height $iconSize
				-annotation (uiRes("m_hyperShadePanel.kViewAsListAnnot"))
				-onCommand
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"asList\")")
				asListBrowserButton;

			// Expand/collapse button separators based upon option var
			if (`optionVar -exists "hypershadeShowSwatchIcons"`) {
				int $state = `optionVar -q "hypershadeShowSwatchIcons"`;
				hyperShadeToggleSwatchIcons($state);
			}

	        // Create the expand/collapse button separators
	        iconTextButton -vis true -w 9 -h $iconSize
		        -annotation (uiRes("m_hyperShadePanel.kShowHideSwatchSizeIcons")) 
		        -i1 openBar.png
		        -c ("hyperShadeToggleSwatchSizeIcons(-1)")
		        swatchSizeCollapseButtons;

			// Buttons for View as Small/Medium/Large Swatches
			iconTextRadioCollection;
			iconTextRadioButton
				-image1 "iconSmall.png"
				-width $iconSize
				-height $iconSize
				-annotation (uiRes("m_hyperShadePanel.kViewAsSmallSwatchesAnnot"))
				-onCommand
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"smallIcons\")")
				smallIconsBrowserButton;

			iconTextRadioButton
				-image1 "iconMedium.png"
				-width $iconSize
				-height $iconSize
				-annotation (uiRes("m_hyperShadePanel.kViewAsMediumSwatchesAnnot"))
				-onCommand
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"mediumIcons\")")
				mediumIconsBrowserButton;

			iconTextRadioButton
				-image1 "iconLarge.png"
				-width $iconSize
				-height $iconSize
				-annotation (uiRes("m_hyperShadePanel.kViewAsLargeSwatchesAnnot"))
				-onCommand
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"largeIcons\")")
				largeIconsBrowserButton;

			iconTextRadioButton
				-image1 "iconSuper.png"
				-width $iconSize
				-height $iconSize
				-annotation (uiRes("m_hyperShadePanel.kViewAsExtraLargeSwatchesAnnot"))
				-onCommand
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"superIcons\")")
				superIconsBrowserButton;

			// Expand/collapse button separators based upon option var
			if (`optionVar -exists "hypershadeShowSwatchSizeIcons"`) {
				int $state = `optionVar -q "hypershadeShowSwatchSizeIcons"`;
				hyperShadeToggleSwatchSizeIcons($state);
			}

	        // Create the expand/collapse button separators
	        iconTextButton -vis true -w 9 -h $iconSize
		        -annotation (uiRes("m_hyperShadePanel.kShowHideSwatchSortIcons")) 
		        -i1 openBar.png
		        -c ("hyperShadeToggleSwatchSortIcons(-1)")
		        swatchSortCollapseButtons;

			// Buttons for Sort by Name/Type/Time, and Reverse Order
			iconTextRadioCollection;
			iconTextRadioButton
				-image1 "sortName.png"
				-width $iconSize
				-height $iconSize
				-annotation (uiRes("m_hyperShadePanel.kSortByNameAnnot"))
				-onCommand
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"byName\")")
				byNameBrowserButton;

			iconTextRadioButton
				-image1 "sortType.png"
				-width $iconSize
				-height $iconSize
				-annotation (uiRes("m_hyperShadePanel.kSortByTypeAnnot"))
				-onCommand
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"byType\")")
				byTypeBrowserButton;

			iconTextRadioButton
				-image1 "sortTime.png"
				-width $iconSize
				-height $iconSize
				-annotation (uiRes("m_hyperShadePanel.kSortByTimeAnnot"))
				-onCommand
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"byTime\")")
				byTimeBrowserButton;

			iconTextCheckBox
				-image1 "reverseOrder.png"
				-width $iconSize
				-height $iconSize
				-annotation (uiRes("m_hyperShadePanel.kSortInReverseOrderAnnot"))
				-changeCommand
					("hyperShadePanelMenuCommand(\""
						+ $panel
						+ "\", \"reverseOrder\")")
				reverseOrderBrowserButton;

			// Expand/collapse button separators based upon option var
			if (`optionVar -exists "hypershadeShowSwatchSortIcons"`) {
				int $state = `optionVar -q "hypershadeShowSwatchSortIcons"`;
				hyperShadeToggleSwatchSortIcons($state);
			}

	        // Create the expand/collapse button separators
	        iconTextButton -vis true -w 9 -h $iconSize
		        -annotation (uiRes("m_hyperShadePanel.kShowHideSceneTabFilter")) 
		        -i1 openBar.png
		        -c ("hyperShadeToggleSceneTabFilter(-1)")
		        collapseSceneTabFilter;

			// Filter for the hyper shade tab.
            //   . If we have "Show Top and Bottom Tabs", then the
            //     filter is for the current active tab among the top tabs.
            //   . If we have "Show Top Tabs Only" or
            //     "Show Bottom Tabs Only", then the filter is for
            //     the currently active tab.
            //
            string $sceneTabFilterForm = `formLayout sceneTabFilterForm`;
            setParent ..;  // from sceneTabFilterForm

			// Expand/collapse button separators based upon option var
			if (`optionVar -exists "hypershadeShowSceneTabFilter"`) {
				int $state = `optionVar -q "hypershadeShowSceneTabFilter"`;
				hyperShadeToggleSceneTabFilter($state);
			}

    setParent $oldParent;
}


// Description:  This procedure is called to return the name of
//  the create bar form.
//
global proc string hyperShadeCreateBarForm(string $panel)
{	
    global string $gLookdevCreatePanel;
    if (`dockControl -exists $gLookdevCreatePanel`)
    {
        string $uiForm = `dockControl -q -content $gLookdevCreatePanel`; 
        return $uiForm;
    }
    return "";
}

// Description:  This procedure is called to return the name of
//  the bin UI form.
//
global proc string hyperShadeBinUIForm(string $panel)
{
	global string $gLookdevBinsPanel;
    if (`dockControl -exists $gLookdevBinsPanel`)
    {
        string $uiForm = `dockControl -q -content $gLookdevBinsPanel`; 
        return $uiForm;
    }
    return "";
}

global proc shaderballGeometryUpdate(int $sel)
{
	global string $gShaderBallEditor;
	if ($sel > 9) $sel = 9;
	if ($sel < 1) $sel = 1;

	switch ($sel)
	{
		case 1: // Shaderball
			if (size($gShaderBallEditor))
				modelEditor -e -acg "meshShaderball" $gShaderBallEditor;
			break;
		case 2: // Cloth
			if (size($gShaderBallEditor))
				modelEditor -e -acg "meshCloth" $gShaderBallEditor;
			break;
		case 3: // Teapot
			if (size($gShaderBallEditor))
				modelEditor -e -acg "meshTeapot" $gShaderBallEditor;
			break;
		case 4: // Ocean
			if (size($gShaderBallEditor))
				modelEditor -e -acg "meshOcean" $gShaderBallEditor;
			break;
		case 5: // Ocean Splash
			if (size($gShaderBallEditor))
				modelEditor -e -acg "meshOceanSplash" $gShaderBallEditor;
			break;
		case 6: // Glass Fill
			if (size($gShaderBallEditor))
				modelEditor -e -acg "meshGlassFill" $gShaderBallEditor;
			break;
		case 7: // Glass Splash
			if (size($gShaderBallEditor))
				modelEditor -e -acg "meshGlassSplash" $gShaderBallEditor;
			break;
		case 8: // Sphere
			if (size($gShaderBallEditor))
				modelEditor -e -acg "meshSphere" $gShaderBallEditor;
			break;
		case 9: // Plane
			if (size($gShaderBallEditor))
				modelEditor -e -acg "meshPlane" $gShaderBallEditor;
			break;
		default:
			break;
    }

    // save the selection so it is restored the next time.
    optionVar -iv hyperShadeShaderballGeometryType $sel;
}

global proc string shaderballGeometryMenuChanged(string $optionMenu)
{
	string $value = `optionMenu -query -value $optionMenu`;	
    int $sel = `optionMenu -query -sl $optionMenu`;

	shaderballGeometryUpdate($sel);

	return $value;
}

global proc string shaderballRendererMenuChanged(string $optionMenu)
{
	global string $gShaderBallEditor;
	global string $gHardwareMenu;

	string $value = `optionMenu -query -value $optionMenu`;

	if (size($gShaderBallEditor))
	{
		if ($value == $gHardwareMenu) {
			// Hardware = empty string = no override
			modelEditor -e -acr "" $gShaderBallEditor;		
		} else {
			modelEditor -e -acr $value $gShaderBallEditor;		
		}
	}

    // Save the selection so it is restored the next time
    optionVar -sv hyperShadeShaderballRendererName $value;

	return $value;
}

global proc shaderBallRendererMenuUpdate()
{
	global string $gShaderBallRendererMenu;
	global string $gHardwareMenu;
	
	if ($gShaderBallRendererMenu == "" || !`optionMenu -exists $gShaderBallRendererMenu`)
	{
		return;
	}

	// Clear the menu
	string $items[] = `optionMenu -q -itemListLong $gShaderBallRendererMenu`;
	for ($item in $items) {
		deleteUI $item;
	}

	// Add default Hardware renderer
	string $HWItem = $gHardwareMenu;
	menuItem -parent $gShaderBallRendererMenu -label $HWItem;

	string $renderers[] = {$gHardwareMenu};

	// Add plugin renderers
	string $pluginRenderers[] = `renderer -q -materialViewRendererList`;
	for ($renderer in $pluginRenderers) {
		menuItem -parent $gShaderBallRendererMenu -label $renderer;
		$renderers[size($renderers)] = $renderer;
	}

	// Set the current renderer selection
	string $currentRenderer = $gHardwareMenu;
	if (`optionVar -exists hyperShadeShaderballRendererName`)
	{
		string $oldRenderer = `optionVar -query hyperShadeShaderballRendererName`;
		if (stringArrayContains($oldRenderer, $renderers)) {
			$currentRenderer = $oldRenderer;
		}
	}
	optionMenu -edit -value $currentRenderer $gShaderBallRendererMenu;
	
	shaderballRendererMenuChanged($gShaderBallRendererMenu);
}


proc string[] tokenizeEnv(string $env) {
	string $tokens[];
	int $numTokens = `tokenize $env "|" $tokens`;
	string $name = $numTokens > 0 ? $tokens[0] : "";
	string $image = $numTokens > 1 ? $tokens[1] : "";
	return {$name, $image};
}

global proc string[] shaderballGetEnvironments()
{
	// Get IBL presets directory
	string $path = `getenv MAYA_LOCATION`;
	$path += "/presets/Assets/IBL/";

	// Add default environments
	string $environments[] = { "Off|" };
	int $i = 1;
	$environments[$i++] = "Interior1 Color|" + $path + "Interior1_Color.exr";
	$environments[$i++] = "Interior1 Neutral|" + $path + "Interior1_Neutral.exr";
	$environments[$i++] = "Interior2 Color|" + $path + "Interior2_Color.exr";
	$environments[$i++] = "Interior2 Neutral|" + $path + "Interior2_Neutral.exr";
	$environments[$i++] = "Exterior1 Color|" + $path + "Exterior1_Color.exr";
	$environments[$i++] = "Exterior1 Neutral|" + $path + "Exterior1_Neutral.exr";
	$environments[$i++] = "Exterior2 Color|" + $path + "Exterior2_Color.exr";
	$environments[$i++] = "Exterior2 Neutral|" + $path + "Exterior2_Neutral.exr";

	// Add custom environments saved in option var
	if (`optionVar -exists hyperShadeShaderballCustomEnvironments`) {
		string $customEnvironments[] = `optionVar -q hyperShadeShaderballCustomEnvironments`;
		$environments = stringArrayCatenate($environments, $customEnvironments);
	}

	return $environments;
}

global proc shaderballEnvironmentSetFileCB(string $scrollList, string $imageField)
{
    string $singleFilter = "All Files (*.*)";
    string $result[] = `fileDialog2 -fileFilter $singleFilter -dialogStyle 2 -fileMode 1 -okCaption "Ok"`;

    if(size($result) > 0) {
		textFieldButtonGrp -edit -text $result[0] $imageField;
		shaderballEnvironmentSaveCB($scrollList, $imageField);
    }
}

global proc shaderballEnvironmentSaveCB(string $scrollList, string $imageField)
{
	global string $gLookdevCustomEnvironments[];

	int $selectedIndex[] = `textScrollList -query -selectIndexedItem $scrollList`;
	if (size($selectedIndex) == 0) {
		return;
	}

	string $selected[] = `textScrollList -query -selectItem $scrollList`;
    string $newName  = $selected[0];
	string $newImage = `textFieldButtonGrp -q -text $imageField`;

	int $index = $selectedIndex[0] - 1;
	$gLookdevCustomEnvironments[$index] = $newName + "|" + $newImage;

	// Update editor
	shaderballEnvironmentUpdateEditor($scrollList, $imageField);

	// Select the saved item
	textScrollList -edit -selectItem $newName $scrollList;
}

global proc shaderballEnvironmentNewCB(string $scrollList, string $imageField)
{
	global string $gLookdevCustomEnvironments[];

	string $title = (uiRes("m_hyperShadePanel.kAddEnvTitle"));
	string $msg = (uiRes("m_hyperShadePanel.kAddEnvMsg"));
	string $ok = (uiRes("m_hyperShadePanel.kAddEnvOK"));
	string $cancel = (uiRes("m_hyperShadePanel.kAddEnvCancel"));

	string $name = "";
	string $result = `promptDialog -title $title -message $msg -button $ok -button $cancel -defaultButton $ok -cancelButton $cancel -dismissString $cancel`;
	if ($result == $ok)
	{
	    $name = `promptDialog -query -text`;

		// Check if this already exists
		for ($env in $gLookdevCustomEnvironments) {
			string $tokens[] = tokenizeEnv($env);
			if ($tokens[0] == $name) {
				string $msg = (uiRes("m_hyperShadePanel.kAddEnvExists"));
				error($msg);
			}
		}
	}
	
	if ($name != "")
	{
		// Append new item to list
		$gLookdevCustomEnvironments[size($gLookdevCustomEnvironments)] = $name + "|";

		// Update the list
		shaderballEnvironmentUpdateEditor($scrollList, $imageField);

		// Select the new item (its last on the list)
		int $numItems = `textScrollList -query -numberOfItems $scrollList`;
		textScrollList -edit -selectIndexedItem $numItems $scrollList;
		shaderballEnvironmentSelectCB($scrollList, $imageField);
	}
}

global proc shaderballEnvironmentDeleteCB(string $scrollList, string $imageField)
{
	global string $gLookdevCustomEnvironments[];

	int $selectedIndex[] = `textScrollList -query -selectIndexedItem $scrollList`;
	if (size($selectedIndex))
	{
		// Delete item
		int $index = $selectedIndex[0] - 1;
		stringArrayRemoveAtIndex($index, $gLookdevCustomEnvironments);

		// Clear image field and dim out
		textFieldButtonGrp -edit -enable false -text "" $imageField;

		// Update editor
		shaderballEnvironmentUpdateEditor($scrollList, $imageField);
	}
}

global proc shaderballEnvironmentSelectCB(string $scrollList, string $imageField)
{
	global string $gLookdevCustomEnvironments[];

	// Clear field
	textFieldButtonGrp -edit -text "" $imageField;

	string $selected[] = `textScrollList -query -selectItem $scrollList`;
	if (size($selected) == 0) {
		textFieldButtonGrp -edit -enable false $imageField;
		return;
	}
	
	// Fill field with data from selected environments
	for ($env in $gLookdevCustomEnvironments) {
		string $tokens[] = tokenizeEnv($env);
		if ($tokens[0] == $selected[0]) {
			textFieldButtonGrp -edit -enable true -text $tokens[1] $imageField;
			break;
		}
	}
}

global proc shaderballEnvironmentSaveCloseCB(string $optionMenu)
{
	global string $gHypershadeEnvironmentEditor;
	global string $gLookdevCustomEnvironments[];

	// Save the environment to option var
	optionVar -clearArray hyperShadeShaderballCustomEnvironments;
	for ($env in $gLookdevCustomEnvironments)
	{
		string $tokens[] = tokenizeEnv($env);
		string $name  = $tokens[0];
		string $image = $tokens[1];
		if ($name != "" && $image != "") {
			optionVar -stringValueAppend hyperShadeShaderballCustomEnvironments $env;
		}
	}

	// Update the menu
	shaderBallEnvironmentMenuUpdate($optionMenu);

	clear($gLookdevCustomEnvironments);

	// Hide the editor
	window -edit -visible false $gHypershadeEnvironmentEditor;
}

global proc shaderballEnvironmentCancelCB()
{
	global string $gHypershadeEnvironmentEditor;
	global string $gLookdevCustomEnvironments[];

	clear($gLookdevCustomEnvironments);

	// Hide the editor
	window -edit -visible false $gHypershadeEnvironmentEditor;
}

global proc shaderballEnvironmentUpdateEditor(string $scrollList, string $imageField)
{
	global string $gLookdevCustomEnvironments[];

	string $selected[] = `textScrollList -query -selectItem $scrollList`;
	textScrollList -edit -removeAll $scrollList;

	string $environmentNames[];
	for ($env in $gLookdevCustomEnvironments) {
		string $tokens[] = tokenizeEnv($env);
		string $name = $tokens[0];
		$environmentNames[size($environmentNames)] = $name;
		textScrollList -edit -append $name $scrollList;
	}

	// Restore the previous selection
	int $found = 0;
	if (size($selected)) {
		if (stringArrayContains($selected[0], $environmentNames)) {
			textScrollList -edit -selectItem $selected[0] $scrollList;
			textFieldButtonGrp -edit -enable true $imageField;
			$found = 1;
		}
	}
	if (!$found) {
		textFieldButtonGrp -edit -enable false -text "" $imageField;
	}
}

global proc shaderballEnvironmentShowEditor(string $optionMenu)
{
	global string $gHypershadeEnvironmentEditor;
	global string $gLookdevCustomEnvironments[];

	// Get the current state of custom environments
	if (`optionVar -exists hyperShadeShaderballCustomEnvironments`) {
		$gLookdevCustomEnvironments = `optionVar -q hyperShadeShaderballCustomEnvironments`;
	} else {
		clear($gLookdevCustomEnvironments);
	}

	// If the UI exists already just update and show it
	if ($gHypershadeEnvironmentEditor != "")
	{
		string $scrollList = $gHypershadeEnvironmentEditor + "|parentLayout|leftLayout|scrollList";
		string $imageField = $gHypershadeEnvironmentEditor + "|parentLayout|rightLayout|imageField";

		shaderballEnvironmentUpdateEditor($scrollList, $imageField);

		showWindow $gHypershadeEnvironmentEditor;

		return;
	}

	string $wnd = `window -retain -width 190 -title (uiRes("m_hyperShadePanel.kCustomEnvWindowTitle"))`;

	string $imageLabel = (uiRes("m_hyperShadePanel.kCustomEnvImageLabel"));
	string $browseLabel = "...";
	string $addLabel = (uiRes("m_hyperShadePanel.kCustomEnvAddLabel"));
	string $delLabel = (uiRes("m_hyperShadePanel.kCustomEnvDelLabel"));
	string $saveCloseLabel = (uiRes("m_hyperShadePanel.kCustomEnvSaveClose"));
	string $cancelLabel = (uiRes("m_hyperShadePanel.kCustomEnvCancel"));

	string $parentLayout = `formLayout -numberOfDivisions 100 parentLayout`;

		string $leftLayout = `formLayout -numberOfDivisions 100 leftLayout`;

			string $scrollList = `textScrollList -numberOfRows 8 -allowMultiSelection false scrollList`;
			string $addBtn = `button -label $addLabel -command ("shaderballAddCustomEnvironment " + $scrollList)`;
			string $delBtn = `button -label $delLabel -command ("shaderballDeleteCustomEnvironment " + $scrollList)`;

		setParent ..;

		string $verticalSep = `separator -horizontal false -style "double"`;

		string $rightLayout = `formLayout -numberOfDivisions 100 rightLayout`;

			string $imageField = `textFieldButtonGrp -label $imageLabel -text "" -buttonLabel $browseLabel imageField`;

		setParent ..;

		string $horizontalSep = `separator -horizontal true`;
		string $saveCloseBtn = `button -label $saveCloseLabel -command ("shaderballEnvironmentSaveCloseCB(\"" + $optionMenu + "\")")`;
		string $cancelBtn = `button -label $cancelLabel -command ("shaderballEnvironmentCancelCB")`;

	setParent ..;

	// Set control commands
	textScrollList -edit -selectCommand ("shaderballEnvironmentSelectCB(\"" + $scrollList + "\",\"" + $imageField + "\")") $scrollList;
	button -edit -command ("shaderballEnvironmentNewCB(\"" + $scrollList + "\",\"" + $imageField + "\")") $addBtn;
	button -edit -command ("shaderballEnvironmentDeleteCB(\"" + $scrollList + "\",\"" + $imageField + "\")") $delBtn;

	textFieldButtonGrp -edit -changeCommand ("shaderballEnvironmentSaveCB(\"" + $scrollList + "\",\"" + $imageField + "\")") $imageField;
	textFieldButtonGrp -edit -buttonCommand ("shaderballEnvironmentSetFileCB(\"" + $scrollList + "\",\"" + $imageField + "\")") $imageField;

	formLayout -edit
		-attachForm $scrollList "top" 5
		-attachForm $scrollList "left" 5
		-attachForm $scrollList "right" 5

		-attachControl $scrollList "bottom" 5 $addBtn
		-attachForm $addBtn "left" 5
		-attachPosition $addBtn "right" 5 50
		-attachForm $addBtn "bottom" 5

		-attachControl $scrollList "bottom" 5 $delBtn
		-attachForm $delBtn "right" 5
		-attachPosition $delBtn "left" 5 50
		-attachForm $delBtn "bottom" 5

		$leftLayout;

	formLayout -edit
		-attachForm $imageField "top" 5
		-attachForm $imageField "left" 5
		-attachForm $imageField "right" 5

		$rightLayout;

	formLayout -edit
		-attachForm $leftLayout "top" 5
		-attachForm $leftLayout "left" 5
		-attachPosition $leftLayout "right" 5 30
		-attachControl $leftLayout "bottom" 5 $horizontalSep

		-attachForm $verticalSep "top" 5
		-attachControl $verticalSep "left" 5 $leftLayout
		-attachControl $verticalSep "bottom" 5 $horizontalSep

		-attachForm $rightLayout "top" 5
		-attachForm $rightLayout "right" 5
		-attachControl $rightLayout "left" 5 $verticalSep
		-attachControl $rightLayout "bottom" 5 $horizontalSep

		-attachForm $horizontalSep "left" 5
		-attachForm $horizontalSep "right" 5
		-attachControl $horizontalSep "bottom" 5 $saveCloseBtn

		-attachForm $saveCloseBtn "left" 5
		-attachForm $saveCloseBtn "bottom" 5
		-attachPosition $saveCloseBtn "right" 5 50

		-attachControl $cancelBtn "left" 5 $saveCloseBtn
		-attachForm $cancelBtn "right" 5
		-attachForm $cancelBtn "bottom" 5

		$parentLayout;

	shaderballEnvironmentUpdateEditor($scrollList, $imageField);

	showWindow $wnd;

	// Save UI item names
	$gHypershadeEnvironmentEditor = $wnd;
}

global proc shaderballEnvironmentMenuChanged(string $optionMenu)
{
	global string $gShaderBallEditor;
	if (size($gShaderBallEditor) == 0) {
		return;
	}

	int $sel = `optionMenu -query -select $optionMenu`;
	int $num = `optionMenu -query -numberOfItems $optionMenu`;

	if ($sel == $num) {

		string $prevEnvironment = `optionVar -query hyperShadeShaderballEnvironmentName`;
		optionMenu -edit -value $prevEnvironment $optionMenu;

		shaderballEnvironmentShowEditor($optionMenu);

	} else {

		string $environments[] = shaderballGetEnvironments();
		string $name = `optionMenu -query -value $optionMenu`;

		string $file = "";
		for ($env in $environments) {
			string $tokens[] = tokenizeEnv($env);
			if ($tokens[0] == $name) {
				$file = $tokens[1];
				break;
			}
		}

		modelEditor -e -ace $file $gShaderBallEditor;

		// Save the selection so it is restored the next time
		optionVar -sv hyperShadeShaderballEnvironmentName $name;
	}
}

global proc shaderBallEnvironmentMenuUpdate(string $optionMenu)
{
	if (!`optionMenu -exists $optionMenu`) {
		return;
	}

	// Clear the menu
	string $items[] = `optionMenu -q -itemListLong $optionMenu`;
	for ($item in $items) {
		deleteUI $item;
	}

	string $environmentNames[];
	string $environments[] = shaderballGetEnvironments();

	for ($env in $environments) {
		string $tokens[] = tokenizeEnv($env);
		menuItem -parent $optionMenu -label $tokens[0];
		$environmentNames[size($environmentNames)] = $tokens[0];
	}

	menuItem -parent $optionMenu -label (uiRes("m_hyperShadePanel.kEnvAddNewItem"));

	// Set the current environment selection
	if (`optionVar -exists hyperShadeShaderballEnvironmentName`)
	{
		string $oldEnvironment = `optionVar -query hyperShadeShaderballEnvironmentName`;
		if (stringArrayContains($oldEnvironment, $environmentNames)) {
			optionMenu -edit -value $oldEnvironment $optionMenu;
		}
	}
	
	shaderballEnvironmentMenuChanged($optionMenu);
}

global proc hyperShadeToggleMaterialViewerOptions(int $arg, string $shaderBallRendererMenu, string $geomMenu, string $envMenu)
//
// Show and Hide the material viewer options
// $arg = 1 means show, 0 means hide, -1 means use optionVar
//
{
	int $state = $arg;
	if ($state < 0) 
	{
		if (!`optionVar -exists hypershadeShowMaterialViewerOptions`)
			$state = 0;
		else
			$state = (!`optionVar -q hypershadeShowMaterialViewerOptions`);
	}

	optionMenu -edit -manage $state $shaderBallRendererMenu;
	optionMenu -edit -manage $state $geomMenu;
	optionMenu -edit -manage $state $envMenu;

	if ($state) {	
		iconTextButton -edit -i1 openBar.png MaterialViewerOptionsCollapseButton;
	} else {
		iconTextButton -edit -i1 closeBar.png MaterialViewerOptionsCollapseButton;
	}
	optionVar -intValue "hypershadeShowMaterialViewerOptions" $state;
}

global proc hyperShadeToggleCM(int $arg, string $formLayout1, string $formLayout2, string $formLayout3)
//
// Show and Hide the CM options
// $arg = 1 means show, 0 means hide, -1 means use optionVar
//
{
	int $state = $arg;
	if ($state < 0) 
	{
		if (!`optionVar -exists hypershadeShowCM`)
			$state = 0;
		else
			$state = (!`optionVar -q hypershadeShowCM`);
	}

	formLayout -edit -manage $state $formLayout1;
	formLayout -edit -manage $state $formLayout2;
	formLayout -edit -manage $state $formLayout3;

	if ($state) {	
		iconTextButton -edit -i1 openBar.png CMCollapseButton;
	} else {
		iconTextButton -edit -i1 closeBar.png CMCollapseButton;
	}
	optionVar -intValue "hypershadeShowCM" $state;
}

global proc hypershadeUpdateColorManagement()
{
	global string $gShaderBallEditor;
	if (!`modelEditor -exists $gShaderBallEditor`) {
		return;
	}

    string $rendererDevice = `modelEditor -q -rendererDeviceName $gShaderBallEditor`;
    int $isVisible = ($rendererDevice == "VirtualDeviceGL") || ($rendererDevice == "VirtualDeviceDx11");
    
    iconTextButton -e -visible $isVisible ($gShaderBallEditor + "modelEditorExposureIcon");
    floatField     -e -visible $isVisible ($gShaderBallEditor + "modelEditorExposureField");
    iconTextButton -e -visible $isVisible ($gShaderBallEditor + "modelEditorGammaIcon");
    floatField     -e -visible $isVisible ($gShaderBallEditor + "modelEditorGammaField");
    symbolCheckBox -e -visible $isVisible ($gShaderBallEditor + "modelEditorEnableButton");
    optionMenu     -e -visible $isVisible ($gShaderBallEditor + "modelEditorTransformSelOptionMenu");

    // Synchronize the state of the controls with the modelEditor state.

	float $exposure = `modelEditor -q -exposure $gShaderBallEditor`;
	float $gamma    = `modelEditor -q -gamma $gShaderBallEditor`;
    floatField -e -value $exposure ($gShaderBallEditor + "modelEditorExposureField");
    floatField -e -value $gamma    ($gShaderBallEditor + "modelEditorGammaField");

    int $cmEnabled = `modelEditor -query -cmEnabled $gShaderBallEditor`;
    symbolCheckBox -e -value $cmEnabled ($gShaderBallEditor + "modelEditorEnableButton");

    // Re-build view transform menu, in case it changed.
    setParent -menu ($gShaderBallEditor + "modelEditorTransformSelOptionMenu");

    string $existingMenuItems[] = `optionMenu -q -itemListLong ($gShaderBallEditor + "modelEditorTransformSelOptionMenu")`;
    string $menuItem;
    for ($menuItem in $existingMenuItems) {
      deleteUI -menuItem $menuItem;
    }

    string $viewTransformNames[] = `colorManagementPrefs -q -viewTransformNames`;
    string $viewTransformName;
    for ($viewTransformName in $viewTransformNames) {
      menuItem -label $viewTransformName;
    }

    string $vtn = `modelEditor -query -viewTransformName $gShaderBallEditor`;
    optionMenu -e -v $vtn ($gShaderBallEditor + "modelEditorTransformSelOptionMenu");

    int $globalCmEnabled = `colorManagementPrefs -q -cmEnabled`;
    symbolCheckBox -e -enable $globalCmEnabled ($gShaderBallEditor + "modelEditorEnableButton");
    optionMenu   -e -enable $globalCmEnabled ($gShaderBallEditor + "modelEditorTransformSelOptionMenu");
}

//
// Set up a panel for shader ball preview.
//
proc string createShaderBallPanel()
{
	global string $gShaderBallEditor;
	global string $gShaderBallRendererMenu;

	string $modelEditorForm  = `formLayout`;

	// Shader ball editor
	$gShaderBallEditor = `modelEditor -parent $modelEditorForm`;
	
    // Turning on the filter will cause an camera to be internally created to 
	// supersede any default camera associated with
	// this editor. As well a number of display options and object filters
	// are enabled.
	//
	modelEditor -e -srf "shaderBallSceneFilter" $gShaderBallEditor;

    // now add the toolbar with the geometry type and renderer option menus
    string $modelEdMenu = `menuBarLayout -width 1`;    

        string $shaderBallFlowLayout = `flowLayout shaderBallFlowLayout`;

			// Create the expand/collapse button separators
			iconTextButton -vis true -w 9 -h 26
				-annotation (uiRes("m_hyperShadePanel.kShowHideMaterialViewerOptions")) 
				-i1 openBar.png
				MaterialViewerOptionsCollapseButton;

			// Renderer menu
			//////////////////////////
            $gShaderBallRendererMenu = `optionMenu -l "" rendererMenu`;
            optionMenu -edit 
		                -changeCommand ("shaderballRendererMenuChanged " + $gShaderBallRendererMenu)
		                $gShaderBallRendererMenu;
            
			shaderBallRendererMenuUpdate();

			// Geometry menu
			//////////////////////////
            text -l " " spacer2;
            string $geomMenu = `optionMenu -l "" geometryMenu`;
            optionMenu -edit 
		                -changeCommand ("shaderballGeometryMenuChanged " + $geomMenu)
		                $geomMenu;

            string $shaderballItem = (uiRes("m_hyperShadePanel.kShaderballGeometry"));
            string $clothItem = (uiRes("m_hyperShadePanel.kClothGeometry"));
            string $teapotItem = (uiRes("m_hyperShadePanel.kTeapotGeometry"));
            string $oceanItem = (uiRes("m_hyperShadePanel.kOceanGeometry"));
            string $oceanSplashItem = (uiRes("m_hyperShadePanel.kOceanSplashGeometry"));
            string $glassFillItem = (uiRes("m_hyperShadePanel.kGlassFillGeometry"));
            string $glassSplashItem = (uiRes("m_hyperShadePanel.kGlassSplashGeometry"));
            string $sphereItem = (uiRes("m_hyperShadePanel.kSphereGeometry"));
            string $planeItem =  (uiRes("m_hyperShadePanel.kPlaneGeometry"));

            menuItem -parent $geomMenu -label $shaderballItem;
            menuItem -parent $geomMenu -label $clothItem;
            menuItem -parent $geomMenu -label $teapotItem;
            menuItem -parent $geomMenu -label $oceanItem;
            menuItem -parent $geomMenu -label $oceanSplashItem;
            menuItem -parent $geomMenu -label $glassFillItem;
            menuItem -parent $geomMenu -label $glassSplashItem;
            menuItem -parent $geomMenu -label $sphereItem;
            menuItem -parent $geomMenu -label $planeItem;

			// Environment menu
			//////////////////////////
			text -l " " spacer3;
            string $envMenu = `optionMenu -l "" environmentMenu`;
            optionMenu -edit 
		                -changeCommand ("shaderballEnvironmentMenuChanged " + $envMenu)
		                $envMenu;
            
			shaderBallEnvironmentMenuUpdate($envMenu);

			// Expand/collapse button separators based upon option var
			if (`optionVar -exists "hypershadeShowMaterialViewerOptions"`) {
				int $state = `optionVar -q "hypershadeShowMaterialViewerOptions"`;
				hyperShadeToggleMaterialViewerOptions($state, $gShaderBallRendererMenu, $geomMenu, $envMenu);
			}
			iconTextButton -e
				-c ("hyperShadeToggleMaterialViewerOptions(-1, \"" + $gShaderBallRendererMenu + "\", \"" + $geomMenu + "\", \"" + $envMenu + "\");")
				MaterialViewerOptionsCollapseButton;

			// ADSK_CLR_MGT_BEGIN
			// Create the expand/collapse button separators
			iconTextButton -vis true -w 9 -h 26
				-annotation (uiRes("m_hyperShadePanel.kShowHideCM")) 
				-i1 openBar.png
				CMCollapseButton;

			string $layouts[] = createColorManagementSection($gShaderBallEditor, "", $gShaderBallEditor);

			// Expand/collapse button separators based upon option var
			if (`optionVar -exists "hypershadeShowCM"`) {
				int $state = `optionVar -q "hypershadeShowCM"`;
				hyperShadeToggleCM($state, $layouts[0], $layouts[1], $layouts[2]);
			}
			iconTextButton -e
				-c ("hyperShadeToggleCM(-1, \"" + $layouts[0] + "\", \"" + $layouts[1] + "\", \"" + $layouts[2] + "\");")
				CMCollapseButton;

			scriptJob -parent $gShaderBallEditor -event "colorMgtEnabledChanged" hypershadeUpdateColorManagement;
			scriptJob -parent $gShaderBallEditor -event "colorMgtPrefsReloaded" hypershadeUpdateColorManagement;
			scriptJob -parent $gShaderBallEditor -event "colorMgtConfigChanged" hypershadeUpdateColorManagement;
			scriptJob -parent $gShaderBallEditor -event "colorMgtPrefsViewTransformChanged" hypershadeUpdateColorManagement;
			// ADSK_CLR_MGT_END

			// set the current geometry type to display in the shaderball            
            int $currentGeometry = 1; // shader ball
            if (`optionVar -exists hyperShadeShaderballGeometryType`) {
                $currentGeometry = `optionVar -query hyperShadeShaderballGeometryType`;
                if ($currentGeometry < 1 || $currentGeometry > `optionMenu -q -numberOfItems $geomMenu`) {
                	$currentGeometry = 1; // shader ball
                }
            }
            optionMenu -edit -sl $currentGeometry $geomMenu;
			shaderballGeometryUpdate( $currentGeometry );
            
            setParent ..;
	
			formLayout -edit

		    -attachForm    $modelEdMenu         "left" 0
		    -attachForm    $modelEdMenu         "top" 0
    	    -attachForm    $modelEdMenu         "right" 0
    	     	    
            -attachControl $gShaderBallEditor	"top" 0 $modelEdMenu
            -attachForm    $gShaderBallEditor	"left" 0
            -attachForm    $gShaderBallEditor	"right" 0
            -attachForm    $gShaderBallEditor	"bottom" 0

		    $modelEditorForm;

    return $modelEditorForm;
}

proc string getConnectedNode(string $attr) {
	string $source = `connectionInfo -sourceFromDestination $attr`;
	if (size($source) > 0) {
		string $tokens[];
		tokenize($source, ".", $tokens);
		return $tokens[0];
	}
	return "";
}

proc string[] getChildrenOfClass(string $node, string $class, string $visitedNodes[])
{
    if (!`objExists $node`) {
        return {};
    }

	string $nodeType = `nodeType $node`;  
    if (`getClassification -satisfies $class $nodeType`) {
        return {$node};
    }
    
    string $result[];
	if ($nodeType == "transform") {
		string $children[] = `listRelatives -fullPath -children -noIntermediate $node`;
		for ($child in $children)
		{
		    if (!`stringArrayContains $child $visitedNodes`) {
				$visitedNodes[size($visitedNodes)] = $child;		
    		    string $nodes[] = stringArrayRemoveDuplicates( getChildrenOfClass($child, $class, $visitedNodes) );
    			appendStringArray($result, $nodes, size($nodes));
    		}
		}
	}
	
	return $result;
};

global proc string[] getLookdevNodes(string $node) {
	string $result[];
	string $nodeType = `nodeType $node`;
	if ($nodeType == "transform")
	{
		// For transform nodes, we want to return light and camera shapes
		// as well as materials if the shape is a geometry

		// Find any light source shapes
		string $lights[] = getChildrenOfClass($node, "light", {});
		if (size($lights)) {
			appendStringArray($result, $lights, size($lights));
		}
		// Find any camera shapes
		string $cameras[] = getChildrenOfClass($node, "camera", {});
		if (size($cameras)) {
			appendStringArray($result, $cameras, size($cameras));
		}
		// Find any mesh or nurbs geometry
		// In this case we want the shader of the geometry
		string $geometry[] = getChildrenOfClass($node, "drawdb/geometry/mesh", {});
		string $tmp[] = getChildrenOfClass($node, "drawdb/geometry/nurbsSurface", {});
		appendStringArray($geometry, $tmp, size($tmp));
		for ($g in $geometry) {
			string $shadingGroups[] = `listSets -type 1 -extendToShape -object $g`;
			string $nodes[];
			for ($s in $shadingGroups) {
				$nodes = getLookdevNodes($s);
				appendStringArray($result, $nodes, size($nodes));
			}
		}
	}
	else if ($nodeType == "mesh" || $nodeType == "nurbsSurface")
	{
		// For geometry shapes we want the shape itself, and also if it 
		// has more then one material we need to return them, so user can 
		// select which one to render
		//
		$result[0] = $node;
		string $shadingGroups[] = `listSets -type 1 -extendToShape -object $node`;
		if (size($shadingGroups) > 1) {
			string $nodes[];
			for ($s in $shadingGroups) {
				$nodes = getLookdevNodes($s);
				appendStringArray($result, $nodes, size($nodes));
			}
		}
	}
	else if ($nodeType == "shadingEngine")
	{
		// For shading engines we want the connected shaders
		//
		string $connected = getConnectedNode($node + ".surfaceShader");
		if (size($connected) > 0) {
			$result[0] = $connected;
		}
		if (attributeExists ("miMaterialShader", $node))
        {
            $connected = getConnectedNode($node + ".miMaterialShader");
		    if (size($connected) > 0) {
			    $result[size($result)] = $connected;
		    }
        }
		$connected = getConnectedNode($node + ".volumeShader");
		if (size($connected) > 0) {
			$result[size($result)] = $connected;
		}
		$connected = getConnectedNode($node + ".displacementShader");
		if (size($connected) > 0) {
			$result[size($result)] = $connected;
		}
	}
	else
	{
		// For all other node types we return the node itself
		//
		$result[0] = $node;
	}

	return $result;
}

// Callback returning all nodes on selection that is relevant for lookdev
//
global proc string[] hyperShadePropertyPanelSelectionCallback() {
	global string $gLookdevSelectionArray[];
    return $gLookdevSelectionArray;
};

proc string getShadingEngineForNode(string $node, string $visitedNodes[]) {
	if (`objExists $node`) {
		string $nodeType = `nodeType $node`;
		if ($nodeType == "shadingEngine") {
			return $node;
		} else {
			string $nodes[] = stringArrayRemoveDuplicates(`listConnections -destination true -source false -skipConversionNodes true $node`);
			for ($n in $nodes) {
				// Make sure to avoid loops in the graph
				if (!`stringArrayContains $n $visitedNodes`) {
					$visitedNodes[`size $visitedNodes`] = $n;
					string $n2 = getShadingEngineForNode($n, $visitedNodes);
					if (size($n2) > 0) {
						if ($n2 != "initialParticleSE" &&
							$n2 != "defaultShaderList1" &&
							$n2 != "initialMaterialInfo" &&
							$n2 != "lookdevSelection")
						{
							return $n2;
						}
					}
				}
			}
		}
	}
	return "";
}

proc string getSurfaceShaderForNode(string $node, string $visibleNodes[], string $visitedNodes[]) {

	if (`objExists $node`) {
		string $nodeType = `nodeType $node`;
		if (`getClassification -satisfies "shader/surface" $nodeType`) {
	 	    return $node;
		} else if ($nodeType == "shadingEngine") {
			// Check for default surface shader connection
			string $src = getConnectedNode($node + ".surfaceShader");
			if (size($src)) {
	            $visitedNodes[`size $visitedNodes`] = $src;
				return getSurfaceShaderForNode($src, $visibleNodes, $visitedNodes);
			} 
			// Check for mental ray surface shader connection
			else if (attributeExists ("miMaterialShader", $node)) {
				string $src = getConnectedNode($node + ".miMaterialShader");
				if (size($src)) {
		            $visitedNodes[`size $visitedNodes`] = $src;
					return getSurfaceShaderForNode($src, $visibleNodes, $visitedNodes);
				}
			}
	    } else {
	 	    string $nodes[] = stringArrayRemoveDuplicates(`listConnections -destination true -source false -skipConversionNodes true $node`);
	 	    for ($n in $nodes) {
                if (`stringArrayContains $n $visibleNodes`) 
                {
    		        // Make sure to avoid loops in the graph
			        if (!`stringArrayContains $n $visitedNodes`) {
    		            $visitedNodes[`size $visitedNodes`] = $n;
	    		        string $n2 = getSurfaceShaderForNode($n, $visibleNodes, $visitedNodes);
			            if (size($n2) > 0) {
			            	return $n2;
			            }
                    }
                }
			}
		}
	}
	return "";
}


proc string getTopTextureForNode(string $node, string $visibleNodes[], string $visitedNodes[]) {

	if (`objExists $node`) {
	 	string $nodes[] = stringArrayRemoveDuplicates(`listConnections -destination true -source false -skipConversionNodes true $node`);
	    for ($n in $nodes) {
            if (`stringArrayContains $n $visibleNodes`) {
                // Make sure to avoid loops in the graph
			    if (!`stringArrayContains $n $visitedNodes`) {
    		        $visitedNodes[`size $visitedNodes`] = $n;
	    		    string $n2 = getTopTextureForNode($n, $visibleNodes, $visitedNodes);
			        if (size($n2) > 0) {
			            return $n2;
                    }
                }
			}
		}
        
        string $nodeType = `nodeType $node`;
		if (`getClassification -satisfies "texture" $nodeType`
		    || `getClassification -satisfies "shader" $nodeType`
		    || `getClassification -satisfies "utility" $nodeType`
		    || `getClassification -satisfies "imageplane" $nodeType`
		    || `getClassification -satisfies "postprocess" $nodeType`)
            return $node;
	}
	return "";
}

proc string getShadingGraphString(string $node) 
{
    // we only want to get nodes that are visible in the node editor.  This way if a 
    // node is used in more than one graph we can limit the shaderball display to the
    // node being currently displayed in the node editor.
    global string $gHypershadeNodeEditor;
    string $visibleNodes[] = `nodeEditor -q -getNodeList $gHypershadeNodeEditor`;
    
    string $activeSurfaceShader = "";
	string $activeShadingEngine = "";		
    string $shaderName = getSurfaceShaderForNode($node, $visibleNodes, {});
    if (size($shaderName) > 0)
    {
        $activeSurfaceShader = $shaderName;
        $activeShadingEngine = getShadingEngineForNode($node, {});
    }
    else
        $activeSurfaceShader = getTopTextureForNode($node, $visibleNodes, {});

	// We pass back the shading engine + the surface shader + the node
	// in a comma seperated string. This string will be interpreted
	// as need to pull off the appropiate node names. A comma is used
	// as it is a disallowed character for a node name.
	//
	string $graph = $activeShadingEngine + "," + $activeSurfaceShader + "," + $node;
    return $graph;
}

// Callback for receiving changes to the active node in the property panel
//
global proc hyperShadePropertyPanelActiveNodeCallback(string $node) {

	global string $shaderBallActiveNode;
	if(`objExists $node`){
	    $shaderBallActiveNode = $node;
    } else {
   		$shaderBallActiveNode = "";
    }

	global string $gShaderBallEditor;
	if ($gShaderBallEditor == "" || !`modelEditor -exists $gShaderBallEditor`)
    {
        //the shaderball has been closed.  Ignore any activate calls.
        $gShaderBallEditor = "";
	    return;
    }
	
	if(!`objExists $node`){
		// Node has been deleted, set empty graph.
		modelEditor -e -asg ",,," $gShaderBallEditor;
		return;
	}

	string $soloedNode = `soloMaterial -q -node`;
	if ($soloedNode == "" || $node == $soloedNode)
	{
	    if (size($node) == 0)
		    return;

		string $graph = getShadingGraphString($node);
		string $oldGraph = `modelEditor -q -asg $gShaderBallEditor`;
		
        string $oldGraphTokens[];
		string $newGraphTokens[];
		int $numOldGraphTokens = `tokenize $oldGraph "," $oldGraphTokens`;
		int $numNewGraphTokens = `tokenize $graph "," $newGraphTokens`;

		if ($numOldGraphTokens != $numNewGraphTokens 
            || ($newGraphTokens[0] != $oldGraphTokens[0] 
            || $newGraphTokens[1] != $oldGraphTokens[1])) 
        {
			modelEditor -e -asg $graph $gShaderBallEditor;
		}
	}
}

global proc hyperShadeRefreshActiveNode()
{
    global string $shaderBallActiveNode;
    if (size($shaderBallActiveNode) != 0)
        hyperShadePropertyPanelActiveNodeCallback($shaderBallActiveNode);
}

proc deleteLookdevSelectionSet()
{
    global string $gLookdevSelectionArray[];
    clear $gLookdevSelectionArray;
}

proc string [] removeDeletedNodes(string $list[])
{
	string $item, $result[];
	int    $index = 0;
	
	for ($item in $list) {
		if (`objExists $item`) {
			$result[$index++] = $item;
		}
	}
	
	return $result;
}

global proc hypershadeUpdateLookdevSelection(string $results[])
{
    global string $gLookdevSelectionArray[];
    global string $gHypershadePropertyPanelRoot;
	string $selectionCallback = "hyperShadePropertyPanelSelectionCallback";
	string $activeNodeCallback = "hyperShadePropertyPanelActiveNodeCallback";
	string $onDeleteCallback = "hyperShadeNodeDeletedCallback";
	string $onNameChangeCallback = "hyperShadeNodeNameChangedCallback";
	
    $gLookdevSelectionArray = removeDeletedNodes($results);
    updatePropertyPanel($gHypershadePropertyPanelRoot, $selectionCallback, $activeNodeCallback, $onDeleteCallback, $onNameChangeCallback, true);    
}

global proc hyperShadeNodeDeletedCallback(string $node)
{
	global string $gLookdevSelectionArray[];
	$gLookdevSelectionArray = stringArrayRemove({$node},$gLookdevSelectionArray);
}

global proc hyperShadeNodeNameChangedCallback(string $newName, string $oldName)
{
	global string $gLookdevSelectionArray[];
	int $idx = stringArrayFind($oldName, 0, $gLookdevSelectionArray);
	if($idx != -1){
		$gLookdevSelectionArray[$idx] = $newName;
	}
}

global proc hyperShadeSelectionChangedCallback()
{
	int $kMaxNodesInPropertyPanel = 16;

	string $result[];
	string $selectedNodes[] = `ls -long -selection`;

	string $lookdevNodes[];

	for ($arbNode in $selectedNodes) {

		// If we have selected e.g. a face of a polygon (pPoly.f[123]) we
		// need to grab just the first part (pPoly) to be able to extract
		// the relevant information.
		string $tokens[];
		tokenize $arbNode "." $tokens;
		string $node = $tokens[0];

        // If we explicitly select a shading engine we want to display it
        string $nodeType = `nodeType $node`;
	    if ($nodeType == "shadingEngine") {
	        if (!stringArrayContains($node,  $result))
                $result[size($result)] = $node;
		}
		else {
		    $lookdevNodes = getLookdevNodes($node);
		    appendStringArray($result, $lookdevNodes, size($lookdevNodes));

		    $result = stringArrayRemoveDuplicates($result);
		}

		if (size($result) >= $kMaxNodesInPropertyPanel) {
			break;
		}
	}

	// We intentionally do not clear the selection when empty.
	// The last thing you had selected stays in the property view.
	if (size($result) == 0)
	{
	    global string $gLookdevSelectionArray[];
        $result = $gLookdevSelectionArray;
	}
	hypershadeUpdateLookdevSelection($result);
}

proc int raiseHypershadeWindow(string $window)
{
	if( `dockControl -exists $window` )
    {
		if (`dockControl -q -vis $window` != 0)
            dockControl -edit -raise $window;
        else
            dockControl -edit -vis true -floating true $window;

        return 1;
    }
    return 0;
}

global proc hypershadeOpenBrowserWindow(string $panel, int $floating)
{
	string $hypershadeBrowserPanelLabel = (uiRes("m_hyperShadePanel.kLookdevBrowserLabel"));
	string $dockStation                 = $panel + "dockStation";

    global string $gLookdevBrowserPanel;
	global int $gHypershadeInitialBrowserHeight;

	if(raiseHypershadeWindow($gLookdevBrowserPanel) != 0)
        return; // already open

	optionVar -stringValue "hyperShadePanelWorkAreaTab" "";	 
			     
	string $buttonsAndPaneForm = `formLayout buttonsAndPaneForm`;

    	string $browserButtons = `flowLayout browserButtons`;
    	setParent ..; // from browserButtons
    		
    	string $paneLayout =
    		`paneLayout
    			-configuration "horizontal2"
    			-activePaneIndex 1
    			paneArrangement`;
    						
    		string $firstPaneTabs = `tabLayout
    			-selectCommand
    				("hyperShadePanelSetActiveTabLayout "
    					+ $panel
    					+ " firstPaneTabs true")
    			firstPaneTabs`;
    		setParent ..; // from firstPaneTabs

		    string $secondPaneTabs = `tabLayout
	            -selectCommand
					("hyperShadePanelSetActiveTabLayout "
					+ $panel
					+ " secondPaneTabs false")
				secondPaneTabs`;
			setParent ..; // from secondPaneTabs;

    	setParent ..; // from paneArrangement

        // forcing this to only show the top pane
	    {
            paneLayout
		        -edit
		        -configuration "single"
		        -setPane firstPaneTabs 1
		        -activePaneIndex 1
		        paneArrangement;

            optionVar
                -stringValue
                	hyperShadePanelTabSectionsShown
                	"showTopTabsOnly";
        }
    
    formLayout -edit
    	-af browserButtons top		0
    	-an browserButtons bottom
    	-af browserButtons left		0
    	-af browserButtons right	0
    
    	-ac paneArrangement	top		0 browserButtons
    	-af paneArrangement	bottom	0
    	-af paneArrangement	left    0
    	-af paneArrangement	right	0
    
    	buttonsAndPaneForm;
    
    setParent ..; // from buttonsAndPaneForm

	createHypershadeBrowserToolbarFormContent( $panel, $browserButtons );

	dockControl
        -ret            true // the browser window's contents are retained.
		-area			"top"
		-floating		$floating
		-content		$buttonsAndPaneForm
		-allowedArea	"top"
		-allowedArea	"bottom"
		-allowedArea	"left"
		-allowedArea	"right"
        -height         $gHypershadeInitialBrowserHeight
		-label			$hypershadeBrowserPanelLabel
		-dockStation    $dockStation
		-parent         $panel
		$gLookdevBrowserPanel;

    setParent $panel;

	// Create the tabs
	//
	initTabs($panel);

    // Refresh the PaneTabs' active tab.
    //
    hyperShadePanelSetActiveTabLayout($panel, "firstPaneTabs", true);
    hyperShadePanelSetActiveTabLayout($panel, "secondPaneTabs", true);

	// If the user has specified in a previous session that only the top or
	// bottom tab section is to be displayed, we will continue to do so.
	//
	string $tabSectionsShown =
		`optionVar -query hyperShadePanelTabSectionsShown`;

	if ($tabSectionsShown == "showTopTabsOnly")
	{
		showTopTabsOnly($panel);
	}
	else if ($tabSectionsShown == "showBottomTabsOnly")
	{
		showBottomTabsOnly($panel);
	}

	// Refresh the toolbar since it is affected by the currently active tab
	//
	refreshToolbar($panel);
}

proc hypershadeInitializePropertyPanel(string $parentForm)
{
	global string $gHypershadePropertyPanelRoot;
	string $selectionCallback = "hyperShadePropertyPanelSelectionCallback";
	string $activeNodeCallback = "hyperShadePropertyPanelActiveNodeCallback";
	string $onDeleteCallback = "hyperShadeNodeDeletedCallback";
	string $onNameChangeCallback = "hyperShadeNodeNameChangedCallback";
	$gHypershadePropertyPanelRoot = createPropertyPanel($parentForm, $selectionCallback, $activeNodeCallback, $onDeleteCallback, $onNameChangeCallback);
	hyperShadeSelectionChangedCallback(); // Need to update the $gLookdevSelectionArray before creating the panel
	updatePropertyPanel($gHypershadePropertyPanelRoot, $selectionCallback, $activeNodeCallback, $onDeleteCallback, $onNameChangeCallback, true);
		
	scriptJob -protected -parent $parentForm -event "SelectionChanged" "hyperShadeSelectionChangedCallback";
	scriptJob -protected -parent $parentForm -event "constructionHistoryChanged" "hyperShadeSelectionChangedCallback";
}

global proc hypershadeOpenPropertyEditorWindow(string $panel, int $floating)
{
	deleteLookdevSelectionSet();

	string $hypershadePropertyPanelLabel    = (uiRes("m_hyperShadePanel.kLookdevPropertyLabel"));	
	string $dockStation                     = $panel + "dockStation";

    global string $gLookdevPropertyPanel;
	
	if(raiseHypershadeWindow($gLookdevPropertyPanel) != 0)
        return; // already open

 	// add the content
	string $oldParent = `setParent -q`;
	setParent $panel;
	string $propertyPanelForm = `formLayout propertyPanelForm`;
	setParent $oldParent;

	dockControl
        -ret            false
		-area			"right"
        -splitLayout    "vertical"
		-floating		$floating
		-content		$propertyPanelForm
		-allowedArea	"top"
		-allowedArea	"bottom"
		-allowedArea	"left"
		-allowedArea	"right"
		-label			$hypershadePropertyPanelLabel
		-dockStation    $dockStation
		-parent         $panel
		$gLookdevPropertyPanel;	

	    string $parentForm = `setParent $propertyPanelForm`;
        hypershadeInitializePropertyPanel($parentForm);
}

global proc hypershadeOpenMaterialViewerWindow(string $panel, int $floating)
{
	string $hypershadeShaderballPanelLabel  = (uiRes("m_hyperShadePanel.kLookdevShaderballLabel"));	        
	string $dockStation                     = $panel + "dockStation";
    
    global string $gLookdevShaderballPanel;

	if(raiseHypershadeWindow($gLookdevShaderballPanel) != 0)
        return; // already open
			     
 	// add the content
	string $oldParent = `setParent -q`;
	setParent $panel;
	string $shaderBallContent = createShaderBallPanel();
	setParent $oldParent;

	dockControl
        -ret            false
		-area			"right"
        -splitLayout    "vertical"
		-floating		$floating
		-content		$shaderBallContent
		-allowedArea	"top"
		-allowedArea	"bottom"
		-allowedArea	"left"
		-allowedArea	"right"
		-label			$hypershadeShaderballPanelLabel
		-dockStation    $dockStation
		-parent         $panel
		$gLookdevShaderballPanel;

	hyperShadeRefreshActiveNode();
}

global proc hypershadeOpenBinsWindow(string $panel, int $floating)
{
    string $label       = (uiRes("m_hyperShadePanel.kLookdevBinsLabel"));
	string $dockStation = $panel + "dockStation";
    global string $gLookdevBinsPanel;
			        
	if(raiseHypershadeWindow($gLookdevBinsPanel) != 0)
        return; // already open

	// add the content
	string $oldParent = `setParent -q`;
	setParent $panel;
    string $binsWrapForm = `formLayout binsWrapForm`;  	
	setParent $oldParent;

    hyperShadeBinsUI($binsWrapForm);
		        
    dockControl
	    -ret            false
	    -area			"left"
	    -floating		$floating
	    -content		$binsWrapForm
	    -allowedArea	"top"
	    -allowedArea	"bottom"
	    -allowedArea	"left"
	    -allowedArea	"right"
	    -label			$label
	    -dockStation    $dockStation 
	    -parent         $panel
	    $gLookdevBinsPanel;
}

global proc hypershadeOpenCreateWindow(string $panel, int $floating)
{
    string $hypershadeCreatePanelLabel  = (uiRes("m_hyperShadePanel.kLookdevToolkitLabel"));
	string $dockStation                 = $panel + "dockStation";
    global string $gLookdevCreatePanel;
			        
	if(raiseHypershadeWindow($gLookdevCreatePanel) != 0)
        return; // already open
	
	// add the content		     
	string $oldParent = `setParent -q`;
	setParent $panel;
    string $createBarWrapForm = `formLayout createBarWrapForm`;
    string $testDockableLayout = `columnLayout -adjustableColumn true`;             	
	setParent $oldParent;

    // Create the createBarWrapForm content.
    renderCreateBarUI($createBarWrapForm);
		        
    dockControl
	    -ret            false
	    -area			"left"
	    -floating		$floating
	    -content		$createBarWrapForm
	    -allowedArea	"top"
	    -allowedArea	"bottom"
	    -allowedArea	"left"
	    -allowedArea	"right"
	    -label			$hypershadeCreatePanelLabel
	    -dockStation    $dockStation 
	    -parent         $panel
	    $gLookdevCreatePanel;
}

global proc hypershadeOpenModelEditorWindow(string $panel, int $floating)
{
    string $panelLabel  = (uiRes("m_hyperShadePanel.kLookdevModelEditorLabel"));
	string $dockStation = $panel + "dockStation";

	global string $gLookdevModelEditorPanel;

	string $theModelPanel = $gLookdevModelEditorPanel + "ModelPanel";

	// Check if this window and content is already open
	if (`modelPanel -exists $theModelPanel`)
	{
		if(raiseHypershadeWindow($gLookdevModelEditorPanel) != 0)
	        return; // already open
	}

	// We might have an empty dock control open. 
	// We then do not create a new pane but use the existing one instead.
	//
	string $content;
	if( `dockControl -exists $gLookdevModelEditorPanel` ){
		$content = `dockControl -q -content $gLookdevModelEditorPanel`;
	} else{
		string $oldParent = `setParent -q`;
		setParent $panel;
		$content = `paneLayout`;
		setParent $oldParent;
	}

	if(raiseHypershadeWindow($gLookdevModelEditorPanel) != 0)
        return; // already open

	// Need to create the dock control before the modelPanel to avoid a bug caused by changing the full path
	// of the modelEditor belonging to the modelPanel. See: MAYA-50977 for more details.
    dockControl
        -ret            false
	    -area			"left"
        -splitLayout    "vertical"
	    -floating		$floating
	    -content		$content
	    -allowedArea	"top"
	    -allowedArea	"bottom"
	    -allowedArea	"left"
	    -allowedArea	"right"
	    -label			$panelLabel
	    -dockStation    $dockStation 
	    -parent         $panel
	    $gLookdevModelEditorPanel;

	// Create the acctual modelPanel or reparent if it exists already
	//
	if (`modelPanel -exists $theModelPanel`) {
		// reparent
		modelPanel -edit -unParent $theModelPanel;
		modelPanel -edit -parent $content $theModelPanel;
	} else {
		// create
		modelPanel -parent $content $theModelPanel;
	}
}

global proc hypershadeOpenSpreadSheetWindow(string $panel, int $floating)
{
    string $panelLabel  = (uiRes("m_hyperShadePanel.kLookdevSpreadSheetLabel"));
	string $dockStation = $panel + "dockStation";
    global string $gLookdevSpreadsheetPanel;
			        
	if(raiseHypershadeWindow($gLookdevSpreadsheetPanel) != 0)
        return; // already open
	
    // add the content		     
	string $oldParent = `setParent -q`;
	setParent $panel;
    SpreadSheetWindow;
    setParent ..;
    string $newPanel = `setParent -q`;   
	setParent $oldParent;

    dockControl
        -ret            false
	    -area			"bottom"
        -splitLayout    "vertical"
	    -floating		$floating
	    -content		$newPanel
	    -allowedArea	"top"
	    -allowedArea	"bottom"
	    -allowedArea	"left"
	    -allowedArea	"right"
	    -label			$panelLabel
	    -dockStation    $dockStation 
	    -parent         $panel
	    $gLookdevSpreadsheetPanel;
}

//
//	Description:
//		Return the types of filters that the Hypershade will display
//		in its "Show->Objects" filter menu.
//
global proc string [] hypershadeFilterCategories()
{
	string $result[] = { "Modeling", "Camera", "Animating", "Lighting", "CreateNode", "ShadingGroup" };
	return $result;
}

proc setupHypershadeNEFilterUIForm()
{
	global string $gHypershadeNodeEditor;
	filterUICreateField($gHypershadeNodeEditor, "hypershadeNEFilterUIForm");
	filterUISetRelatedFiltersProcedure($gHypershadeNodeEditor, "hypershadeFilterCategories" );
	filterUICreateMenuSub($gHypershadeNodeEditor, `popupMenu`, 0, 0);
	string $menuBarMenu = filterUIGetPopupMenu($gHypershadeNodeEditor);
	string $objectMenu = filterUIGetObjectMenu($menuBarMenu);			
	string $options[] = { "Cameras", "Shading Nodes", "Shading Groups" };
	filterUISetDefaultOptions($gHypershadeNodeEditor, $objectMenu, $options);
}

global proc hypershadeOpenRenderViewWindow(string $panel, int $floating)
{
	string $panelLabel  = (uiRes("m_hyperShadePanel.kLookdevRenderViewLabel"));
	string $dockStation = $panel + "dockStation";
	global string $gLookdevRenderViewPanel;

	// We might have empty dock controls open. 
	// We then do not create a new pane but use the existing one instead.
	//
	string $content;
	if( `dockControl -exists $gLookdevRenderViewPanel` ){
		$content = `dockControl -q -content $gLookdevRenderViewPanel`;
	} else{
		string $oldParent = `setParent -q`;
		setParent $panel;
		$content = `paneLayout`;
		setParent $oldParent;
	}
	
	// If the scripted panel has been created we simply change the parent.
	// If not, we create the scripted panel. We do this because we expect/can create
	// only one instance of certain panels.
	//
	string $renderPanels[] = `getPanel -scriptType "renderWindowPanel"`;
	if ( size( $renderPanels ) )
	{
		string $topLvlControl = `scriptedPanel -q -ctl $renderPanels[0]`;
		if($topLvlControl != ""){
			warning (uiRes("m_hyperShadePanel.kLookdevRenderViewWarning"));
			return;
		}
		// Set the new parent.
		//
		scriptedPanel -e -unParent $renderPanels[0];
		scriptedPanel -e -parent $content $renderPanels[0];
	}
	else
	{
		// Panel not yet created. Create one and unparent it.
		//
		string $renderPanel = `scriptedPanel -type "renderWindowPanel" -unParent`;
		scriptedPanel -e -label `interToUI $renderPanel` $renderPanel;
		scriptedPanel -e -parent $content $renderPanel;
	}
	if(raiseHypershadeWindow($gLookdevRenderViewPanel) != 0)
		return; // already open
	
	dockControl
		-ret            false
		-area			"bottom"
		-splitLayout    "vertical"
		-floating		$floating
		-content		$content
		-allowedArea	"top"
		-allowedArea	"bottom"
		-allowedArea	"left"
		-allowedArea	"right"
		-label			$panelLabel
		-dockStation    $dockStation 
		-parent         $panel
		$gLookdevRenderViewPanel;
}

global proc hypershadeOpenOutlinerWindow(string $panel, int $floating)
{
    string $panelLabel  = (uiRes("m_hyperShadePanel.kLookdevOutlinerLabel"));
	string $dockStation = $panel + "dockStation";
    global string $gLookdevOutlinerPanel;

	string $theOutlinerPanel = $gLookdevOutlinerPanel + "OutlinerPanel";

	// Check if this window and content is already open
	if (`outlinerPanel -exists $theOutlinerPanel`)
	{
		if(raiseHypershadeWindow($gLookdevOutlinerPanel) != 0)
	        return; // already open
	}

	// We might have an empty dock control open. 
	// We then do not create a new pane but use the existing one instead.
	//
	string $content;
	if( `dockControl -exists $gLookdevOutlinerPanel` ){
		$content = `dockControl -q -content $gLookdevOutlinerPanel`;
	} else {
		string $oldParent = `setParent -q`;
		setParent $panel;
		$content = `paneLayout`;
		setParent $oldParent;
	}

	// Create the acctual outlinerPanel or reparent if it exists already
	//
	if (`outlinerPanel -exists $theOutlinerPanel`) {
		// reparent
		outlinerPanel -edit -unParent $theOutlinerPanel;
		outlinerPanel -edit -parent $content $theOutlinerPanel;
	} else {
		// create
		outlinerPanel -parent $content $theOutlinerPanel;
	}

	if(raiseHypershadeWindow($gLookdevOutlinerPanel) != 0)
        return; // already open
	
    dockControl
        -ret            false
	    -area			"left"
        -splitLayout    "vertical"
	    -floating		$floating
	    -content		$content
	    -allowedArea	"top"
	    -allowedArea	"bottom"
	    -allowedArea	"left"
	    -allowedArea	"right"
	    -label			$panelLabel
	    -dockStation    $dockStation 
	    -parent         $panel
	    $gLookdevOutlinerPanel;
}

global proc hypershadeOpenUVEditorWindow(string $panel, int $floating)
{
    string $panelLabel  = (uiRes("m_hyperShadePanel.kLookdevUVEditorLabel"));
	string $dockStation = $panel + "dockStation";
    global string $gLookdevUVEditorPanel;

	// We might have empty dock controls open. 
	// We then do not create a new pane but use the existing one instead.
	//
	string $content;
	if( `dockControl -exists $gLookdevUVEditorPanel` ){
		$content = `dockControl -q -content $gLookdevUVEditorPanel`;
	} else{
		string $oldParent = `setParent -q`;
		setParent $panel;
		$content = `paneLayout`;
		setParent $oldParent;
	}

	// If the scripted panel has been created we simply change the parent.
	// If not, we create the scripted panel. We do this because we expect/can create
	// only one instance of certain panels.
	//
	string $texturePanels[] = `getPanel -scriptType "polyTexturePlacementPanel"`;
	if ( size( $texturePanels ) )
	{
		string $topLvlControl = `scriptedPanel -q -ctl $texturePanels[0]`;
		if($topLvlControl != ""){
			warning (uiRes("m_hyperShadePanel.kLookdevUVEditorWarning"));
			return;
		}
		// Set the new parent.
		//
		scriptedPanel -e -unParent $texturePanels[0];
		scriptedPanel -e -parent $content $texturePanels[0];
	}
	else
	{
		// Panel not yet created. Create one and unparent it.
		//
		string $texturePanel = `scriptedPanel -type "polyTexturePlacementPanel" -unParent`;
		scriptedPanel -e -label `interToUI $texturePanel` $texturePanel;
		scriptedPanel -e -parent $content $texturePanel;
	}
	if(raiseHypershadeWindow($gLookdevUVEditorPanel) != 0)
        return; // already open
		        
    dockControl
        -ret            false
	    -area			"bottom"
        -splitLayout    "vertical"
	    -floating		$floating
	    -content		$content
	    -allowedArea	"top"
	    -allowedArea	"bottom"
	    -allowedArea	"left"
	    -allowedArea	"right"
	    -label			$panelLabel
	    -dockStation    $dockStation 
	    -parent         $panel
	    $gLookdevUVEditorPanel;
}

global proc hypershadeOpenGraphEditorWindow(string $panel, int $floating)
{
    string $panelLabel  = (uiRes("m_hyperShadePanel.kLookdevGrapEditorLabel"));
	string $dockStation = $panel + "dockStation";
    global string $gLookdevGraphEditorPanel;

	// We might have empty dock controls open. 
	// We then do not create a new pane but use the existing one instead.
	//
	string $content;
	if( `dockControl -exists $gLookdevGraphEditorPanel` ){
		$content = `dockControl -q -content $gLookdevGraphEditorPanel`;
	} else{
		string $oldParent = `setParent -q`;
		setParent $panel;
		$content = `paneLayout`;
		setParent $oldParent;
	}

	// If the scripted panel has been created we simply change the parent.
	// If not, we create the scripted panel. We do this because we expect/can create
	// only one instance of certain panels.
	//
	string $graphEditorPanels[] = `getPanel -scriptType "graphEditor"`;
	if ( size( $graphEditorPanels ) )
	{
		string $topLvlControl = `scriptedPanel -q -ctl $graphEditorPanels[0]`;
		if($topLvlControl != ""){
			warning (uiRes("m_hyperShadePanel.kLookdevGrapEditorWarning"));
			return;
		}
		// Set the new parent.
		//
		scriptedPanel -e -unParent $graphEditorPanels[0];
		scriptedPanel -e -parent $content $graphEditorPanels[0];
	}
	else
	{
		// Panel not yet created. Create one and unparent it.
		//
		string $graphEditorPanel = `scriptedPanel -type "graphEditor" -unParent`;
		scriptedPanel -e -label `interToUI $graphEditorPanel` $graphEditorPanel;
		scriptedPanel -e -parent $content $graphEditorPanel;
	}
	if(raiseHypershadeWindow($gLookdevGraphEditorPanel) != 0)
        return; // already open
		        
    dockControl
        -ret            false
	    -area			"bottom"
        -splitLayout    "vertical"
	    -floating		$floating
	    -content		$content
	    -allowedArea	"top"
	    -allowedArea	"bottom"
	    -allowedArea	"left"
	    -allowedArea	"right"
	    -label			$panelLabel
	    -dockStation    $dockStation 
	    -parent         $panel
	    $gLookdevGraphEditorPanel;
}

global proc addHyperShadePanel(string $panel)
{
	//
	// Description:
	//	This procedure is called when the hypershade panel is first opened.
	//	This procedure creates all of the UI for the hypershade panel.
	//
	
	// Make sure the filteredCollection stuff is initialized.
	//
	filteredCollection();

	// Show the wait cursor
	//
	waitCursor -state on;

	// Flag this as a construction operation, to prevent many unnecessary
	// refreshes as the tabs are being created.
	//
	hyperShadeStartConstruction( $panel );

	buildMainMenu(
		$panel,
		false); // not a popup menu

	int $addMaterialViewer = 1;
	string $disableMaterialViewer = getenv("MAYA_DISABLE_LOOKDEV_MATERIAL_VIEWER");
	if (size($disableMaterialViewer) != 0)
		$addMaterialViewer = 0;

	int $addPropertyPanel = 1;
	string $disablePropertyPanel = getenv("MAYA_DISABLE_LOOKDEV_PROPERTY_PANEL");
	if (size($disablePropertyPanel) != 0)
		$addPropertyPanel = 0;

	formLayout -manage false mainForm; 

		string $dockStation        = $panel + "dockStation";
		string $lookdevEditorLabel = (uiRes("m_hyperShadePanel.kLookdevEditor"));

		window -width 512 -height 268 
            -sizeable true 
            -title $lookdevEditorLabel
            -parent mainForm 
            -dockStation
            -dockCorner "topRight" "right"
            -dockCorner "bottomRight" "right"
            -nestedDockingEnabled 1
            $dockStation;

		string $nodeEditorForm = `formLayout nodeEditorForm`;
		string $nodeEditorToolbar = `flowLayout nodeEditorToolbar`;
		setParent ..;

        // Create the content of the toolbarForm.
        createHypershadeNodeEditorToolbarFormContent($panel, $nodeEditorToolbar);
		
		string $mainPane = `paneLayout -configuration ($addPropertyPanel > 0 ? "vertical3" : "vertical2") -staticWidthPane 1 mainPane`;

		    // Node Editor Panel
			// **********************************************************************************************************
		    {			     
	            string $hypershadeNodeEditorPanelLabel  = (uiRes("m_hyperShadePanel.kLookdevNodeEditorLabel"));
			    string $hypershadeNodeEditorPanel       = "LookdevNodeEditorPanel";
				string $nestedDock                      = $hypershadeNodeEditorPanel + "Dock";
                global string $gHypershadeNodeEditor;

			    int $nodeEditorDockable = 0;
                if ($nodeEditorDockable != 0)
                {   
		            if( `window -exists $hypershadeNodeEditorPanel` )
		                deleteUI $hypershadeNodeEditorPanel;
				    if( `dockControl -exists $nestedDock` )
		                deleteUI $nestedDock;

			        window -width 512 -height 268 -sizeable true -title $hypershadeNodeEditorPanelLabel $hypershadeNodeEditorPanel;	

                    if (!`nodeEditor -exists $gHypershadeNodeEditor`)
                        $gHypershadeNodeEditor = createNodeEditor("hyperShadePrimaryNodeEditor", $hypershadeNodeEditorPanel);
                    else
                    {
                        nodeEditor -e -parent $hypershadeNodeEditorPanel $gHypershadeNodeEditor;
                    }

				    dockControl
		               -ret         false
		               -area		"bottom"
		               -floating	0
		               -content		$hypershadeNodeEditorPanel
		               -allowedArea	"top"
		               -allowedArea	"bottom"
		               -allowedArea	"left"
		               -allowedArea	"right"
		               -label		$hypershadeNodeEditorPanelLabel
		               -dockStation $dockStation
		               -parent      $panel
		               $nestedDock;
                }
		        else
                {
                    if (!`nodeEditor -exists $gHypershadeNodeEditor`)
                        $gHypershadeNodeEditor = createNodeEditor("hyperShadePrimaryNodeEditor", $mainPane);
                    else
                    {
                        nodeEditor -edit -parent $mainPane $gHypershadeNodeEditor;
                    }
                }
		    }

			setupHypershadeNEFilterUIForm();

			formLayout 
				-edit 

				-af $nodeEditorToolbar top 0
				-an $nodeEditorToolbar bottom
				-af $nodeEditorToolbar left 0
				-af $nodeEditorToolbar right 0

				-ac $mainPane top 0 $nodeEditorToolbar
				-af $mainPane bottom 0
				-af $mainPane left 0
				-af $mainPane right 0

				$nodeEditorForm;

		    // Browser Panel
			// **********************************************************************************************************
		    hypershadeOpenBrowserWindow($panel, false);

		    // shaderball panel
			// **********************************************************************************************************
			if ($addMaterialViewer > 0)
                hypershadeOpenMaterialViewerWindow($panel, false);

			// Property Panel
			// **********************************************************************************************************
			if ($addPropertyPanel > 0)
                hypershadeOpenPropertyEditorWindow($panel, false); 
			
			// create panel
			// **********************************************************************************************************
	        hypershadeOpenCreateWindow($panel, false);

			// bins panel
			// **********************************************************************************************************
	        hypershadeOpenBinsWindow($panel, false);

			// Put the create panel on top
			// **********************************************************************************************************
			global string $gLookdevCreatePanel;
			dockControl -e -r $gLookdevCreatePanel;

            // model editor panel
			// **********************************************************************************************************
            global string $gLookdevModelEditorPanel;
            string $modelEditorExists = $gLookdevModelEditorPanel + "Exists";
            if (`optionVar -exists $modelEditorExists`)
	            hypershadeOpenModelEditorWindow($panel, false);

            // spreadsheet panel
			// **********************************************************************************************************
            global string $gLookdevSpreadsheetPanel;
            string $spreadsheetEditorExists = $gLookdevSpreadsheetPanel + "Exists";
            if (`optionVar -exists $spreadsheetEditorExists`)
	            hypershadeOpenSpreadSheetWindow($panel, false);
				
			// renderview panel
			// **********************************************************************************************************
            global string $gLookdevRenderViewPanel;
            string $renderViewExsists = $gLookdevRenderViewPanel + "Exists";
            if (`optionVar -exists $renderViewExsists`)
	            hypershadeOpenRenderViewWindow($panel, false);
				
			// outliner panel
			// **********************************************************************************************************
            global string $gLookdevOutlinerPanel;
            string $renderViewExsists = $gLookdevOutlinerPanel + "Exists";
            if (`optionVar -exists $renderViewExsists`)
	            hypershadeOpenOutlinerWindow($panel, false);
				
			// uveditor panel
			// **********************************************************************************************************
            global string $gLookdevUVEditorPanel;
            string $renderViewExsists = $gLookdevUVEditorPanel + "Exists";
            if (`optionVar -exists $renderViewExsists`)
	            hypershadeOpenUVEditorWindow($panel, false);
				
			// grapheditor panel
			// **********************************************************************************************************
            global string $gLookdevGraphEditorPanel;
            string $renderViewExsists = $gLookdevGraphEditorPanel + "Exists";
            if (`optionVar -exists $renderViewExsists`)
	            hypershadeOpenGraphEditorWindow($panel, false);


		setParent $panel;

		// Main layout done here
		//
		formLayout
			-edit

			-af $dockStation top		1
			-af $dockStation bottom		1
			-af $dockStation left		1
			-af $dockStation right		1

			mainForm;

	setParent ..; // from mainForm

	// Set the create bar to the last saved size.
	evalDeferred("setHyperShadePaneSizes " + $panel + " paneArrangement");

    // Finished creating the content of the mainForm, manage the
    // form to show the content.
    //
    formLayout -edit -manage true mainForm;

	// Hide the wait cursor
	//
	waitCursor -state off;

	// Establish callbacks which will be called when plugins are
	// loaded/unloaded. The callbacks will find out what plugin was loaded and
	// will update the create bar if necessary.
	//
	global int $gHypershadePluginCallbacksRegistered;

	if (!$gHypershadePluginCallbacksRegistered)
	{
		loadPlugin
			-addCallback
				("hyperShadePanelLoadPluginCallback \"" + $panel + "\"") ;
		unloadPlugin
			-addCallback
				("hyperShadePanelUnloadPluginCallback \"" + $panel + "\"") ;
		$gHypershadePluginCallbacksRegistered = true;
	}

	// Signal the end of the construciton operation
	//
	hyperShadeEndConstruction( $panel, 1 );
}

proc deleteEditors(
	string $tabLayout)
{
	//
	// Description:
	//	This procedure is called from removeHyperShadePanel().
	//	This procedure determines all the hypergraph editors that are being
	//	used within the specified tab layout and deletes them, since the
	//	hypershade is going away.
	//

	string $tabArray[] = `tabLayout -query -childArray $tabLayout`;
	string $tab;

	global string $gHypershadeNodeEditor;
	nodeEditor -e -unParent $gHypershadeNodeEditor;
	
	// Delete all hypergraph editors being used by this panel
	//
	for ($i = 0; $i < size($tabArray); $i++)
	{
		$tab = $tabArray[$i];
		$tab = ($tabLayout + "|" + $tab);

		string $tabType = lookupTabType($tab);
		string $component = lookupComponentName($tab);

        // If the conponent is an empty string, it means the
        // content of this tab was never constructed, then we
        // do no need to do anything.
        //
        if ($component == "")
        {
            continue;
        }

		string $hypergraph;

		if ($tabType == "scene")
		{
			string $hypershade = collectionUIHypershadeName($component);

			// Be sure to properly delete the collection, including
			// its filters and such.
			//
			collectionUIDelete( $component, 0 );

			hyperGraph -edit -unParent $hypershade;
			deleteUI $hypershade;
		}
		else if ($tabType == "disk")
		{
			string $filesVisor = libraryUIFilesVisor($component);
			string $directoriesVisor =
				libraryUIDirectoriesVisor($component);
			hyperGraph -edit -unParent $filesVisor;
			deleteUI $filesVisor;
			hyperGraph -edit -unParent $directoriesVisor;
			deleteUI $directoriesVisor;
		}
		else if ($tabType == "graph" || $tabType == "protected graph")
		{
			string $hypershade = graphUIHypershadeName($component);
			hyperGraph -edit -unParent $hypershade;
			deleteUI $hypershade;
		}
	}
}
 
proc savePaneSize(string $pane)
{
    $panelExists = $pane + "Exists";

    //save the pane size
    if (`dockControl -exists $pane`)
    {
        optionVar -iv $panelExists true;

	    int $size = `dockControl -q -width $pane`;
        string $panelSizeVar = $pane + "Width";

	    optionVar -iv $panelSizeVar $size;

        $panelSizeVar = $pane + "Height";
	    $size = `dockControl -q -height $pane`;
	    optionVar -iv $panelSizeVar $size;
    }
    else if (`optionVar -exists $panelExists`)
        optionVar -remove $panelExists;        
}

proc saveHyperShadePaneSizes(string $panel)
{
	//
	// Save the size and layout of the pane in hypershade.
	//
	string $oldParent = `setParent -query`;
	if ("" != $panel)
	{
		setParent $panel;
	}

	if (`paneLayout -exists paneArrangement`)
	{
		int $paneSizes[] = `paneLayout -q -paneSize paneArrangement`;
		if (1 < size($paneSizes))
		{
			if (3 > $paneSizes[1])
				$paneSizes[1] = 0;
			else if (97 < $paneSizes[1])
				$paneSizes[1] = 100;
			optionVar -iv hyperShadeWorkAreaProportion $paneSizes[1];
		}
	}

	//save the create pane size
	global string $gLookdevCreatePanel;
    savePaneSize($gLookdevCreatePanel);

	//save the bins pane size
	global string $gLookdevBinsPanel;
    savePaneSize($gLookdevBinsPanel);

	//save the property panel size
	global string $gLookdevPropertyPanel;
	savePaneSize($gLookdevPropertyPanel);

	//save the shaderball panel size
	global string $gLookdevShaderballPanel;
	savePaneSize($gLookdevShaderballPanel);

	//save the browser panel size
	global string $gLookdevBrowserPanel;
	savePaneSize($gLookdevBrowserPanel);

	//save the modelEditor panel size
	global string $gLookdevModelEditorPanel;
	savePaneSize($gLookdevModelEditorPanel);

	//save the spreadsheet panel size
	global string $gLookdevSpreadsheetPanel;
	savePaneSize($gLookdevSpreadsheetPanel);
	
	//save the renderview panel size
	global string $gLookdevRenderViewPanel;
	savePaneSize($gLookdevRenderViewPanel);
	
	//save the outliner panel size
	global string $gLookdevOutlinerPanel;
	savePaneSize($gLookdevOutlinerPanel);
	
	//save the uveditor panel size
	global string $gLookdevUVEditorPanel;
	savePaneSize($gLookdevUVEditorPanel);
	
	//save the grapheditor panel size
	global string $gLookdevGraphEditorPanel;
	savePaneSize($gLookdevGraphEditorPanel);

    // save all the docking layout information
	string $dockStation = $panel + "dockStation";
    string $dockingLayout = `window -q -dockingLayout $dockStation`;
	optionVar -sv hyperShadeDockingLayout $dockingLayout;

	if ($oldParent != "NONE") 
		setParent $oldParent;
}

global proc removeHyperShadePanel(string $panel)
{
	//
	// Description:
	//	This procedure is called when the hypershade is being destroyed
	//	or reparented.
	//	This procedure ensures that all hypergraph/hypershade/visor editors
	//	used by the various tabs get deleted.
	//

	saveHyperShadePaneSizes($panel);

	// Flag this as a construction operation, to prevent many unnecessary
	// refreshes as the tabs are deleted.
	//
	hyperShadeStartConstruction( $panel );

    deleteLookdevSelectionSet();

	string $tabLayout;

	setParent $panel;
	$tabLayout = `setParent firstPaneTabs`;
	deleteEditors($tabLayout);

	setParent $panel;
	$tabLayout = `setParent secondPaneTabs`;
	deleteEditors($tabLayout);

    // Set the previous filterBox and filterButton value to "".
    //
    global string $gPreviousFilterBox;
    global string $gPreviousFilterButton;
    $gPreviousFilterBox = "";
    $gPreviousFilterButton = "";

	// Unregister the callbacks which are being called when plugins are
	// loaded/unloaded.
	//
	global int $gHypershadePluginCallbacksRegistered;

	if ($gHypershadePluginCallbacksRegistered)
	{
		loadPlugin
			-removeCallback
				("hyperShadePanelLoadPluginCallback \"" + $panel + "\"") ;
		unloadPlugin
			-removeCallback
				("hyperShadePanelUnloadPluginCallback \"" + $panel + "\"") ;
		$gHypershadePluginCallbacksRegistered = false;
	}
	
    // clean up the shader ball editor
	global string $gShaderBallEditor; 
    if (`modelEditor -exists $gShaderBallEditor`)
        deleteUI $gShaderBallEditor;
	$gShaderBallEditor = "";

	// Signal end of the construction process
	//
	hyperShadeEndConstruction( $panel, 0 );
	
	// Remove hyperShadeNodeEditor from filter UI
	global string $gHypershadeNodeEditor;
	filterUIRemoveView($gHypershadeNodeEditor);
}


proc string saveNodeEditorState(string $panelName) {
//
//  Description:
//		Return a string that will restore the current node Editor state
//		when it is executed.
//
	// 
	// Save the current graph state with the panel
	// if we are saving panel configs
	//
    global string $gHypershadeNodeEditor;

	string $stateString;
	// create the normal state string
	string $indent = "\n\t\t\t";
	string $ned = $gHypershadeNodeEditor;
	$stateString = (
		$indent + "$editorName = " + $ned + ";\n" +
		`nodeEditor -query -stateString $ned`
		);
	return $stateString;
}


global proc string saveStateHyperShadePanel(string $panel)
{
	//
	// Description:
	//	This procedure is a required procedure for a scripted panel.
	//  It is meant to return a string which, when executed, will set the
	//  panel's state. 

	string $stateStr = ""; //saveNodeEditorState($panel);
	return $stateStr;
}

global proc deleteHyperShadePanel(string $panel)
{
	//
	//  Description:
	//    Final deletion of the panel.  Clean up any resources that need to be
	//    freed.
	//
	global string $gPauseButtonPanel;
	$gPauseButtonPanel = "";
}

global proc hyperShadePanel(string $panel)
{
	global string $gMainPane;

	// Instantiate a new hyperShadePanel
	//
	setParent $gMainPane;
	scriptedPanel -unParent -type hyperShadePanel $panel;
}


global proc hyperShadeSetShowRelationshipsCallback( string $itemName, string $panel )
{
	// Description:
	//  This procedure is called when the show-relationships menu item is selected
	//  It toggles the show-relationships setting in the corresponding hyperGraph editor
	//
	string $activeTab = activeTab($panel);
	string $component = lookupComponentName($activeTab);

	if( isGraphTab($activeTab) )
	{
		string $editor = graphUIHypershadeName($component);
		int $state = `menuItem -query -checkBox $itemName`;
		optionVar -intValue hsShowRelationships $state;
		hyperGraph -e -showRelationships $state $editor;
	}
}

global proc hyperShadeSetMergeConnectionsCallback( string $itemName, string $panel )
{
	// Description:
	//  This procedure is called when the merge-connections menu item is selected
	//  It toggles the mergeConnections setting in the corresponding hyperGraph editor
	//
	string $activeTab = activeTab($panel);
	string $component = lookupComponentName($activeTab);

	if( isGraphTab($activeTab) )
	{
		string $editor = graphUIHypershadeName($component);
		int $state = `menuItem -query -checkBox $itemName`;
		optionVar -intValue hsMergeConnections $state;
		hyperGraph -e -mergeConnections $state $editor;
	}
}

global proc hyperShadeSetOpaqueContainersCallback( string $itemName, string $panel )
{
	// Description:
	//  This procedure is called when the opaque-containers menu item is selected
	//  It toggles the opaqueContainers setting in the corresponding hyperGraph editor
	//
	string $activeTab = activeTab($panel);
	string $component = lookupComponentName($activeTab);

	if( isGraphTab($activeTab) )
	{
		string $editor = graphUIHypershadeName($component);
		int $state = `menuItem -query -checkBox $itemName`;
		optionVar -intValue hsOpaqueContainers $state;
		hyperGraph -e -opaqueContainers $state $editor;
	}
}


//-----------------------------------------------------------------------------
//
//	FILTER CONTROLS
//	---------------
//
//	This section provides functions for adding general HyperGraph-style
//	filtering to the HyperShade tabs.  Each tab has two controls that
//	implement filtering:
//
//	1) a text box for entering regular expressions that specify the
//	   names of nodes that should be displayed in the tab.
//
//	2) a "Show" button that has a popup menu that specifies some
//	   node type-based filters to be applied in addition to the
//	   name-based filtering.
//
//	The filter controls are created and managed by the code in
//	filterUI.mel.
//
//-----------------------------------------------------------------------------


proc string[] findTabFilterControls(
	string $tab)
{
	//
	// Description:
	//	Locates the parent layout for a tab, as well as
	//	the relevant filtering controls for it.
	//

	// returns 4 controls:
	//
	//	1) formLayout that contains the HyperShade editor
	//	   and its filter controls
	//	2) hyperShade editor
	//	3) filter box
	//	4) filter "Show" button
	//
	string $collection = lookupComponentName( $tab );

	string $filterControls[] = collectionUIFilterControls( $collection );
	string $hs = $filterControls[0];
	string $filterBox = $filterControls[1];
	string $filterButton = $filterControls[2];

	string $res[];
	$res[0] = $collection;
	$res[1] = $hs;
	$res[2] = $filterBox;
	$res[3] = $filterButton;
	return $res;
}

proc setTabFilterControls(
	string $tab,
	string $filterBox,
	string $filterButton)
{
	//
	// Description:
	//	Records the names of the filter controls for the
	//	specified tab.
	//
	string $collection = lookupComponentName( $tab );

	collectionUISetFilterControls( $collection,
								   $filterBox,
								   $filterButton );
}

// Description:  This procedure is called to show the given $tab's
//      filterBox and filterButton.
//
global proc showCurrentFilterBoxAndButton(string $panel, string $tab)
{
	string $controls[] = `findTabFilterControls( $tab )`;
	string $filterBox = $controls[2];
	string $filterButton = $controls[3];

    setParent $panel;

    // Hide the previous filterBox and filterButton.
    //
    global string $gPreviousFilterBox;
    global string $gPreviousFilterButton;
    if ($gPreviousFilterBox != "" && $filterBox != $gPreviousFilterBox)
    {
        control -e -vis false $gPreviousFilterBox;
        control -e -vis false $gPreviousFilterButton;
    }

    // Show the current filterBox and filterButton. Must also enable in case they are dimmed.
    //
	control -e -vis true -enable true $filterBox;
	control -e -vis true -enable true $filterButton;

    $gPreviousFilterBox = $filterBox;
    $gPreviousFilterButton = $filterButton;
}

// Description:  This procedure is called to dim the given $tab's
//      filterBox and filterButton.
//
global proc dimCurrentFilterBoxAndButton()
{
    // Dim the previous filterBox and filterButton.
    //
    global string $gPreviousFilterBox;
    global string $gPreviousFilterButton;
    if ($gPreviousFilterBox != "")
    {
        control -e -enable false $gPreviousFilterBox;
        control -e -enable false $gPreviousFilterButton;
    }
}

global proc showFilter(
	string $panel,
	string $tab,
	string $implicit)
{
	//
	// Description:
	//	Creates the user-defined filtering controls for the given tab.
	//	The specified implicit filter will be applied before the
	//	user-specified filtering.
	//

	//	build the filtering controls
	//
	addFilter( $panel, $tab, $implicit );

	//	lay out the controls
	//
	string $controls[] = `findTabFilterControls( $tab )`;
	string $layout = $controls[0];
	string $hs = $controls[1];
	string $filterBox = $controls[2];
	string $filterButton = $controls[3];


	string $oldParent = `setParent -q`;
	setParent $layout;

    // Put the hyperShadeEditor in layout.
    //
	formLayout -edit
		-attachForm		$hs				"bottom"	0
		-attachForm	    $hs				"top"		0
		-attachForm		$hs				"left"		0
		-attachForm		$hs				"right"		0
	$layout;

    // Put the filterBox and filterButton in the sceenTabForm.
    //
    setParent $panel;

    showCurrentFilterBoxAndButton($panel, $tab);

	control -e -en 1 $filterBox;

	formLayout -edit
   		-attachForm     $filterBox		"top"		0
   		-attachForm     $filterBox		"left"		0
   		-attachForm  	$filterBox		"bottom"    0
   		-attachNone		$filterBox		"right"
	sceneTabFilterForm;

	control -e -en 1 $filterButton;

	formLayout -edit
   		-attachForm     $filterButton	"top"		0
   		-attachControl  $filterButton   "left"		5 $filterBox
   		-attachForm     $filterButton   "bottom"    0
   		-attachForm     $filterButton   "right"     0
	sceneTabFilterForm;

	setParent $oldParent;

}

global proc addFilter(
	string $panel,
	string $tab,
	string $implicit )
{
	//
	// Description:
	//	Creates filter controls for the specified tab and hooks
	//	them up to the HyperShade view.
	//

	//	see if the controls have already been created
	//
	string $controls[] = `findTabFilterControls( $tab )`;
	string $collection = $controls[0];
	string $hs = $controls[1];
	string $filterBox = $controls[2];
	string $filterButton = $controls[3];

	if( !`button -ex $filterButton` )
	{
		//	controls do not exist, so build them in the
		//  sceneTabFilterForm.
		//
		string $oldParent = `setParent -q`;
		setParent $panel;
        string $filterUIParent = `setParent sceneTabFilterForm`;

		//	create the filter box for specifying node name
		//	wildcards.
		//
		$filterBox = filterUICreateField($hs, $filterUIParent);

		//	create the "Show" button that will contain a popup
		//	menu for node type-based filtering
		//
		$filterButton = `button -label (uiRes("m_hyperShadePanel.kShow")) `;

		//	create the popup "Show" menu
		//
		string $m = `popupMenu -parent $filterButton -button 1`;
		string $filterMenu = filterUICreateMenuSub($hs, $m, 0, 0);

		//	set the implicit filter - this is determined by the type
		//	of the tab.  If a user creates a "Materials" tab, then
		//	the implicit filter will show only materials, and the
		//	user-defined name and type filters will be applied on
		//	top of that.
		//
		filterUISetImplicitFilterNoApply( $hs, $implicit );

		//	set the related filters for this tab
		//
		string $internalName =
			filteredCollection_InternalFromFilter( $implicit );

		string $relatedFilters[] =
			filteredCollection_RelatedFilters( $internalName );

		if( (size($relatedFilters) == 1) && ($relatedFilters[0] == "ALL") )
		{
			// means all filters are related, so specify no related filter proc
			//
			filterUISetRelatedFiltersProcedure($hs, "");
		}
		else
		{
			string $relatedProc =
				("filteredCollection_RelatedFilters " + $internalName);
			filterUISetRelatedFiltersProcedure( $hs, $relatedProc );
		}

		//	register the controls in the lookup table
		//
		setTabFilterControls( $tab, $filterBox, $filterButton );
		setParent $oldParent;
	}
}


//------------------------------------------------------------------------
//
//	The following procedures are for enabling and disabling
//	HyperShade tabs during construction operations.  This helps
//	to speed up the UI by avoiding unnecessary refreshes while
//	the UI is in a transient state.
//

proc string[] listSceneTabs(
	string $panel,
	int $active )
{
	//
	// Description:
	//	Lists the names of the scene tabs in the HyperShade.  If the
	//	$active flag it true, only lists the tabs that are
	//	currently active.

	string $oldParent = `setParent -q`;
	setParent $panel;

	string $tabs[] = {};

	//	go through the top and bottom panes
	//
	string $pane;
	for( $pane in { "firstPaneTabs", "secondPaneTabs" } )
	{
		if( `layout -ex $pane` )
		{
			string $tabLayout = `setParent $pane`;

			//	get the tab layout children
			//
			string $tabArray[];
			if( $active )
			{
				string $active = `tabLayout -query -selectTab $tabLayout`;
				$tabArray = { $active };
			}
			else
			{
				$tabArray = `tabLayout -query -childArray $tabLayout`;
			}

			//	store the scene tabs
			//
			for ($i = 0; $i < size($tabArray); $i++)
			{
				string $tab = $tabArray[$i];
				$tab = ($tabLayout + "|" + $tab);

				if( isSceneTab($tab) )
				{
					$tabs[size($tabs)] = $tab;
				}
			}
		}
	}

	setParent $oldParent;
	return $tabs;
}

proc enableTabs(
	string $panel,
	int $enable )
{
	//
	// Description:
	//	Enables or disables all scene tabs in the HyperShade.
	//
	string $allTabs[] = listSceneTabs($panel,0);
	string $t;

	for( $t in $allTabs )
	{
		string $collectionUI = lookupComponentName( $t );
		collectionUIEnableFilter( $collectionUI, $enable );
	}
}

proc enableActiveTabs(
	string $panel,
	int $enable )
{
	//
	// Description:
	//	Enables or disables all active scene tabs in the HyperShade.
	//
	string $activeTabs[] = listSceneTabs($panel,1);
	string $t;

	for( $t in $activeTabs )
	{
		string $collectionUI = lookupComponentName( $t );
		collectionUIEnableFilter( $collectionUI, $enable );
	}
}

//	global variable indicates whether HyperShade is in a
//	transient state or not.
//
global int $hsInConstruction = 0;

global proc hyperShadeStartConstruction(
	string $panel)
{
	//
	// Description:
	//	Signals that the HyperShade is about to start
	//	constructing, destroying, or moving tabs.  This
	//	causes many refresh messages to be sent to the
	//	tabs, so we would like to prevent them from doing
	//	unnecessary work during this time.  We do this by
	//	disabling the filters on the tabs.
	//
	global int $hsInConstruction;
	$hsInConstruction = 1;

	enableTabs( $panel, 0 );
}

global proc hyperShadeEndConstruction(
	string $panel,
	int $stillAround)
{
	//
	// Description:
	//	Signals the end of a HyperShade tab construction, destruction, or
	//	move operation.  If the HyperShade panel itself is still around
	//	after this operation, then we need to refresh the active tabs.
	//	Other tabs will be refreshed when the user clicks on them.
	//
	global int $hsInConstruction;
	$hsInConstruction = 0;

	if( $stillAround )
	{
		enableActiveTabs( $panel, 1 );
	}
}

global proc int hyperShadeIsInConstruction( string $panel )
{
	//
	// Description:
	//	Indicates whether or not the HyperShade is in the
	//	middle of a construction operation.  The filtering
	//	functions in collectionUI.mel use this function
	//	to decide whether or not they should obey requests
	//	to refresh the contents of the tabs.
	//
	global int $hsInConstruction;
	return $hsInConstruction;
}

proc string paneActiveTab(
	string $panel, string $tabLayout)
{
	//
	// Description:
	//	This procedure determines the name of the frontmost tab in the tab
	//	layout in the active pane of the hypershade panel.
	//
	// Returns:
	//	The name of the tab.
	//

	// Remember the current parent so we can revert to it when we're done here.
	//
	string $oldParent = `setParent -query`;
	string $oldMenuParent = `setParent -menu -query`;

	string $tab;

    if (size(`tabLayout -q -childArray $tabLayout`) == 0)
    {
        // No tab in this tabLayout.
        //
        $tab = "";
    }
    else
    {
        $tabLayout = `setParent $tabLayout`;

	    $tab = `tabLayout -query -selectTab $tabLayout`;
	    $tab = `setParent $tab`;
    }

	// Revert to the original parent.
	//
	if ($oldParent != "NONE") setParent $oldParent;
	if ($oldMenuParent != "NONE") setParent -menu $oldMenuParent;

	return $tab;
}

// Description:  This procedure returns the active scene tab
//      in hyper shade.
//
global proc string hyperShadePaneSceneTabsCurrentView(string $tabLayout)
{
	string $panel = hyperShadePanelName();
	if (!`panel -exists $panel`)
	{
		return "";
	}

    string $tab = paneActiveTab($panel, $tabLayout);

    // If the tabLayout has no tabs in it, then there is no view.
    //
    if ($tab == "")
    {
        return "";
    }

    // If the active tab is not a scene tab, then there is no scene
    // tab being viewed at the moment for this tabLayout.  Return "".
    //
    if (!isSceneTab($tab))
    {
        return "";
    }

    string $controls[] = `findTabFilterControls($tab)`;
    string $view = $controls[1];
    return $view;
}

// Description:  This procedure is called to return the name of
//      the hyper shade createAndOrganizeForm
//
global proc string hyperShadeCreateAndOrganizeFormName()
{
    string $oldParent = `setParent -q`;

	string $panel = hyperShadePanelName();
    setParent $panel;
    setParent createAndOrganizeForm;
    string $result = `setParent -q`;

    setParent $oldParent;

    return $result;
}

global proc hyperShadeEditTexture( string $node )
{
	string $cmd = "getAttr ";
	$cmd += $node;
	$cmd += ".fileTextureName";

    string $fileName = eval($cmd);
	if ( $fileName == "" ) {
		string $errorStr = (uiRes("m_hyperShadePanel.kNoFileAssigned"));
		error (`format -s $node $errorStr`);
		return;
	}

	int $sequence  = 0;	// single image
	int $editImage = 1;
	launchImageApp($fileName, $sequence, $editImage);
}

global proc EditTexture()
{
	// Need to run a test to make sure something is selected
	string $node[] = `ls -selection`;
	if (`size ($node)` < 1) {
		error (uiRes("m_hyperShadePanel.kSelectTextureNode"));
	}
	else if (`size ($node)` > 1) {
		warning (uiRes("m_hyperShadePanel.kMoreNodesSelected"));
	}

	// Need to run a test on the selected node to make sure we can sample it
	if (!(isClassified($node[0], "texture"))) {
		error (uiRes("m_hyperShadePanel.kOnlyTexturesNodesAcceptable"));
	}

	//Check whether node is of PSD type or file type
	if( ((nodeType ($node[0])) != "psdFileTex" ) && ((nodeType ($node[0])) != "file" ) )
	{
		error (uiRes("m_hyperShadePanel.kOnlyFileTypeNodesAcceptable"));
	}

	hyperShadeEditTexture( $node[0] );

}

// Description:  This procedure is called from the C++ code after
//      the icon size type has been changed.  We want to refresh
//      the hyper shade UI to show the new icon size.
//
global proc refreshHyperShadeAfterIconSizeChange(string $iconSizeName)
{
    string $panel = hyperShadePanelName();
    hyperShadePanelMenuCommand($panel, $iconSizeName);
}

// Description:  This procedure is called to activate the tabLayout
//      corresponding to the specified collectionUI.
//
global proc activateCorrespondingTabLayout(string $collectionUI)
{
    string $panel = hyperShadePanelName();

    string $correspondingTabLayout = lookupTabLayoutName($collectionUI);
    string $currentlyActiveTabLayout = activeTabLayout($panel);

    // Check to see if the corresponding tab is already active.
    //
    if ($correspondingTabLayout != $currentlyActiveTabLayout)
    {
        hyperShadePanelSetActiveTabLayout( $panel, $correspondingTabLayout, false);
    }
}

proc restorePaneSize(string $pane)
{
	if (`dockControl -exists $pane`)
	{
        string $panelSizeVar = $pane + "Width";
	    if (`optionVar -exists $panelSizeVar`)
	    {
	        int $size = `optionVar -q $panelSizeVar`;
	        dockControl -e -width $size $pane;
	    }
        
        $panelSizeVar = $pane + "Height";
	    if (`optionVar -exists $panelSizeVar`)
	    {
	        int $size = `optionVar -q $panelSizeVar`;
	        dockControl -e -height $size $pane;
	    }
	}
}

global proc setHyperShadePaneSizes(string $panel, string $workAreaPane)
//
//  Description:
//		Set the hyper shade panes to the proper size (based on either
//		saved or default values).
//
{
	// Make sure the workAreaPane still exists as it may have been deleted.
	if (!`paneLayout -exists $workAreaPane`) {
		return;
	}

	global string $gLookdevCreatePanel;
	global string $gLookdevBinsPanel;
	global string $gLookdevPropertyPanel;
	global string $gLookdevBrowserPanel;
	global string $gLookdevShaderballPanel;
	global string $gLookdevModelEditorPanel;
	global string $gLookdevSpreadsheetPanel;
	global string $gLookdevRenderViewPanel;
	global string $gLookdevOutlinerPanel;
	global string $gLookdevUVEditorPanel;
	global string $gLookdevGraphEditorPanel;

	// default proportion of the work area pane
	int $workAreaProportion = 50;

	if (`optionVar -exists hyperShadeWorkAreaProportion`)
	{
		$workAreaProportion = `optionVar -q hyperShadeWorkAreaProportion`;
	}
	else
	{
		optionVar -iv hyperShadeWorkAreaProportion $workAreaProportion;
	}

	paneLayout -e -paneSize 1 100 $workAreaProportion $workAreaPane;

	formLayout -e -manage false mainForm; 

    // now all the docking panels
	if (`optionVar -exists hyperShadeDockingLayout`)
	{  
		// restore all the docking layout information
	    string $dockStation = $panel + "dockStation";
        string $dockingLayout = `optionVar -q hyperShadeDockingLayout`;
        window -e -dockingLayout $dockingLayout $dockStation;

        restorePaneSize($gLookdevCreatePanel);
        restorePaneSize($gLookdevBinsPanel);
	    restorePaneSize($gLookdevPropertyPanel);    
	    restorePaneSize($gLookdevBrowserPanel);
	    restorePaneSize($gLookdevShaderballPanel);
	    restorePaneSize($gLookdevModelEditorPanel);
	    restorePaneSize($gLookdevSpreadsheetPanel);
		restorePaneSize($gLookdevRenderViewPanel);
		restorePaneSize($gLookdevOutlinerPanel);
		restorePaneSize($gLookdevUVEditorPanel);
		restorePaneSize($gLookdevGraphEditorPanel);
	}
    
    if (!`optionVar -exists hyperShadeBringCreatePanelToFront`)
    {
        //bring the create panel to the front the first time it is built.
        dockControl -edit -raise $gLookdevCreatePanel;
        optionVar -iv hyperShadeBringCreatePanelToFront 1;
    }
    
    evalDeferred("formLayout -e -manage true mainForm");
}

// Description:  This procedure is called to hide the specified window
//
global proc hideHypershadeWindow(string $window)
{
    if( `dockControl -exists $window` )
    {
		if (`dockControl -q -vis $window` != 0) {
			dockControl -edit -vis false $window;
		}
    }
};

global proc closeHypershade()
{
	string $hyperShadePanels[] = `getPanel -scriptType "hyperShadePanel"`;
	string $hyperShadePanel;
	for ($hyperShadePanel in $hyperShadePanels) {
		deleteUI -panel $hyperShadePanel;
	}
}

// Description: This procedure is called to restore the state of the panels
//      in Hypershade after a file-new operation is done. Some panel types are removed
//      by a file-new operation, so we make sure to restore them again here
//
global proc updateHyperShadePanelState()
{
	string $hyperShadePanels[] = `getPanel -scriptType "hyperShadePanel"`;
	if (size($hyperShadePanels) == 0) {
		return; // Nothing to update
	}

	string $panel = $hyperShadePanels[0];
	if (!`scriptedPanel -exists $panel`) {
		return; // Nothing to update
	}

	global string $gLookdevModelEditorPanel;
	global string $gLookdevOutlinerPanel;

	if( `dockControl -exists $gLookdevModelEditorPanel` )
	{
		string $theModelPanel = $gLookdevModelEditorPanel + "ModelPanel";
		if (!`modelPanel -exists $theModelPanel`)
		{
			hypershadeOpenModelEditorWindow($panel, false);
		}
	}

	if( `dockControl -exists $gLookdevOutlinerPanel` )
	{
		string $theOutlinerPanel = $gLookdevOutlinerPanel + "OutlinerPanel";
		if (!`outlinerPanel -exists $theOutlinerPanel`)
		{
			hypershadeOpenOutlinerWindow($panel, false);
		}
	}
}
