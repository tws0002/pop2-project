// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Description:
//
//		Creates a panel that contains the rendering window.
//		This file also contains a bunch of helper procedures related to the
//		rendering window.
//

// This file is organized in the following order.
//
// - Utility procedures used by other procedures in the file
// - Procedures called when menu commands are chosen
// - Procedures which generate the menus and refresh the menus each time the
// particular menu is opened
// - Procedures which call the menu generation procedures and create other
// user interface elements within the render view window or panel
// - Procedures which are accessed from outside the renderview
// - Procedures which support scripted panel capability
//
// Conventions:
//
// - $editor is the name of the scripted panel object which is the
// render view panel

global int $gIprTuningPaused = false;

global int $mrImrResolution0;
global int $mrImrResolution1;
global string $mrImrCamera;
global string $gRenderViewRenderTarget;
global int $gRenderViewRenderTargetNameChangeJob = -1;
global int $gRenderViewRenderTargetDeletedJob    = -1;
// Enums for setRenderViewRenderTarget().
global int $gRenderViewRenderTargetNormal       = 0;
global int $gRenderViewRenderTargetInNameChange = 1;
global int $gRenderViewRenderTargetInDelete     = 2;

// Images for render pass / render layer lock / unlock.
global string $gRenderPassLockUnlockImage[2] = {
  "renderPassLock.png", "renderPassUnlock.png" };

// Was the last render aborted (user interrupt or failure)? 
global int $gRenderViewRenderAborted = 0;

// Render target force dependencies render flag.  When this is true,
// dependencies of a render target will be rendered.  This is shown as
// "unlocked" render passes in the render view UI, and conversely
// "locked" render passes means do not render them (no dependency rendering).
global int $gRenderTargetForceDependenciesRender = 1; // "Unlocked"

//---------------------------------------------------------------------------//
// Utility procedures
//---------------------------------------------------------------------------//


//
// Description:
//		Sets all the option var specific to the render view.
//	- renderViewTestResolution: 0 => panel resolution.
//								1 => render settings.
//								2 => 10% render settings.
//								3 => 25% render settings.
//								4 => 50% render settings.
//								5 => 75% render settings.
//								6 => 110% render settings.
//								7 => 125% render settings.
//								8 => 150% render settings.
//	- renderViewAutoResize: boolean
//	- renderViewAutoRenderRegion: boolean.
//
global int $renderViewShadowsMode = 0;
global int $renderViewGlowPassMode = 0;
global int $renderViewResolutions[] = {
	0, 100, 10, 25, 50, 75, 110, 125, 150};
global proc setRenderOptionVars()
{
	if( !`optionVar -exists renderViewTestResolution` )
	{
		// Default value: 1 => render globals
		//
		optionVar -intValue renderViewTestResolution 1;
	}
	if( !`optionVar -exists renderViewAutoResize` )
	{
		optionVar -intValue renderViewAutoResize 1;
	}
	if( !`optionVar -exists renderViewRenderSelectedObj` )
	{
		optionVar -intValue renderViewRenderSelectedObj 0;
	}
	if( !`optionVar -exists renderViewRenderAllLayers` )
	{
		optionVar -intValue renderViewRenderAllLayers 0;
	}
	if( !`optionVar -exists renderViewRenderLayersMode` )
	{
		optionVar -intValue renderViewRenderLayersMode 0;
	}
	if( !`optionVar -exists renderViewAutoRenderRegion` )
	{
		optionVar -intValue renderViewAutoRenderRegion 0;
	}

	// For the long run, we should add a flag to the
	// renderWindowEditor which will allow us to associate
	// a file name with an image.
	// Also, we should make sure that each image in the
	// renderview buffer can have a name associated with it.
	// (code reivew comments from Josh, Sept. 15, Corina Wang)
	//
	if( !`optionVar -exists renderedImageName` )
	{
		optionVar -stringValue renderedImageName "test";
	}

    // IPR option variables which don't depend on the iprEngine
    //

	if( !`optionVar -exists iprRenderShading` )
	{
		optionVar -intValue iprRenderShading true;
	}
	if( !`optionVar -exists iprRenderShadowMaps` )
	{
		optionVar -intValue iprRenderShadowMaps true;
	}
	if( !`optionVar -exists iprRenderMotionBlur` )
	{
		optionVar -intValue iprRenderMotionBlur true;
	}
}

// Description:  This procedure returns true if IPR is running by
//  the current renderer, and false otherwise.
//
global proc int isRunningIpr()
{

    string $isRunningIprProc =
		`renderer -q -isRunningIprProcedure (currentRenderer())`;
	if ($isRunningIprProc !="" && eval($isRunningIprProc) )
    {
        return true;
    }
    return false;
}


//
// Description:
//		Returns the render window editor, creates it if needed.
//
proc string getRenderWindowPanel()
{

	string $renderPanel;
	string $renderPanels[] = `getPanel -scriptType "renderWindowPanel"`;

	if( size($renderPanels) == 0 )
	{
		$renderPanel = `scriptedPanel -type "renderWindowPanel" -unParent`;
		scriptedPanel -e -label `interToUI $renderPanel` $renderPanel;
	}
	else
	{
		$renderPanel = $renderPanels[0];
	}

	return $renderPanel;
}

proc initializeIprOptionVars(string $iprEngine)
//
// Description:
//		Sets all the option vars specific to IPR.
//
{

	//
	//	Set the options variables.
	//
	if( !`optionVar -exists updateShadingAndLighting` )
	{
		optionVar -intValue updateShadingAndLighting 1;
	}
	if( !`optionVar -exists updateLightGlow` )
	{
		optionVar -intValue updateLightGlow 1;
	}
	if( !`optionVar -exists updateShaderGlow` )
	{
		optionVar -intValue updateShaderGlow 1;
	}
	if( !`optionVar -exists updateMotionBlur` )
	{
		optionVar -intValue updateMotionBlur 1;
	}

	// Set the state on the engine.
	//
	iprEngine -edit
		-updateShading      `optionVar -query updateShadingAndLighting`
		$iprEngine;

	iprEngine -edit
		-updateLightGlow 	`optionVar -query updateLightGlow`
		$iprEngine;

	iprEngine -edit
		-updateShaderGlow 	`optionVar -query updateShaderGlow`
		$iprEngine;

	iprEngine -edit
		-updateMotionBlur 	`optionVar -query updateMotionBlur`
		$iprEngine;
}

global proc updateIPRMemoryEstimate()
{

	string $displayedMemory = "IPR: ";

	if (isIprFileLoaded()) {
		string $memEstimate[] =
			`iprEngine -q -estimatedMemory defaultIprEngine`;

		if ($memEstimate[0] == "0MB") {
			// Prompt the user to select a region to begin tuning
			//
			renderWindowEditor
				-edit
				-caption (uiRes("m_renderWindowPanel.kSelectaregionCaption"))
				`getRenderWindowPanel`;
		}

		$displayedMemory = ($displayedMemory + $memEstimate[0]);
	} else {
		$displayedMemory = ($displayedMemory + "0MB");
	}

	text -edit -label $displayedMemory iprMemEstText;
}

proc beginIprSession(string $editor)
{

	if (!`iprEngine -query -exists defaultIprEngine`)
	{
		// Create an IPR engine
		//
		iprEngine defaultIprEngine;

		// Set the state on this engine using optionVars.
		initializeIprOptionVars "defaultIprEngine";
	}
}

proc int isImageLoaded(string $editor)
{

	return (`renderWindowEditor -query -nbImages $editor` != -1);
}

proc string changeWorkspaceDir(string $newDirType)
{
	string	$rootDir			= `workspace -query -rootDirectory`;
	string	$currentDir			= `workspace -query -directory`;
	string	$renderDirs[]		= `workspace -query -fileRule`;
	string	$newDir				= $currentDir;
	int		$setDir				= false;

	global string $gDirRetainingOptionVar;
	$gDirRetainingOptionVar = "browserLocationForRenderView";

	// Set the directory path to the remembered location
	//
	if( `optionVar -exists browserLocationForRenderView` ){
		// Set to this path.
		$newDir = `optionVar -q browserLocationForRenderView`;
		if (`file -q -ex $newDir`) {
			if (!catch(`workspace -dir $newDir`)) {
				$setDir = true;
			}
		}
	}

	if( !$setDir ){
		int $i;
	for ($i = 0; $i < size($renderDirs); $i += 2)
		{
			if ($renderDirs[$i] == $newDirType)
			{
				$newDir = $renderDirs[$i+1];
			}
		}

	workspace -directory $rootDir;
		workspace -directory $newDir;
	}
	return $currentDir;
}

// Description:  Get the test resolution for the current renderer.
//
proc int[] getTestResolution( string $panel )
{

	int		$res[2] = { 640, 480 };

	if( `optionVar -exists renderViewTestResolution` )
	{
		int $testRes = `optionVar -query renderViewTestResolution`;

		if( $testRes == 0 )
		{
			if( size($panel) )
			{
				string	$modelViewControl = getCustomViewEditorFromPanel( $panel );
				if (size($modelViewControl) == 0)
				{
					// Fix a bug where a non model panel can be passed over.
					if (`modelPanel -q -exists $panel`)
						$modelViewControl = `modelEditor -q -control $panel`;
				}

				if(size($modelViewControl) && `control -ex $modelViewControl`)
				{
					$res[0] = `control -q -w $modelViewControl`;
					$res[1] = `control -q -h $modelViewControl`;
				}
			}
		}
		else
		{
			global int $renderViewResolutions[];

            // Get the width and height.
            //
            $res[0] = `getAttr defaultResolution.width`;
            $res[1] = `getAttr defaultResolution.height`;

            if ($testRes > 1)
            {
                $res[0] *= $renderViewResolutions[$testRes];
                $res[1] *= $renderViewResolutions[$testRes];
                $res[0] /= 100;
                $res[1] /= 100;
            }
		}
	}


	return $res;
}

proc string getRenderWindowPanelFormLayout()
{
	string	$panel[] = `getPanel -scriptType "renderWindowPanel"`;
	return `renderWindowEditor -query -parent $panel[0]`;
}

//
// Description: Returns the current camera rig name if any
//
global proc string getCurrentCameraRig()
{
	string	$renderPanel = `getRenderWindowPanel`;
	string	$cameraRig = `renderWindowEditor -q -currentCameraRig $renderPanel`;
	return $cameraRig;
}

//
// Description:
//		Returns the current camera stored by the render window editor.
//	returns the current camera view if nothing stored in the render view or
//	the first camera.
//
global proc string getCurrentCamera()
{
	string	$renderPanel = `getRenderWindowPanel`;
	string	$camera = `renderWindowEditor -q -currentCamera $renderPanel`;

	if( !size($camera) )
	{
		//
		//	So gets the current camera.
		//
		string $currentPanel = `getPanel -wf`;

		string $stereoEditor = getCustomViewEditorFromPanel( $currentPanel );
		if (size($stereoEditor))
		{
			$camera = `modelPanel -q -cam $stereoEditor`;
		}
		else if( `modelPanel -exists $currentPanel` )
		{
			$camera = `modelPanel -q -cam $currentPanel`;
		}
		else
		{
			// Since we have to make a guess at what camera to use, we'll
			// first guess that it's something typical (namely: persp).
			// If that's not a good guess, we'll just guess that it's the
			// first camera in the scene.
			//
			int $useFirstCamera = true;

			string $defCameras[] = `ls persp|perspShape`;
			if (size($defCameras) > 0) {
				string $defCamera = $defCameras[0];
				if (`objectType -isa "camera" $defCamera`) {
					$camera = $defCamera;
					$useFirstCamera = false;
				}
			}

			if ($useFirstCamera) {
				string	$cameras[] = `ls -cameras`;
				$camera = $cameras[0];
			}
		}
	}

	return $camera;
}

proc string getCameraPanel( string $camera  )
{
	string	$cameraPanel;

	for( $modelPanel in `getPanel -type "modelPanel"` )
	{
		$cameraPanel = `modelPanel -q -cam $modelPanel`;

		if( $cameraPanel == $camera )
		{
			return $modelPanel;
		}
	}

	// Check for a camera rig panels (scriptedPanel) if we can't find the camera in
	// a modelPanel.
	//
	string $camList[] = `getMultiCameraRenderList( $camera )`;
	if (size($camList) < 2)
		$camList = `getMultiCameraChildren( $camera )`;
	if (size($camList) > 1)
	{
            string $stereoPanel = getCustomViewEditorFromPanel( "StereoPanel" );
		return $stereoPanel;
	}

	string	$null = "";
	return $null;
}

//
// Description:
//	Raise the render view window if exists, then return 1.
//	Return 0 otherwise.
//
proc int raiseRenderViewWindow()
{
	//
	//	Look for the renderViewWindow and pop it up if it exists.
	//
	for( $i in `lsUI -windows` )
	{
		if( $i == "renderViewWindow" )
		{
			showWindow $i;
			return 1;
		}
	}

	return 0;
}

proc string showRenderView()
{
	// Ensures that the Render View is displayed.
	// If the Render View is currently torn-off in a window, the window is
	// brought forward. If the Render View does not exist in a torn-off window
	// nor in a panel, it is created in a torn-off window.
	//
	// Returns the name of the render view.
	//

	string $editor;

	$editor = `getRenderWindowPanel`;

	if( `raiseRenderViewWindow` == 1 )
	{
		// The Render View exists and is in a torn-off window. It has been
		// brought to the front.
		//
		return $editor;
	}

	// If we get to here, the Render View is not in a torn-off window
	//
	for( $i in `getPanel -vis` )
	{
		if( $i == $editor )
		{
			// The Render View exists and is in a panel.
			//
			return $editor;
		}
	}

	// If we get to here, the Render View is not currently in a panel nor is
	// it in a torn-off window.
	//
	scriptedPanel -edit -tearOff $editor;

	return $editor;
}

proc int isToolbarDisplayed ()
{
	if ( !`optionVar -exists renderViewDisplayToolbar` )
	{
		optionVar -intValue renderViewDisplayToolbar 1;
	}
	return `optionVar -query renderViewDisplayToolbar`;
}

proc displayToolbar (int $display)
{
	optionVar -intValue renderViewDisplayToolbar $display;
}

proc toggleDisplayToolbar()
{
	displayToolbar( ! isToolbarDisplayed());
}

//---------------------------------------------------------------------------//
// Procedures which are called when menu items are chosen
//---------------------------------------------------------------------------//

proc loadImage(string $editor)
{
	string $callbackCmd;
	$callbackCmd = ("renderWindowLoadImageCallback \"" + $editor + "\"");

	string $prevDir = changeWorkspaceDir("images");

	// 0 for a read browser
	//
	string $loadImage = (uiRes("m_renderWindowPanel.kLoadImage"));
	fileBrowser $callbackCmd  $loadImage  "image" 0;

	changeWorkspaceDir($prevDir);
}

global proc int renderWindowLoadImageCallback(
	string $editor,
	string $fileName,
	string $fileType)
{
	string $currentDir = `workspace -q -dir`;
	retainWorkingDirectory $currentDir;

	// Called by the file browser with the name and type of the file the user
	// has chosen
	//
	if ($fileName != "")
	{
		renderWindowEditor -edit -loadImage $fileName $editor;
	}

	// Return 1 to close the file browser
	//
	return 1;
}

proc saveImage(string $editor)
{
	string $callbackCmd;
	$callbackCmd = ("renderWindowSaveImageCallback \"" + $editor + "\"");

	string $prevDir = changeWorkspaceDir("images");
	string $workspace = `workspace -q -dir`;

	string $saveImage = (uiRes("m_renderWindowPanel.kSaveImageLabel"));
	int $fileMode = 0;

	string $options[] = fileBrowserActionSetup("image", $fileMode);

	// ADSK_CLR_MGT_BEGIN

	// $options[2] is the list of image formats that IMF plug-ins support.
	// We append extra image formats that our HDR image writer support.
	// OpenEXR is not handled via IMF plug-ins.
	$options[2] = $options[2] + ";;OpenEXR (*.exr)";

	// ADSK_CLR_MGT_END

	string $fileCmd = ("fileDialog2 ");
	$fileCmd += (" -caption \"" + $saveImage + "\"");
	$fileCmd += (" -okCaption \"" + $options[0] + "\"");
	$fileCmd += (" -fileMode " + $fileMode);
	$fileCmd += (" -startingDirectory \"" + $workspace + "\"");
	$fileCmd += (" -returnFilter 1");
	$fileCmd += (" -fileFilter \"" + $options[2] + "\"");
	$fileCmd += (" -selectFileFilter \"" + $options[1] + "\"");
	$fileCmd += (" -optionsUICreate \"saveImageOptionsCreate\"");
	$fileCmd += (" -optionsUICommit \"setRenderViewSaveMode\"");

	if (!`exists saveImageOptBox`)
	{
		source saveImageOptBox;
	}

	string $file[] = `eval $fileCmd`;
	if (0 < size($file) && "" != $file[0])
	{
		string $path = fromNativePath($file[0]);
		string $cmd = ($callbackCmd + "\"" + $path + "\"");

		if (1 < size($file) && "" != $file[1])
		{
			string $filterType = filterDescriptionToFileType($file[1]);
			$cmd += (" \"" + $filterType + "\"");
		}
		else
		{
			$cmd += (" \"\"");
		}

		eval $cmd;
	}

	changeWorkspaceDir($prevDir);
}

global proc int renderWindowSaveImageCallback(
	string $editor,
	string $fileName,
	string $fileType)
{
	string $currentDir = `workspace -q -dir`;
	retainWorkingDirectory $currentDir;

	// Called by the file browser with the name and type of the file the user
	// has chosen
	//
	if ($fileName != "")
	{
		optionVar -stringValue lastSaveImageAsFileType $fileType;

		// ADSK_CLR_MGT_BEGIN
		// This will temporarily override the image format attributes on the
		// render global node. Our HDR image writer relies on these info to
		// decide the HDR image format.
		int    $overrideImageFormat = 0;
		string $overrideIMFKey;

		// OpenEXR is not handled via IMF plug-ins.
		if ($fileType == "OpenEXR")
		{
			$overrideImageFormat = 51;
			$overrideIMFKey      = "exr";
		}
		// ADSK_CLR_MGT_END

		python("import maya.app.general.createImageFormats as createImageFormats");
		python("formatManager = createImageFormats.ImageFormats()");
		python(("formatManager.pushRenderGlobalsForDesc(\"" + $fileType + "\")"));

        int $mode = 0;
        if( `optionVar -exists renderViewSaveMode` )
        {
            $mode = `optionVar -q renderViewSaveMode`;
        }

		// ADSK_CLR_MGT_BEGIN
		if ($overrideImageFormat > 0)
		{
			setAttr defaultRenderGlobals.outf $overrideImageFormat;
			setAttr -type "string" defaultRenderGlobals.imfkey $overrideIMFKey;
		}
		// ADSK_CLR_MGT_END

        if ($mode == 1)
        {
		    renderWindowEditor -edit -colorManage -writeImage $fileName $editor;
        }
        else
        {
		    renderWindowEditor -edit -writeImage $fileName $editor;
        }

		python("formatManager.popRenderGlobals()");
	}

	// Return 1 to close the file browser
	//
	return 1;
}

proc loadIprFile(string $editor)
{
	string $callbackCmd;
	$callbackCmd = ("renderWindowLoadIprFileCallback \"" + $editor + "\"");

	string $prevDir = changeWorkspaceDir("iprImages");

	// 0 for a read browser
	//
	string $loadIPRFile = (uiRes("m_renderWindowPanel.kLoadIPRFile"));
	fileBrowser $callbackCmd  $loadIPRFile  "iff" 0;

	changeWorkspaceDir($prevDir);
}

global proc int renderWindowLoadIprFileCallback(
	string $editor,
	string $fileName,
	string $fileType)
{
	string $currentDir = `workspace -q -dir`;
	retainWorkingDirectory $currentDir;

	// Called by the file browser with the name and type of the file the user
	// has chosen
	//
	if ($fileName != "")
	{
		// Now that we have an IPR file, we can enable IPR
		//
		beginIprSession($editor);

		// Register the file with the IPR engine
		//
		iprEngine -edit -iprImage $fileName defaultIprEngine;

		// Prompt the user to select a region to begin tuning
		//
		renderWindowEditor
			-edit
			-caption (uiRes("m_renderWindowPanel.kSelectaregionCaption"))
			$editor;

		// Update UI which needs to be changed
		//
		renderWindowRefreshLayout($editor);
		renderWindowRefreshMenu("file", $editor);
		renderWindowRefreshMenu("ipr", $editor);
	}

	// Return 1 to close the file browser
	//
	return 1;
}

proc saveIprFile(string $editor)
{
	string $callbackCmd;
	$callbackCmd = ("renderWindowSaveIprFileCallback \"" + $editor + "\"");

	string $prevDir = changeWorkspaceDir("iprImages");
	string $workspace = `workspace -fn`;

	// 1 for a write browser
	//
	string $saveIPRFile = (uiRes("m_renderWindowPanel.kSaveIPRFileLabel"));
	fileBrowser $callbackCmd  $saveIPRFile  "iff" 2;

	changeWorkspaceDir($prevDir);
}

global proc int renderWindowSaveIprFileCallback(
	string $editor,
	string $inFileName,
	string $fileType)
{
	string $currentDir = `workspace -q -dir`;
	retainWorkingDirectory $currentDir;

	// Called by the file browser with the name and type of the file the user
	// has chosen
	//
	if ($inFileName != "")
	{
        // Expand the filename to its full name.
        string $fileName = `workspace -expandName $inFileName`;

		if (isIprFileLoaded()) {
			// copy the current ipr file to the specified fileName
			iprEngine -edit -copy $inFileName defaultIprEngine;
		}
	}

	// Return 1 to close the file browser
	//
	return 1;
}

// Description:  This procedure is called to refresh the IPR specific
//  UIs which needs to be enabled or disabled when IPR starts or stops
//  running.
//
global proc refreshIprRelatedUI(string $panel)
{
    // Refresh the IPR related buttons.
    //
	if (isRunningIpr() ) {
		text -edit -enable true iprMemEstText;
		iconTextButton -edit
				-enable true
				-annotation (uiRes("m_renderWindowPanel.kCloseIPRfilestoptuningAnnot"))
				closeIprButton;

        global int $gIprTuningPaused;
		iconTextCheckBox -edit
				-enable true
		        -value $gIprTuningPaused
				-annotation (uiRes("m_renderWindowPanel.kPauseIPRtuningRefreshAnnot"))
				pauseIprButton;

        string $renUIName = `renderer -query -rendererUIName (currentRenderer())`;
		string $iprImageAnnot = (uiRes("m_renderWindowPanel.kRefreshtheIPRimage"));

		iconTextButton -edit
				-enable (!$gIprTuningPaused)
				-annotation (`format -s $renUIName $iprImageAnnot`)
				refreshIprButton;
	} else {
		text -edit -enable false iprMemEstText;
		iconTextButton -edit -enable false -annotation "" closeIprButton;
		iconTextButton -edit -enable false -annotation "" refreshIprButton;
		iconTextCheckBox -edit -enable false -value false -annotation ""
			pauseIprButton;
	}

    // Refresh the IPR related menus.
    //
	renderWindowRefreshMenu("ipr",$panel);
}

// Description:  This procedure is called to pause the Ipr
//  rendering for the current renderer.
//
global proc renderViewTogglePauseIpr (string $editor)
{
	global int $gIprTuningPaused;

	int $newVal = !$gIprTuningPaused;
    string $pauseIprProc = `renderer -q -pauseIprRenderProcedure (currentRenderer())`;
    eval $pauseIprProc $editor $newVal;

    $gIprTuningPaused = $newVal;

	// Issue a refresh so that the pause button on the toolbar is properly
	// updated.
	//
    refreshIprRelatedUI($editor);
}

// Helper function to encapsulate render target dependency rendering.
// This procedure can change the current render target and render
// layer, so callers should save and restore them around this call.
proc string renderTargetDependencyRender(
  string $renderTarget,
  string $renderLayer,
  string $editor,
  string $camera,
  int $resolution[], 
  int $doShadows, 
  int $doGlowPass,
  string $global
)
{
  global string $gRenderViewRenderTarget;
  global int $gRenderViewRenderAborted;
  string $result;

  string $tasks[] = `getRenderTasks -c $camera -rl $renderLayer $renderTarget`;

  $gRenderViewRenderAborted = 0;
  string $task;
  for ($task in $tasks) {
    if ($gRenderViewRenderAborted) {
      break;
    }

    python("task = " + $task);
    $gRenderViewRenderTarget = python("task['renderTarget']");
    string $taskCamera = python("task['camera']");
    string $taskRenderLayer = python("task['renderLayer']");
    editRenderLayerGlobals("-currentRenderLayer", $taskRenderLayer);
    // Render all layers flag was designed to facilitate the old Maya
    // render layer compositing.  With render targets and compositing
    // graphs, the user clearly expresses which render layers to render.
    // Therefore, turn the unconditional rendering of all render layers off.
    $result = mayaPreviewRender(
      0, $editor, $taskCamera, $resolution, $doShadows, $doGlowPass, $global);
  }

  return $result;
}

global proc setRenderTargetForceDependenciesRender(int $value)
{
  global string $gRenderPassLockUnlockImage[];
  global int $gRenderTargetForceDependenciesRender;
  $gRenderTargetForceDependenciesRender = $value;
  iconTextButton -edit -i1
    $gRenderPassLockUnlockImage[$gRenderTargetForceDependenciesRender]
    renderPassLockUnlockButton;
}

proc int getRenderTargetForceDependenciesRender()
{
  global int $gRenderTargetForceDependenciesRender;
  return $gRenderTargetForceDependenciesRender;
}

global proc toggleRenderTargetForceDependenciesRender()
{
  setRenderTargetForceDependenciesRender(
    !getRenderTargetForceDependenciesRender());
}

global proc renderWindowRenderCamera(
	string 	$renderMode,
	string 	$editor,
	string 	$camera)
{
	global int $renderViewShadowsMode;
	global int $renderViewGlowPassMode;

	// Ensure we have someplace to render to...
	//
	if ($editor == "")
	{
		$editor = `showRenderView`;
	}

	// Cancel the Hypershade snapshot if it is still going
	//
	if (`renderWindowEditor -query -snapshotMode $editor`) {
		renderWindowMenuCommand("grabSwatch", $editor);
	}

    // If the current renderer was in IPR mode, then stop previous IPR.
    //
    if (isRunningIpr())
    {
        // Stop previous IPR.
        //
        stopIprRendering($editor);
    }

	// Valid arguments for renderMode are:
	// "redoPreviousRender", "renderRegion", "render", "snapshot",
	// "redoPreviousIprRender", or "iprRender".

	// Determine the camera to render from.
	//
	// If the camera to render from has not been specified, we
	// render from the current camera.
	//
	int $emptyCameraName = 0;
	if ($camera == "")
	{
		$emptyCameraName = 1;
		$camera 	= `getCurrentCamera`;
	}

	// disable render view blending
	renderWindowEditor -e -blendMode -1 $editor;
	renderWindowEditor -e -compDisplay 0 $editor;
	

	string	$cameraPanel	= `getCameraPanel( $camera )`;
	int 	$resolution[] 	= `getTestResolution( $cameraPanel )`;
	string	$globals[] 		= `ls -renderGlobals`;

	// Save the current render region setting of the render settings
	//
	int 	$prevUseRenderRegion =
		`getAttr ($globals[0] + ".useRenderRegion")`;

	// Determine the resolution to render at.
	//
	if ( ($renderMode == "renderRegion") 
		)
	{
		setAttr ($globals[0] + ".useRenderRegion") true;

		//
		//	Show the region.
		//
		    renderWindowEditor
			    -edit
			    -showRegion $resolution[0] $resolution[1]
			    $editor;
	}
	else
	{
		setAttr ($globals[0] + ".useRenderRegion") false;
	}

	setAttr defaultRenderGlobals.renderAll
		(!`optionVar -q renderViewRenderSelectedObj`);

	// Perform the render
	//
	string $result;

	if ($renderMode == "snapshot")
	{
		renderWindowTakeSnapshot( $resolution[0], $resolution[1], $camera );
	}
    else if (($renderMode == "iprRender")
             || ($renderMode == "redoPreviousIprRender"))
    {
        // Check if the current renderer supports IPR or not.
        //
        if (`renderer -q -iprRenderProcedure (currentRenderer())` != "")
        {
			// If IPR rendering reset view count to 1. And reset current
			// camera set to be empty.
			renderWindowEditor -edit -viewImageCount 1 $editor;
			renderWindowEditor -e -currentCameraRig "" $editor;

			// Suspend material view renderer while IPR is running
			// It is resumed again in stopIprRendering.mel
			renderer -materialViewRendererSuspend true;

            string $startIprProc = `renderer -q -startIprRenderProcedure (currentRenderer())`;
            eval $startIprProc $editor $resolution[0] $resolution[1] $camera;

            // Turn off pause tuning.
            //
	        global int $gIprTuningPaused;
            $gIprTuningPaused = false;
            string $pauseIprProc = `renderer -q -pauseIprRenderProcedure (currentRenderer())`;
            eval $pauseIprProc $editor $gIprTuningPaused;

            refreshIprRelatedUI($editor);
        }
        else
        {
            string $renUIName = `renderer -query -rendererUIName (currentRenderer())`;
            string $currRenderWarn = (uiRes("m_renderWindowPanel.kCurrRenderWarnin"));
			warning (`format -s $renUIName $currRenderWarn`);
        }
    }
	else
	{
	    int $prevCreateIprFile = `getAttr ($globals[0] + ".createIprFile")`;
	    setAttr ($globals[0]+".createIprFile") false;

		int $useLayers = 0;
		if (`optionVar -exists renderViewRenderAllLayers` )
			$useLayers = `optionVar -q renderViewRenderAllLayers`;

		// If this is a stereo camera, render multiple times. Otherwise
		// render only once. The view image count *must* reset to notify
		// whether we are doing multi-camera rendering or not.
		//

		// Override the current camera with the camera rig name,
		// if not explicit camera was set.
		if ($emptyCameraName)
		{
			string $camRig = `renderWindowEditor -q -currentCameraRig $editor`;
			if (size($camRig))
				$camera = $camRig;
		}

		string $clist[];
		// If camera is a child of the current camera rig then use
		// the camera rig instead of the child.
		//
		//string $camRig = `renderWindowEditor -q -currentCameraRig $editor`;
		//if (size($camRig))
		//{
		//	$clist = `getMultiCameraChildren( $camRig )`;
		//	int $exists = stringArrayContains( $camera, $clist );
		//	if ($exists != 0)
		//	{
		//		$camera = $camRig;
		//	}
		//}

		$clist = `getMultiCameraChildren( $camera )`;
		int $i, $cCount = size($clist);

        // If the user has specified a render target without an input
        // connection, tell them about it.
        string $rt = getRenderViewRenderTarget();
        renderTargetWarnIfNoInput($rt);

        // If we have a render target and render target force
        // dependencies rendering is on, get render jobs for the
        // render target and execute them.
        if ($rt != "" && getRenderTargetForceDependenciesRender()) {

          // Store the original render target and layer, to restore them later.
          string $renderLayer = `editRenderLayerGlobals -q -currentRenderLayer`;
          string $oldRenderTarget = $rt;

          if ( $cCount == 2 )
            {
              renderWindowEditor -edit -viewImageCount 2 $editor;
              renderWindowEditor -e -resetViewImage $editor;
              renderWindowEditor -e -currentCameraRig $camera $editor;

              $result = renderTargetDependencyRender(
                $oldRenderTarget, $renderLayer, $editor, $clist[0],
                $resolution, !$renderViewShadowsMode, !$renderViewGlowPassMode,
                $globals[0]);
              renderWindowEditor -e -nextViewImage $editor;
              $result = renderTargetDependencyRender(
                $oldRenderTarget, $renderLayer, $editor, $clist[1],
                $resolution, !$renderViewShadowsMode, !$renderViewGlowPassMode,
                $globals[0]);
            }
          else
            {
              renderWindowEditor -edit -viewImageCount 1 $editor;
              renderWindowEditor -e -currentCameraRig "" $editor;

              $result = renderTargetDependencyRender(
                $oldRenderTarget, $renderLayer, $editor, $camera,
                $resolution, !$renderViewShadowsMode, !$renderViewGlowPassMode,
                $globals[0]);
            }
          // Restore the original render layer and render target.
          // Do this without setRenderViewRenderTarget(), as we are
          // simply restoring state to what it was before the render
          // and don't want to affect render target callbacks.
          $gRenderViewRenderTarget = $oldRenderTarget;
          editRenderLayerGlobals("-currentRenderLayer", $renderLayer);
        }
        else
        {
          if ( $cCount == 2 )
            {
              renderWindowEditor -edit -viewImageCount 2 $editor;
              renderWindowEditor -e -resetViewImage $editor;
              renderWindowEditor -e -currentCameraRig $camera $editor;
              $result = mayaPreviewRender($useLayers, $editor, $clist[0], $resolution, !$renderViewShadowsMode, !$renderViewGlowPassMode, $globals[0]);
              renderWindowEditor -e -nextViewImage $editor;
              $result = mayaPreviewRender($useLayers, $editor, $clist[1], $resolution, !$renderViewShadowsMode, !$renderViewGlowPassMode, $globals[0]);
            }
          else
            {
              renderWindowEditor -edit -viewImageCount 1 $editor;
              renderWindowEditor -e -currentCameraRig "" $editor;
              $result = mayaPreviewRender($useLayers, $editor, $camera, $resolution, !$renderViewShadowsMode, !$renderViewGlowPassMode, $globals[0]);
            }
        }
		setAttr ($globals[0] + ".createIprFile") $prevCreateIprFile;
	}

	optionVar -stringValue renderedImageName $result;

	// Reset the render region setting
	//
	setAttr ($globals[0] + ".useRenderRegion") $prevUseRenderRegion;
}

global proc renderWindowRender(
	string 	$renderMode,
	string 	$editor)
{
	renderWindowRenderCamera($renderMode, $editor, "");
}


// 
//  Return whether VP2 is used as renderer for current active viewport. 
//	If an active viewport can't be found, check the default viewport setting in the preferences
//
global proc int isActiveViewViewport20()
{
	global string $gMainPane;
	int $activeViewFound = 0;
	int $useVP2 = 0;
	
	//
	//  First try to find the active viewport
	//
	if ($gMainPane != "") 
	{
		$mainPaneCtls = `paneLayout -q -ca $gMainPane`;
		$nArr = size($mainPaneCtls);
		for ($i = 0; $i < $nArr; $i++) 
		{
			$panelName = `getPanel -containing $mainPaneCtls[$i]`;
			if ("" != $panelName) 
			{
				if ("modelPanel" == `getPanel -to $panelName`) 
				{
					$obscured = `control -q -io $mainPaneCtls[$i]`;
					if (!$obscured) 
					{
						$modelEd = `modelPanel -q -modelEditor $panelName`;
						if (`modelEditor -q -activeView $modelEd`)
						{
							$activeViewFound = 1;

							string $rendererUsed = `modelEditor -q -rnm $modelEd`;
							$useVP2 = (`strcmp $rendererUsed "vp2Renderer"` == 0);

							break;
						}
					}
				}
			}
		}
	}

	if (!$activeViewFound)
	{
		$defaultRenderer = `optionVar -q viewportRenderer`;
		$useVP2 = ($defaultRenderer == 2);
	}

	return $useVP2;
}

//
// Description:
//		Take a snapshot by creating a temporary model editor whithin the
//	render view window.
//
global proc renderWindowTakeSnapshot
 ( int		$resX,
   int		$resY,
   string	$camera )
{
	//
	//	Raise the render view in case it's partially covered.
	//
	raiseRenderViewWindow;

	string	$prevParent = `setParent -q`;
	string	$mainForm = `getRenderWindowPanelFormLayout`;

	setParent $mainForm;

	int		$formX = `formLayout -q -w $mainForm`;
	int		$formY = `formLayout -q -h $mainForm`;
	float	$snapX = $resX;
	float	$snapY = $resY;

	//
	//	TODO: Not very clean, to be improved.
	//
	while( $snapX > $formX )
	{
		$snapX *= 0.8;
		$snapY *= 0.8;
	}

	while( $snapY > $formY )
	{
		$snapX *= 0.8;
		$snapY *= 0.8;
	}

	int	$right = ($formX - $snapX);
	int	$bottom = ($formY - $snapY);

	//
	//	Create the model editor at the right size and take a snapshot.
	//
	modelEditor renderWindowTMPModelEditor;

	formLayout -e -af renderWindowTMPModelEditor left 0 $mainForm;
	formLayout -e -af renderWindowTMPModelEditor right $right $mainForm;
	formLayout -e -af renderWindowTMPModelEditor top 0 $mainForm;
	formLayout -e -af renderWindowTMPModelEditor bottom $bottom $mainForm;
	
	int $useVP2 = isActiveViewViewport20();

	// Switch to use VP2 if required
	if ($useVP2)
	{
		setRendererInModelPanel vp2Renderer renderWindowTMPModelEditor;
		string $rendererUsed = `modelEditor -q -rnm renderWindowTMPModelEditor`;
		// Check whether VP2 is successfully set
		$useVP2 = (`strcmp $rendererUsed "vp2Renderer"` == 0);
	}

	string	$renderPanel = `getRenderWindowPanel`;

	// If camera is a child of the current camera rig then use
	// the camera rig instead of the child.
	//
	string $camRig = `renderWindowEditor -q -currentCameraRig $renderPanel`;
	string $clist[];
	if (size($camRig))
	{
		$clist = `getMultiCameraChildren( $camRig )`;
		int $exists = stringArrayContains( $camera, $clist );
		if ($exists != 0)
		{
			$camera = $camRig;
		}
	}

	$clist = `getMultiCameraChildren( $camera )`;
	int $i, $cCount = size($clist);
	if ($cCount > 2) $cCount = 2;

	for ($i=0; $i<$cCount; $i++)
	{
		string $snapCamera = $clist[$i];

		//
		//	Unset camera gates, shaded gate display and reset overscan to 1.
		//
		int		$dfg = `camera -q -displayFilmGate $snapCamera`;
		int		$dr = `camera -q -displayResolution $snapCamera`;
		float	$os = `camera -q -overscan $snapCamera`;
		int		$dgm = `camera -q -displayGateMask $snapCamera`;

		camera -e -displayFilmGate off -displayResolution off -displayGateMask off -overscan 1.0 $snapCamera;

		//
		//	Set the right camera to the model editor.
		//
		modelEditor -e -cam $snapCamera renderWindowTMPModelEditor;

		//
		//	Ask the render window editor to take the snapshot of the given
		//	modelEditor at the given resolution.
		//
		if ($i == 0)
		{
			renderWindowEditor -edit -viewImageCount $cCount $renderPanel;

			if ($cCount > 1)
			{
				renderWindowEditor -e -resetViewImage $renderPanel;
				renderWindowEditor -e -currentCameraRig $camera $renderPanel;
			}
			else
			{
				renderWindowEditor -e -currentCameraRig "" $renderPanel;
			}
		}
		else
		{
			renderWindowEditor -e -nextViewImage $renderPanel;
		}

			// Bug 340452. We need to force a refresh here in order to be sure
			// the temporary model editor is ready for a snapshot.
			refresh;
		// Take the snapshot
		renderWindowEditor -e -snp renderWindowTMPModelEditor $resX $resY $renderPanel;

		//
		//	Restore camera settings.
		//
		camera -e -displayFilmGate $dfg -displayResolution $dr -displayGateMask $dgm -overscan $os $snapCamera;
	}
	setParent $mainForm;
	deleteUI -ed renderWindowTMPModelEditor;

	//
	//	Restore parent state.
	//
	setParent $prevParent;
}

global proc showRenderGlobals()
{
    string $globals[] = `ls -renderGlobals`;
    showEditor $globals[0];
}



global proc switchAutoRenderRegionVar()
{
	int $var = 0;
	if( `optionVar -exists renderViewAutoRenderRegion` ) {
		$var = (! `optionVar -q renderViewAutoRenderRegion`);
	}
	optionVar -intValue renderViewAutoRenderRegion $var;
}

global proc switchSelectObj()
{
	int $var = 0;
	if( `optionVar -exists renderViewRenderSelectedObj` ) {
		$var = (! `optionVar -q renderViewRenderSelectedObj`);
	}
	optionVar -intValue renderViewRenderSelectedObj $var;
}


global proc switchAutoResizeVar( string $editor )
{
	int $var = 1;
	if( `optionVar -exists renderViewAutoResize` ) {
		$var = (! `optionVar -q renderViewAutoResize`);
	}
	optionVar -intValue renderViewAutoResize $var;
	renderWindowEditor -e -ar $var $editor;
}

global proc switchShadowsVar( string $editor )
{
	global int $renderViewShadowsMode;
	$renderViewShadowsMode = (! $renderViewShadowsMode);
}

global proc switchGlowPassVar( string $editor )
{
	global int $renderViewGlowPassMode;
	$renderViewGlowPassMode = (! $renderViewGlowPassMode) ;
}

global proc setTestResolutionVar( int $choice )
{
	global int $renderViewResolutions[];
	if( `optionVar -exists renderViewTestResolution` &&
		$choice >= 0 && $choice < size($renderViewResolutions) )
	{
		optionVar -intValue renderViewTestResolution $choice;
	}
	else
	{
		//
		//	Default is panel resolution.
		//
		optionVar -intValue renderViewTestResolution 1;
	}
}

global proc renderWindowMenuCommand(string $command, string $editor)
//
// This procedure acts as a command dispatcher. It is the single global
// procedure which menu items need to call in order to effect commands. By
// making this the single global point of entry, all of the implementation of
// particular menu item commands can be put in local procedures and prevent
// clutter in the global namespace.
//
{
	//
	// Call necessary procedures to effect the command and call the necessary
	// procedures to refresh the UI to reflect the results of the command.
	//
	int $currImage;
	switch ($command)
	{
		case "loadImage":
		loadImage($editor);
		renderWindowRefreshMenu("file", $editor);
		renderWindowRefreshLayout($editor);
		break;
		case "saveImage":
		saveImage($editor);
		break;

		case "loadIprFile":
		loadIprFile($editor);
		break;

		case "saveIprFile":
		saveIprFile($editor);
		break;
		case "keepImageInRenderView":
		$currImage = `renderWindowEditor -q -displayImage $editor`;
		if ($currImage < 0)
		{
			renderWindowEditor -edit -saveImage $editor;
			renderWindowRefreshMenu("file", $editor);
			renderWindowRefreshLayout($editor);
		}
		else
		{
			warning (uiRes("m_renderWindowPanel.kImagealreadykeptWarn"));
		}
		break;

		case "removeImageFromRenderView":
		$currImage = `renderWindowEditor -q -displayImage $editor`;

		if ($currImage >= 0)
		{
			renderWindowEditor -edit -removeImage $editor;
			renderWindowRefreshMenu("file", $editor);
			renderWindowRefreshLayout($editor);
		}
		else
		{
			warning (uiRes("m_renderWindowPanel.kCannotremoveWarn"));
		}
		break;

		case "removeAllImagesFromRenderView":

		renderWindowEditor -edit -removeAllImages $editor;
		renderWindowRefreshMenu("file", $editor);
		renderWindowRefreshLayout($editor);

		break;

		case "updateShadowMaps":
		if (isIprFileLoaded())
		{
			iprEngine -edit -updateShadowMaps defaultIprEngine;
		}
		break;

		case "loadSamples":
		loadSamples($editor);
		break;

		case "updateShadingAndLighting":
		optionVar
			-intValue updateShadingAndLighting (!`optionVar -query updateShadingAndLighting`);
		if (`iprEngine -query -exists defaultIprEngine`)
		{
			iprEngine
				-edit
				-updateShading (`optionVar -query updateShadingAndLighting`)
				defaultIprEngine;
		}
		renderWindowRefreshMenu("ipr", $editor);
		break;

		case "updateLightGlow":
		optionVar
			-intValue updateLightGlow (!`optionVar -query updateLightGlow`);
		if (`iprEngine -query -exists defaultIprEngine`)
		{
			iprEngine
				-edit
				-updateLightGlow (`optionVar -query updateLightGlow`)
				defaultIprEngine;
			renderWindowRefreshMenu("ipr", $editor);
		}
		break;

		case "updateShaderGlow":
		optionVar
			-intValue updateShaderGlow (!`optionVar -query updateShaderGlow`);
		if (`iprEngine -query -exists defaultIprEngine`)
		{
			iprEngine
				-edit
				-updateShaderGlow (`optionVar -query updateShaderGlow`)
				defaultIprEngine;
			renderWindowRefreshMenu("ipr", $editor);
		}
		break;

		case "updateMotionBlur":
		optionVar
			-intValue updateMotionBlur (!`optionVar -query updateMotionBlur`);
		if (`iprEngine -query -exists defaultIprEngine`)
		{
			iprEngine
				-edit
				-updateMotionBlur (`optionVar -query updateMotionBlur`)
				defaultIprEngine;
			renderWindowRefreshMenu("ipr", $editor);
		}
		break;

		case "showRegionMarquee":
		string	$camera 	= `getCurrentCamera`;
		string	$panel 		= `getCameraPanel( $camera )`;
		int		$res[] 		= `getTestResolution( $panel )`;

		renderWindowEditor -edit -showRegion $res[0] $res[1] $editor;
		break;

        case "ShowFrameNumber":
        case "ShowRenderTime":
        case "ShowCameraName":
        case "ShowLayerName":
        case "ShowRenderTargetName":
        string $itemName = "renderView" + $command;
        int $showItem = !`optionVar -query $itemName`;
        optionVar -intValue $itemName $showItem;
        break;

        case "customComment":
        string $comment = "";
        //
        // Get the old custom comment.
        // If the old permanent caption has more than one line,
        // then the last line is taken to be the old custom comment.
        //
        string $permanentCaption = `renderWindowEditor -query -pcaption renderView`;
        int $captionLength = size($permanentCaption);
        string $lines[];
        tokenize $permanentCaption "\n" $lines;
        if ($captionLength >= 1 && `substring $permanentCaption $captionLength $captionLength`=="\n")
        {
            $lines[$captionLength] = "";
        }
        int $numberOfLines = size($lines);
        if ($numberOfLines > 1)
        {
            $comment = $lines[$numberOfLines-1];
        }

        //
        // Get the current custom comment from the render view
        // permenant caption.
        //
        string $ok = (uiRes("m_renderWindowPanel.kOk"));
        string $cancel = (uiRes("m_renderWindowPanel.kCancel"));
        string $result = `promptDialog
            -title (uiRes("m_renderWindowPanel.kCustomComment"))
            -message (uiRes("m_renderWindowPanel.kEnterCustomComment"))
            -text       $comment
            -button $ok -button $cancel
            -defaultButton $ok -cancelButton $cancel
            -dismissString $cancel`;

        if ($result == $ok)
        {

            // Get the comment the user entered.
            //
            $comment = `promptDialog -query -text`;
            //
            // Put the new custom comment in the render view
            // permanent caption for this image.
            //
            int $i;
            $permanentCaption = "";
            if ($numberOfLines == 1)
            {
                $permanentCaption = $lines[0] + "\n";
            }
            else
            {
                // If the old permanent caption has more then
                // one line, then take the first n-1 line before
                // the old custom comment.
                //
                for ($i=0; $i < $numberOfLines-1;$i++)
                {
                    $permanentCaption += $lines[$i]+"\n";
                }
            }
            $permanentCaption += $comment;
            renderWindowEditor -edit -pcaption $permanentCaption renderView;
        }
        break;

		case "dithered":
		int $singleBuffer = `renderWindowEditor -query -singleBuffer $editor`;

		if ($singleBuffer == 0)
		{
			renderWindowEditor -edit -singleBuffer $editor;
		}
		else
		{
			renderWindowEditor -edit -doubleBuffer $editor;
		}
		break;

		case "toolbar":
		toggleDisplayToolbar();
		renderWindowRefreshLayout($editor);
		break;

		case "grabSwatch":
		if (`renderWindowEditor -query -snapshotMode $editor`) {
			// The user is already in grab swatch mode, so we will get out of
			// grab swatch mode.
			//
			renderWindowEditor -edit -caption "" $editor;
			renderWindowEditor -edit -snapshotMode off $editor;
		} else {
			// We will enter grab swatch mode.
			//
			renderWindowEditor
				-edit
				-caption (uiRes("m_renderWindowPanel.kSelectDragRegion"))
				$editor;
			renderWindowEditor -edit -snapshotMode on $editor;
		}
		break;
	}
}



//---------------------------------------------------------------------------//
// Procedures which generate menu items and procedures which refresh menus
// when they are opened
//---------------------------------------------------------------------------//

proc createFileMenu(string $editor, string $menuType)
{
	string $file = (uiRes("m_renderWindowPanel.kFile"));
	if ($menuType == "popup")
	{
		menuItem
			-label 					$file
			-subMenu				true
			-postMenuCommand
				("renderWindowRefreshMenu "
					+ "\"file\" "
					+ $editor)
			-familyImage			""
			($editor + $menuType + "FileMenu");
	}
	else
	{
		menu
			-label 					$file
			-tearOff				true
			-postMenuCommand
				("renderWindowRefreshMenu "
					+ "\"file\" "
					+ $editor)
			-familyImage			""
			($editor + $menuType + "FileMenu");
	}

	menuItem
		-label		(uiRes("m_renderWindowPanel.kOpenImage"))
		-command
			("renderWindowMenuCommand loadImage " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kLoadimagediskAnnot"))
		($editor + "loadImageItem");

	menuItem
		-version 2016
		-label			(uiRes("m_renderWindowPanel.kSaveImage"))
		-command
			("renderWindowMenuCommand saveImage " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kSavecurrentlydispimageDiskAnnot"))
		($editor + "saveImageItem");
    menuItem
        -optionBox               true
        -command                "saveImageOptBox";

	menuItem
		-divider true;

	menuItem
		-label		(uiRes("m_renderWindowPanel.kOpenIPRFile"))
		-command
			("renderWindowMenuCommand loadIprFile " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kLoadIPRfilefromdisk"))
		($editor + "loadIprFileItem");

	menuItem
		-label		(uiRes("m_renderWindowPanel.kSaveIPRFile"))
		-command
			("renderWindowMenuCommand saveIprFile " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kSaveanIPRAnnot"))
		($editor + "saveIprFileItem");

	menuItem
		-label	(uiRes("m_renderWindowPanel.kCloseIPRFile"))
		-command
            ("stopIprRendering " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kFinishIPRsessionAnnot"))
		($editor + "closeIprFileItem");

	menuItem
		-divider true;

	menuItem
		-label (uiRes("m_renderWindowPanel.kLoadPass"))
		-annotation (uiRes("m_renderWindowPanel.kLoadPassAnn"))
		-subMenu true
		-tearOff true
		-postMenuCommand ("renderWindowCreateRenderPassMenu " + $editor + " " + $menuType)
		($editor + $menuType + "loadPassFileItem");
	setParent -menu ..;

	menuItem
		-divider true;

	menuItem -label (uiRes("m_renderWindowPanel.kRenderDiagnostics"))
		-annotation (getRunTimeCommandAnnotation("RenderDiagnostics"))
		-command ("RenderDiagnostics")
	    ($editor + "renderDiagnosticsItem");

	menuItem
		-divider true;

	menuItem
		-label			(uiRes("m_renderWindowPanel.kKeepImageinRenderView"))
		-command
			("renderWindowMenuCommand keepImageInRenderView " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kSavecurrentlydispimageCreateAnnot"))
		($editor + "keepImageInRenderViewItem");

	menuItem
		-label					(uiRes("m_renderWindowPanel.kRemoveImagefromRenderView"))
		-command
			("renderWindowMenuCommand removeImageFromRenderView " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kRemovecurrentlydispimageAnnot"))
		($editor + "removeImageFromRenderViewItem");

	menuItem
		-label					(uiRes("m_renderWindowPanel.kRemoveAllImagesRenderView"))
		-command
			("renderWindowMenuCommand removeAllImagesFromRenderView " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kRemovealldispimageAnnot"))
		($editor + "removeAllImagesFromRenderViewItem");

	setParent -menu ..; // from FileMenu
}

proc refreshFileMenu(string $editor, string $menuType)
{
	setParent -menu ($editor + $menuType + "FileMenu");

	// If there is no image or IPR image currently in the renderview, dim the
	// Save Image... item, the Keep Image in Render View item and the Remove
	// Image from Render View item.
	//
	if (isImageLoaded($editor))
	{
		menuItem
			-edit
			-enable				true
			($editor + "saveImageItem");
		menuItem
			-edit
			-enable				true
			($editor + "keepImageInRenderViewItem");
	}
	else
	{
		menuItem
			-edit
			-enable				false
			($editor + "saveImageItem");
		menuItem
			-edit
			-enable				false
			($editor + "keepImageInRenderViewItem");
	}

	// Update Maya software renderer IPR related UI items.
	//
	if (currentRenderer() == "mayaSoftware")
	{
		// Enable load ipr file menuitem if ipr is supported
		//
		menuItem
			-edit
			-enable				true
			($editor + "loadIprFileItem");

		// If there is no IPR file currently in the renderview, dim
		// the Save IPR File... item.
		//
		if (isIprFileLoaded())
		{
			menuItem
				-edit
				-enable				true
				($editor + "saveIprFileItem");

			menuItem
				-edit
				-enable				true
				($editor + "closeIprFileItem");
		}
		else
		{
			menuItem
				-edit
				-enable				false
				($editor + "saveIprFileItem");

			menuItem
				-edit
				-enable				false
				($editor + "closeIprFileItem");
		}
	}
	else
	{
		menuItem
			-edit
			-enable				false
			($editor + "loadIprFileItem");


		menuItem
			-edit
			-enable				false
			($editor + "saveIprFileItem");

		menuItem
			-edit
			-enable				false
			($editor + "closeIprFileItem");

	}

	// if we can attempt to generate pass paths to load then
	// enable the submenu
	global string $gRenderViewLastRenderCamera;
	global string $gRenderViewLastRenderLayer;
	int $enable = ($gRenderViewLastRenderCamera != "" && $gRenderViewLastRenderLayer != "");
	if ($enable) {
		string $passSets[] = `listConnections -type "renderPassSet" ($gRenderViewLastRenderLayer + ".renderPass")`;
		string $passes[] = `listConnections -type "renderPass" ($gRenderViewLastRenderLayer + ".renderPass")`;
		$enable = (size($passSets) > 0 || size($passes) > 0);
	}

	// Give third parties a chance to enable the render pass menu item
	int $requestsToEnableRenderPassMenuOfRenderView[] = `callbacks -executeCallbacks -hook "enableRenderPassMenuOfRenderView"`;
	for ($requestToEnableRenderPassMenuOfRenderView in $requestsToEnableRenderPassMenuOfRenderView) {
		if($requestToEnableRenderPassMenuOfRenderView == 1) {
			$enable = 1;
			break;
		}
	}
	
	menuItem -edit
		-enable $enable
		($editor + $menuType + "loadPassFileItem");

	// If current renderer supports renderdiagnostics, disable/enable
	//	related UI
	//
    string $currentRendererName = currentRenderer();
	if (`renderer -query -renderDiagnosticsProcedure $currentRendererName` != "")
	{
		menuItem
			-edit
			-enable				true
			($editor + "renderDiagnosticsItem");
	}
	else
	{
		menuItem
			-edit
			-enable				false
			($editor + "renderDiagnosticsItem");
	}

	// If the renderview is currently looking at the non-buffered image, dim
	// the "Remove Image from Render View" item and
	// the "Remove All Images from Render View" item.
	//
	if (`renderWindowEditor -query -displayImage $editor` >= 0)
	{
		menuItem
			-edit
			-enable				true
			($editor + "removeImageFromRenderViewItem");
	}
	else
	{
		menuItem
			-edit
			-enable				false
			($editor + "removeImageFromRenderViewItem");
	}

	if( `renderWindowEditor -query -nbImages $editor` > 0 )
	{
		menuItem
			-edit
			-enable				true
			($editor + "removeAllImagesFromRenderViewItem");
	}
	else
	{
		menuItem
			-edit
			-enable				false
			($editor + "removeAllImagesFromRenderViewItem");
	}
}

//	Generate the render passes submenu of the file menu
//
global proc renderWindowCreateRenderPassMenu(string $editor, string $menuType)
{
	string $subMenu = ($editor + $menuType + "loadPassFileItem");
	menu -edit -deleteAllItems $subMenu;

	global string $gRenderViewLastRenderCamera;
	global string $gRenderViewLastRenderLayer;
	global string $gRenderViewLastRenderTime;

	if ($gRenderViewLastRenderCamera != "" && $gRenderViewLastRenderLayer != "") {
		if (`nodeType $gRenderViewLastRenderLayer` == "renderLayer") {
			string $passSets[] = `listConnections -type "renderPassSet" ($gRenderViewLastRenderLayer + ".renderPass")`;
			string $passes[] = `listConnections -type "renderPass" ($gRenderViewLastRenderLayer + ".renderPass")`;
			for ($set in $passSets) {
				string $setPasses[] = `listConnections -type "renderPass" ($set + ".renderPass")`;
				if (size($setPasses) > 0) {
					$passes = stringArrayCatenate($passes, $setPasses);
				}
			}

			setParent -menu $subMenu;
			string $cameraTrans[] = `listRelatives -path -parent $gRenderViewLastRenderCamera`;
			string $prefix = `getAttr defaultRenderGlobals.imageFilePrefix`;
			int $usesPassToken = (`match "<RenderPass>" $prefix` != "");

			for ($pass in $passes) {
                if (`getAttr ($pass + ".renderable")`) {
				    string $renderPassCustomToken = "RenderPass=" + `substitute ":" $pass "_"`;
				    string $groupName = `getAttr ($pass + ".passGroupName")`;
				    if ($groupName != "") {
					    $renderPassCustomToken += (" RenderPassFileGroup=" + $groupName);
				    }
				    string $typeName = `getAttr ($pass + ".passID")`;
				    if ($typeName != "") {
					    $renderPassCustomToken += (" RenderPassType=" + $typeName);
				    }
				    string $lastRenderTime = $gRenderViewLastRenderTime;
				    int $padding = `getAttr defaultRenderGlobals.extensionPadding`;
				    if ($lastRenderTime != "" && size($lastRenderTime) < $padding) {
					    int $neededPadding = $padding - size($lastRenderTime);
					    for ($i=0; $i<$neededPadding; $i++) {
						    $lastRenderTime = ("0" + $lastRenderTime);
					    }
				    }
				// since this is for preview renders get the full temp path
				string $imageNames[] = `renderSettings -fullPathTemp
											    -genericFrameImageName $lastRenderTime
											-layer $gRenderViewLastRenderLayer
											-camera $cameraTrans[0]
											-customTokenString $renderPassCustomToken`;
				string $filePath = $imageNames[0];

				// if the image type is exr and the render pass token is not
				// used in the file name, then all pass are in the same OpenExr
				// file and we should pass the channel name to imf_disp
				string $channelName = "";
				if (endsWith($filePath, "exr") && !$usesPassToken) {
					$channelName = `frameBufferName -renderPass $pass
										-camera $cameraTrans[0]
										-renderLayer $gRenderViewLastRenderLayer
										-autoTruncate`;
				}

				menuItem -label $pass
					-command ("renderWindowRenderPassMenuCallback \"" + encodeString($filePath) + "\" \"" + $channelName +"\"");
			}
		}

		// Give third parties a chance to add items to the render pass menu of the render view
		callbacks -executeCallbacks -hook "addItemsToRenderPassMenuOfRenderView";

	}
}
}

//	Invoke imf_disp on the file through the python script invokeImfDisp
global proc renderWindowRenderPassMenuCallback(string $fileName, string $channel)
{
	python("import mentalray.invokeImfDisp");
	python("mentalray.invokeImfDisp.invokeImfDisp('" + $fileName + "', '" + $channel + "')");
}

global proc populateRenderTargetMenu()
{
    global string $gRenderViewRenderTarget;
    global int $gRenderViewRenderTargetNormal;

    menu -edit -deleteAllItems renderTargetMenu;

    string $renderTargets[] = `ls -type renderTarget`;

	setParent -menu renderTargetMenu;

    radioMenuItemCollection;

    menuItem -l (uiRes("m_renderWindowPanel.kRenderTargetNone"))
      -c ("setRenderViewRenderTarget \"\" " + $gRenderViewRenderTargetNormal)
	  -rb ($gRenderViewRenderTarget == "");

    for ($i = 0; $i < size($renderTargets); $i++) {
        string $rt = $renderTargets[$i];
        menuItem -l $rt
		  -c ("setRenderViewRenderTarget " + $rt + " " + 
              $gRenderViewRenderTargetNormal)
          -rb ($gRenderViewRenderTarget == $rt);
    }
}

proc setRenderTargetSupport()
{
  int $support = rendererRenderTargetSupport(currentRenderer());

  menu -edit -enable $support renderTargetMenu;

  global string $gRenderViewRenderTarget;
  if (!`objExists $gRenderViewRenderTarget` || !$support) {
    $gRenderViewRenderTarget = "";
  }

  string $renderPanels[] = `getPanel -scriptType "renderWindowPanel"`;
  if( size($renderPanels) > 0 ){
	  updateRenderViewCurrentRenderTarget($renderPanels[0]);
  }
}

global proc string getRenderViewRenderTarget()
{
  global string $gRenderViewRenderTarget;
  return $gRenderViewRenderTarget;
}

global proc setRenderViewRenderTarget(string $rt, int $context)
{
  global string $gRenderViewRenderTarget;
  global int $gRenderViewRenderTargetNameChangeJob;
  global int $gRenderViewRenderTargetDeletedJob;
  global int $gRenderViewRenderTargetInNameChange;
  global int $gRenderViewRenderTargetInDelete;

  if ($gRenderViewRenderTarget == $rt) {
    return;
  }

  // Remove callbacks from the previous render view render target.  It
  // is an error to do this for scriptJob callbacks that are running,
  // but we don't need to, as we create our scriptJob's with -runOnce
  // true.  We just need to remove the ones that haven't run.
  if ($gRenderViewRenderTarget != "") {
    if ($gRenderViewRenderTargetNameChangeJob != -1 &&
        $context != $gRenderViewRenderTargetInNameChange) {
      scriptJob -kill $gRenderViewRenderTargetNameChangeJob;
      $gRenderViewRenderTargetNameChangeJob = -1;
    }
    if ($gRenderViewRenderTargetDeletedJob != -1 &&
        $context != $gRenderViewRenderTargetInDelete) {
      scriptJob -kill $gRenderViewRenderTargetDeletedJob;
      $gRenderViewRenderTargetDeletedJob = -1;
    }
  }

  $gRenderViewRenderTarget = $rt;

  // Watch render target for deletions and name changes.  Use runOnce
  // to remove the script job once the node rename/delete is done, otherwise
  // the script job persists.
  if ($gRenderViewRenderTarget != "") {
    $gRenderViewRenderTargetNameChangeJob = `scriptJob -runOnce true 
      -parent renderTargetMenu -nodeNameChanged $gRenderViewRenderTarget
      renderViewRenderTargetNameChanged`;
    $gRenderViewRenderTargetDeletedJob = `scriptJob -runOnce true -parent
      renderTargetMenu -nodeDeleted $gRenderViewRenderTarget
      renderViewRenderTargetDeleted`;
  }

  string $renderPanels[] = `getPanel -scriptType "renderWindowPanel"`;
  if( size($renderPanels) > 0 ){
	  updateRenderViewCurrentRenderTarget($renderPanels[0]);
  }
}

global proc renderViewRenderTargetNameChanged()
{
  global int $gRenderViewRenderTargetInNameChange;
  // Very unfortunately, we are not given the new node name in the
  // callback, so the best we can do is set the render view render
  // target to None.
  setRenderViewRenderTarget("", $gRenderViewRenderTargetInNameChange);
}

global proc renderViewRenderTargetDeleted()
{
  global int $gRenderViewRenderTargetInDelete;
  setRenderViewRenderTarget("", $gRenderViewRenderTargetInDelete);
}

proc createRenderMenu(string $editor, string $menuType)
{
	// Create the Render menu
	//
	string $render = (uiRes("m_renderWindowPanel.kRender"));
	if ($menuType == "popup")
	{
		menuItem
			-subMenu				true
			-label $render
			-postMenuCommand
				("renderWindowRefreshMenu "
					+ "\"render\" "
					+ $editor)
			-familyImage			"menuIconRender.png"
			-allowOptionBoxes		true
			($editor + $menuType + "RenderMenu");
	}
	else
	{
		menu
			-label $render
			-tearOff 				true
			-allowOptionBoxes		true
			-postMenuCommand
				("renderWindowRefreshMenu "
					+ "\"render\" "
					+ $editor)
			-familyImage			"menuIconRender.png"
			($editor + $menuType + "RenderMenu");
	}

	menuItem
		-label (uiRes("m_renderWindowPanel.kRedoPreviousRender"))
		-command
			("renderWindowRender redoPreviousRender " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kRenderusinprevcameraAnnot"))
		($editor + "redoPreviousRenderItem");

	menuItem
		-label				(uiRes("m_renderWindowPanel.kRenderRegionMenu"))
		-command
			("renderWindowRenderRegion " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kRenderpartinregionmarqueeAnnot"))
		($editor + "renderRegionItem");

	menuItem -divider true;

    menuItem
        -label                  (uiRes("m_renderWindowPanel.kRenderAllLayers"))
        -checkBox               false
        -command                "switchRenderAllLayers"
        ($editor + "renderSelectedLayer");

    menuItem
        -optionBox               true
        -command                "switchRenderAllLayersOptBox";

    menuItem
        -label (uiRes("m_renderWindowPanel.kRenderSelectedObjectsOnly"))
        -checkBox               false
        -command                "switchSelectObj"
        ($editor + "renderSelectedObjItem");

	menuItem
		-divider true;

	//
	//	Dynamic render menu, it contains the list of cameras to render
	//	from.
	//
	menuItem
		-label $render
		-subMenu 				true
		-tearOff 				true
		($editor + $menuType + "renderRenderItem");
	menuItem
		-edit
		-postMenuCommand
			("renderWindowCreateCameraSubmenu "
				+ $editor + $menuType + "renderRenderItem"
				+ " "
				+ "\"renderWindowRenderCamera render " + $editor + " \""
				+ $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kRenderusingparticularcamAnnot"))
		($editor + $menuType + "renderRenderItem");
	setParent -menu ..; // from Render menu

	//
	//	Dynamic snapshot render menu, it contains the list of visible
	//	camera panels to render from.
	//
	menuItem
		-label (uiRes("m_renderWindowPanel.kSnapshot"))
		-subMenu 				true
		-tearOff 				true
		($editor + $menuType + "renderSnapshotItem");
	menuItem
		-edit
		-postMenuCommand
			("renderWindowCreateCameraSubmenu "
				+ $editor
				+ $menuType
				+ "renderSnapshotItem"
				+ " "
				+ "\"renderWindowRenderCamera snapshot "
				+ $editor
				+ " \""
				+ $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kTakewireframesnapshotAnnot"))
		($editor + $menuType + "renderSnapshotItem");
	setParent -menu ..; // from Snapshot menu

	setParent -menu ..; // from Render menu
}

proc refreshRenderMenu(string $editor, string $menuType)
{
	setParent -menu ($editor + $menuType + "RenderMenu");

	menuItem -e -checkBox (`optionVar -q renderViewRenderAllLayers`)
		($editor + "renderSelectedLayer");

	menuItem -e -checkBox (`optionVar -q renderViewRenderSelectedObj`)
		($editor + "renderSelectedObjItem");
}

// Description:  This procedure is called to create the iprUpdateOptions
//  sub menu.
//
global proc iprUpdateOptionsSubMenu(string $menu, string $editor)
{
    // Delete all existing sub menu items.
    //
    popupMenu
        -edit
        -deleteAllItems
        $menu;

    string $currentRenderer = currentRenderer();
    // If the current renderer's IPR is not running, the $menu should be
    // greyout.  It should never reach this procedure.  But if this
    // procedure is called by mistake, we don't show the submenus.
    //
    // we want to pass through here for mentalray
    if (!eval(`renderer -q -isRunningIprProcedure $currentRenderer`)
    	&& $currentRenderer != "mentalRay")
    {
        return;
    }

    setParent
        -menu
        $menu;

    string $subMenuProc = `renderer -q -iprOptionsSubMenuProcedure $currentRenderer`;
    if ($subMenuProc != "")
    {
        // Show the sub menus.
        //
        string	$camera 		= `getCurrentCamera`;
		string	$cameraPanel 	= `getCameraPanel( $camera )`;
		int		$resolution[]	= `getTestResolution( $cameraPanel )`;
        eval($subMenuProc+" "+$editor+" "+$resolution[0]+" "+$resolution[1]+" "+$camera);
    }
}

// Description: This procedure is called to create the IPR Render sub menu
//
global proc iprUpdateRenderSubMenu(string $subMenu, string $editor)
{
	string $renderMenuProc =
		`renderer -q -iprRenderSubMenuProcedure (currentRenderer())`;
	if ($renderMenuProc != "") {
		eval($renderMenuProc + " " + $subMenu + " " + $editor);
	} else {
		// no registered sub menu proc, do default action
		renderWindowCreateCameraSubmenu(
						$subMenu,
						("renderWindowRenderCamera iprRender " + $editor + " "),
						$editor);
	}
}

proc createIprMenu(string $editor, string $menuType)
{
	// Create the IPR menu
	//
	string $ipr = (uiRes("m_renderWindowPanel.kIPR"));
	if ($menuType == "popup")
	{
		menuItem
			-subMenu				true
			-label  $ipr
			-postMenuCommand
				("renderWindowRefreshMenu "
					+ "\"ipr\" "
					+ $editor)
			-familyImage			""
			($editor + $menuType + "IprMenu");
	}
	else
	{
		menu
			-label 					$ipr
			-tearOff 				true
			-postMenuCommand
				("renderWindowRefreshMenu "
					+ "\"ipr\" "
					+ $editor)
			-familyImage			""
			($editor + $menuType + "IprMenu");
	}

	menuItem
		-label			(uiRes("m_renderWindowPanel.kRedoPreviousIPRRender"))
		-command
			("renderWindowRender redoPreviousIprRender " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kIPRrenderusingcameraAnnot"))
		($editor + "redoPreviousIprRenderItem");

	menuItem
		-divider true;

	//
	//	Dynamic render menu, it contains the list of cameras to render
	//	from.
	//
	menuItem
		-label 		(uiRes("m_renderWindowPanel.kIPRRender"))
		-subMenu 				true
		-tearOff 				true
		($editor + $menuType + "iprRenderItem");
	menuItem
		-edit
		-postMenuCommand
			("iprUpdateRenderSubMenu "
				+ $editor
				+ $menuType
				+ "iprRenderItem "
				+ $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kRenderparticularcameraAnnot"))
		($editor + $menuType + "iprRenderItem");
	setParent -menu ..; // from Render menu

	menuItem
		-divider true;

	menuItem
		-label 			(uiRes("m_renderWindowPanel.kUpdateShadowMaps"))
		-command
			("renderWindowMenuCommand updateShadowMaps " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kRecreateshadowmapsAnnot"))
		($editor + "updateShadowMapsItem");

	menuItem
		-label				(uiRes("m_renderWindowPanel.kUpdateImagePlanesBackground"))
		-command
			("renderWindowMenuCommand loadSamples " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kReloadIPRpixelsAnnot"))
		($editor + "loadSamplesItem");

	menuItem
		-label		(uiRes("m_renderWindowPanel.kRefreshIPRImage"))
		-command ("refreshIprImage")
		-annotation
			(uiRes("m_renderWindowPanel.kRefreshIPRimageMenuAnnot"))
		($editor + "refreshIprImage");

	menuItem
		-label					(uiRes("m_renderWindowPanel.kIPRTuningOptions"))
		-subMenu				true
		-tearOff 				true
		($editor + $menuType+"iprUpdateOptionsItem");

	menuItem
		-edit
		-postMenuCommand
            ("iprUpdateOptionsSubMenu "
				+ $editor
				+ $menuType
				+ "iprUpdateOptionsItem"
				+ " "
                + $editor)
		($editor + $menuType+ "iprUpdateOptionsItem");

	setParent -menu ..; // from IPR Tuning Options

	menuItem
		-divider true;

	global int $gIprTuningPaused;

	menuItem
		-label			(uiRes("m_renderWindowPanel.kPauseIPRTuning"))
		-checkBox				$gIprTuningPaused
		-command
		    ("renderViewTogglePauseIpr " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kPauseunpauseAnnot"))
		($editor + "pauseIprTuning");

	setParent -menu ..; // from IPR menu
}

proc refreshIprMenu(string $editor, string $menuType)
{
	setParent -menu ($editor + $menuType + "IprMenu");

	global int $gIprTuningPaused;

    string $currentRendererName = currentRenderer();
	if (`renderer -query -iprRenderProcedure $currentRendererName` != "")
	{

		string $iprMenuItems[] = `menu -query -itemArray ($editor + $menuType + "IprMenu")`;
		//
		// Enable ipr menuItems if renderer supports the ipr feature.
		// These items have to be explicitly enabled in case they were
		// disabled by the previous renderer
		//
		for ($i = 0; $i < size($iprMenuItems); $i += 1)
		{
			menuItem -edit -enable true $iprMenuItems[$i];
		}

        // Update Maya software renderer specific menu items.
        //
		if (isIprFileLoaded())
		{
			menuItem
				-edit
				-enable					true
				($editor + "updateShadowMapsItem");

			menuItem
				-edit
				-enable					true
				($editor + "loadSamplesItem");
		}
		else
		{
			menuItem
				-edit
				-enable					false
				($editor + "updateShadowMapsItem");

			menuItem
				-edit
				-enable					false
				($editor + "loadSamplesItem");
		}

        // Update general IPR menu items.
        //
        int $enableMenuItem = false;
	    if (isRunningIpr())
        {
            $enableMenuItem = true;
        }

        // Update the Ipr update options menu.
        //
	    menuItem
		    -edit
		    -enable		($enableMenuItem || $currentRendererName == "mentalRay")
		    ($editor + $menuType+"iprUpdateOptionsItem");

        string $iprUpdateOptionsMenuLabel = `renderer -q -iprOptionsMenuLabel $currentRendererName`;
        if ($iprUpdateOptionsMenuLabel != "")
        {
	        menuItem
                -edit
		        -label $iprUpdateOptionsMenuLabel
		        ($editor + $menuType+"iprUpdateOptionsItem");
        }

		menuItem
				-edit
				-enable	($enableMenuItem && !$gIprTuningPaused)
				($editor + "refreshIprImage");

		menuItem
				-edit
				-enable	$enableMenuItem
				($editor + "pauseIprTuning");

		// Check or uncheck the "Pause IPR Tuning" menu item checkbox
		// appropriately
		//
		menuItem
			-edit
			-checkBox				$gIprTuningPaused
			($editor + "pauseIprTuning");

	}
	else
	{
		string $iprMenuItems[] = `menu -query -itemArray ($editor + $menuType + "IprMenu")`;

		// Disable all ipr menuItems if current renderer does not support ipr.
		// Since the menu itself cannot be disabled, all menuItems are being
		// greyed out
		//
		for ($i = 0; $i < size($iprMenuItems); $i += 1)
		{
			menuItem -edit -enable false $iprMenuItems[$i];
		}
	}
}

proc buildOptionsMenu(string $editor, string $menuType)
{
	// Create a render settings menu item for each available renderer
	//
	int $i;
	string $rendererUIName = "";
	string $annotation = getRunTimeCommandAnnotation("RenderGlobalsWindow");
	menuItem
			-enableCommandRepeat false
			-label (localizedUIMisc("Render Settings") + " ...")
			-annotation $annotation
			-command "unifiedRenderGlobalsWindow";

	menuItem
		-subMenu				true
		-label		(uiRes("m_renderWindowPanel.kRenderUsing"))
		-annotation
			(uiRes("m_renderWindowPanel.kChangecurrentrenderAnnot"))
		($editor + $menuType + "renderUsingItem");

	menuItem
		-edit
		-postMenuCommand
			("buildRenderUsingMenu "
				+ $editor
				+ $menuType + "renderUsingItem "
				+ $editor)
		($editor + $menuType + "renderUsingItem");

	setParent -menu ..;

	menuItem -divider true;

	menuItem
		-subMenu				true
		-label			(uiRes("m_renderWindowPanel.kTestResolution"))
		-annotation
			(uiRes("m_renderWindowPanel.kChangeresolutionAnnot"))
		($editor + $menuType + "resolutionItem");

	menuItem
		-edit
		-postMenuCommand
			("renderWindowMakeResolutionItem "
				+ $editor
				+ $menuType + "resolutionItem "
				+ $editor)
		($editor + $menuType + "resolutionItem");

	setParent -menu ..; // from Resolution menu

	menuItem -divider true;

	menuItem
		-label			(uiRes("m_renderWindowPanel.kAutoResize"))
		-checkBox				false
		-command				("switchAutoResizeVar " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kCheckedcenteredAnnot"))
		($editor +  "autoResizeItem");

	menuItem
		-label			(uiRes("m_renderWindowPanel.kAutoRenderRegion"))
		-checkBox				false
		-command				"switchAutoRenderRegionVar"
		-annotation
			(uiRes("m_renderWindowPanel.kCheckedRenderRegionAnnot"))
		($editor +  "autoRenderRegionItem");

	menuItem -divider true;

	menuItem
        -label             (uiRes("m_renderWindowPanel.kIgnoreShadows"))
        -checkBox               false
        -command                ("switchShadowsVar " + $editor)
        -annotation
            (uiRes("m_renderWindowPanel.kCheckednoshadowsAnnot"))
        ($editor + "shadowsItem");

    menuItem
        -label (uiRes("m_renderWindowPanel.kIgnoreGlows"))
        -checkBox               false
        -command                ("switchGlowPassVar " + $editor)
        -annotation
            (uiRes("m_renderWindowPanel.kCheckednoglowsAnnot"))
        ($editor + "glowPassItem");
}

proc createOptionsMenu(string $editor, string $menuType)
{
	string $subName;
	string $option = (uiRes("m_renderWindowPanel.kOptions"));
	if ($menuType == "popup")
	{
		menuItem
			-subMenu				true
			-label 		$option
			-postMenuCommand
				("renderWindowRefreshMenu "
					+ "\"options\" "
					+ $editor)
			-familyImage 			"menuIconRenderSettings.png"
			($editor + $menuType + "OptionsMenu");
	}
	else
	{
		menu
			-label 			$option
			-tearOff				true
			-postMenuCommand
				("renderWindowRefreshMenu "
					+ "\"options\" "
					+ $editor)
			-familyImage 			"menuIconRenderSettings.png"
			($editor + $menuType + "OptionsMenu");
	}

	buildOptionsMenu($editor, $menuType);

	setParent -menu ..; // from Options menu
}

proc refreshOptionsMenu(string $editor, string $menuType)
{
	global int $renderViewShadowsMode;
	global int $renderViewGlowPassMode;

	setParent -menu ($editor + $menuType + "OptionsMenu");

	// If auto resize is on, check the Auto Resize checkbox.
	//
	menuItem
		-edit
		-checkBox			`optionVar -query renderViewAutoResize`
		($editor +  "autoResizeItem");

	menuItem
		-edit
		-checkBox			$renderViewShadowsMode
		($editor +  "shadowsItem");

    menuItem
        -edit
        -checkBox           $renderViewGlowPassMode
        ($editor +  "glowPassItem");

	// Make sure the state of the renderWindowEditor accurately reflects the
	// user's setting of the optionVar
	//
	renderWindowEditor
		-edit
		-autoResize			`optionVar -query renderViewAutoResize`
		$editor;

	// Update render all / selected
	//
	menuItem -edit -checkBox (!`getAttr defaultRenderGlobals.renderAll`)
		($editor + "renderSelectedObjItem");

	// If auto render region is on, check the Auto Render Region checkbox.
	//
	menuItem
		-edit
		-enable			true
		-checkBox			`optionVar -query renderViewAutoRenderRegion`
		($editor + "autoRenderRegionItem");

	// Disable this menu item for IPR
    ///
	if (isRunningIpr()) {
		menuItem -edit -enable false
			($editor + "autoRenderRegionItem");
	}

    // Update Maya software renderer specific UI items.
    //
	if (currentRenderer() == "mayaSoftware")
	{
		// Disable these menu items for IPR
		if (isRunningIpr()) {
    		menuItem -edit -enable false ($editor +  "shadowsItem");
			menuItem -edit -enable false ($editor +  "glowPassItem");
		} else {
    		menuItem -edit -enable true ($editor +  "shadowsItem");
			menuItem -edit -enable true ($editor +  "glowPassItem");
		}
	}
	else
	{
		menuItem -edit -enable false ($editor +  "shadowsItem");
		menuItem -edit -enable false ($editor +  "glowPassItem");
	}
}

proc createViewMenu(string $editor, string $menuType)
{
	string $view = (uiRes("m_renderWindowPanel.kView"));
	if ($menuType == "popup")
	{
		menuItem
			-subMenu				true
			-label 					$view
			-postMenuCommand
				("renderWindowRefreshMenu "
					+ "\"view\" "
					+ $editor)
			-familyImage 			"menuIconView.png"
			($editor + $menuType + "ViewMenu");
	}
	else
	{
		menu
			-label 					$view
			-tearOff				true
			-postMenuCommand
				("renderWindowRefreshMenu "
					+ "\"view\" "
					+ $editor)
			-familyImage 			"menuIconView.png"
			($editor + $menuType + "ViewMenu");
	}

	menuItem
		-label			(uiRes("m_renderWindowPanel.kFrameImage"))
		-command
			("renderWindowEditor "
				+ "-edit "
				+ "-frameImage "
				+ $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kZoomimagefitsrenderviewAnnot"))
		($editor + "frameImageItem");

	menuItem
		-label			(uiRes("m_renderWindowPanel.kFrameRegion"))
		-command
			("renderWindowEditor "
				+ "-edit "
				+ "-frameRegion "
				+ $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kZoomregionfitsrenderviewAnnot"))
		($editor + "frameRegionItem");

	menuItem
		-label			(uiRes("m_renderWindowPanel.kRealSize"))
		-command
			("renderWindowEditor "
				+ "-edit "
				+ "-realSize "
				+ $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kZoomimagerealsizeAnnot"))
		($editor + "realSizeItem");

	menuItem -divider true;

	menuItem
		-label			(uiRes("m_renderWindowPanel.kShowRegionMarquee"))
		-command ("renderWindowMenuCommand showRegionMarquee " + $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kShowtheregionmarquee"))
		($editor + "showRegionMarqueeItem");

	menuItem
		-label				(uiRes("m_renderWindowPanel.kResetRegionMarquee"))
		-command
			("renderWindowEditor "
				+ "-edit "
				+ "-marquee 1.0 0.0 0.0 1.0 "
				+ $editor)
		-annotation
			(uiRes("m_renderWindowPanel.kResetregionsizeentireimageAnnot"))
		($editor + "resetRegionMarqueeItem");

	menuItem -divider true;

	menuItem
		-label		(uiRes("m_renderWindowPanel.kGrabSwatchtoHypershadeVisor"))		
		-annotation (uiRes("m_renderWindowPanel.kGrabSwatchHyperVisorAnnot"))
        -command ("renderWindowMenuCommand grabSwatch " + $editor)
		($editor + "grabSwatchItem");

	setParent -menu ..; // from View menu
}

proc refreshViewMenu(string $editor, string $menuType)
{
	//
	// Set the appropriate text for the grab swatch
	//
	if ($menuType == "menubar") {
		setParent -menu ($editor + $menuType + "ViewMenu");
	} else if ($menuType == "popup") {
		setParent -menu ($editor + $menuType + "OptionsMenu");
	}
	if (`renderWindowEditor -query -snapshotMode $editor`) {
		menuItem -edit
			-label (uiRes("m_renderWindowPanel.kCancelSwatchGrabHyperV"))
			-annotation (uiRes("m_renderWindowPanel.kCancelSwatchGrabHyperVAnnot"))
			($editor + "grabSwatchItem");
	} else {
		menuItem -edit
				-label (uiRes("m_renderWindowPanel.kGrabSwatchtoHyperVisor"))
                -annotation (uiRes("m_renderWindowPanel.kGrabSwatchtoHyperVisorAnnot"))
			($editor + "grabSwatchItem");
	}
}

proc refreshDisplayMenu(string $editor, string $menuType)
{
    // Check the display style and color channel information.
    //
	int $isRGB   = 0;
    int $isRed   = 0;
    int $isGreen = 0;
    int $isBlue  = 0;
    int $isLum   = 0;
    int $isMask  = 0;
    string $displayStyle = `renderWindowEditor -q -displayStyle $editor`;
	switch ($displayStyle) {
		case "lum":  $isLum = 1; break;
		case "mask": $isMask = 1; break;
		default: // "color"
		float $scaleRed = `renderWindowEditor -q -scaleRed $editor`;
		float $scaleGreen = `renderWindowEditor -q -scaleGreen $editor`;
		float $scaleBlue = `renderWindowEditor -q -scaleBlue $editor`;
		if ($scaleRed == 1.0) {
			if (($scaleGreen == 1.0) && ($scaleBlue == 1.0))
				$isRGB = 1;
			else { $isRed = 1; }
		}
		else if ($scaleGreen == 1.0)
			$isGreen = 1;
		else
			$isBlue = 1;
	}

	// Update the RGB / Mask icons
	if (`iconTextButton -ex rvMaskButton`) {
		if ($isMask) {
			iconTextButton -edit -i1 "rvMaskPlane.png"  rvMaskButton;
			// Dim the RGB button. Make sure not to Dim twice...
			string $icon = `iconTextButton -query -i1 rvAllPlanesButton`;
			$icon = `substitute "(Dim)*\\.png$" $icon "Dim.png"`;
			iconTextButton -edit -i1 $icon rvAllPlanesButton;
		} else {
			iconTextButton -edit -i1 "rvMaskPlaneDim.png"  rvMaskButton;
			string $icon;
			string $cmd;
			string $upd = ";renderWindowRefreshMenu(\"display\", \"" + $editor + "\")";
			if ($isLum) {
				$icon = "rvLumChannel.png";
				$cmd = ("renderWindowEditor -edit -displayStyle \"lum\" "
						+ $editor + $upd );
			} else if ($isRed) {
				$icon = "rvRedChannel.png";
				$cmd = ("renderWindowEditor -edit -displayStyle \"color\" "
						+ "-scaleRed 1 -scaleGreen -1000 -scaleBlue -1000 "
						+ $editor + $upd );
			} else if ($isGreen) {
				$icon = "rvGreenChannel.png";
				$cmd = ("renderWindowEditor -edit -displayStyle \"color\" "
						+ "-scaleRed -1000 -scaleGreen 1 -scaleBlue -1000 "
						+ $editor + $upd );
			} else if ($isBlue) {
				$icon = "rvBlueChannel.png";
				$cmd = ("renderWindowEditor -edit -displayStyle \"color\" "
						+ "-scaleRed -1000 -scaleGreen -1000 -scaleBlue 1 "
						+ $editor + $upd );
			} else {
				$icon = "rvAllPlanes.png";
				$cmd = ("renderWindowEditor -edit -displayStyle \"color\" "
						+ "-scaleRed 1 -scaleGreen 1 -scaleBlue 1 "
						+ $editor + $upd );
			}
			iconTextButton -edit -i1 $icon -command $cmd rvAllPlanesButton;
		}
	}

	if ($menuType != "")
	{
		string $displayMenu = $editor + $menuType + "DisplayMenu";

		// Check if the menu has been constructed
		//
		if( `menu -q -ex $displayMenu` ){
			setParent -menu $displayMenu;

			// Update the display style and color channel radioButton menuItems.
			//
			menuItem -edit -radioButton $isRed   ($editor + "redPlaneItem");
			menuItem -edit -radioButton $isGreen ($editor + "greenPlaneItem");
			menuItem -edit -radioButton $isBlue  ($editor + "bluePlaneItem");
			menuItem -edit -radioButton $isRGB   ($editor + "allPlanesItem");
			menuItem -edit -radioButton $isLum   ($editor + "luminanceItem");
			menuItem -edit -radioButton $isMask  ($editor + "maskPlaneItem");

			// Update the dithered menuItem
			//
			int $dithered = !`renderWindowEditor -query -singleBuffer $editor`;
			menuItem -edit -checkBox $dithered ($editor + "ditheredItem");

			// Update the toolbar menuItem
			//
			int $isTool = isToolbarDisplayed();
			menuItem -edit -checkBox $isTool ($editor + "toolbarItem");
			int $rigsSupported = multipleCamerasSupported();
			if ( $rigsSupported  )
			{
				// Get the number of buffers display vs the number used for the current render: -viewImageCount
				//
				int $enableStereoDisplay = 1;
				int $imageCount = `renderWindowEditor -query -displayImageViewCount $editor`;
				if ($imageCount < 2)
					$enableStereoDisplay = 0;

				// If only 1 image disable stereo display menu
				//
				menuItem
					-edit
					-enable	$enableStereoDisplay
					($editor + $menuType + "StereoDisplayItem");

				setParent -menu ($editor + $menuType + "StereoDisplayItem");

				string $stereoMode = `renderWindowEditor -q -stereoMode $editor`;
				string $stereoOrient[] = `renderWindowEditor -q -stereoImageOrientation  $editor`;
				menuItem -edit
					-checkBox ($stereoMode == "redcyan")
					($editor + "Stereo_redcyan");
				menuItem -edit
					-checkBox ($stereoMode == "redcyanlum")
					($editor + "Stereo_redcyanlum");
				menuItem -edit
					-checkBox (($stereoMode == "both") && ($stereoOrient[0] == "normal"))
					($editor + "Stereo_parallel");
				menuItem -edit
					-checkBox (($stereoMode == "both") && ($stereoOrient[0] == "mirrored"))
					($editor + "Stereo_crossed");
				menuItem -edit
					-checkBox ($stereoMode == "leftonly")
					($editor + "Stereo_leftonly");
				menuItem -edit
					-checkBox ($stereoMode == "rightonly")
					($editor + "Stereo_rightonly");

				int $stereoSupported = `renderWindowEditor -q -stereo $editor`;
				menuItem -edit
					-checkBox ($stereoMode == "stereo")
					-enable $stereoSupported
					($editor + "Stereo_stereo");

				menuItem -edit -enable true ($editor + "redPlaneItem");
				menuItem -edit -enable true ($editor + "greenPlaneItem");
				menuItem -edit -enable true ($editor + "bluePlaneItem");

				if ($enableStereoDisplay)
				{
					if ($stereoMode == "redcyan" || $stereoMode == "redcyanlum")
					{
						menuItem -edit -enable false ($editor + "redPlaneItem");
						menuItem -edit -enable false ($editor + "greenPlaneItem");
						menuItem -edit -enable false ($editor + "bluePlaneItem");
					}
				}

				setParent -menu $displayMenu;

				menuItem -edit -enable true ($editor + "redPlaneItem");
				menuItem -edit -enable true ($editor + "greenPlaneItem");
				menuItem -edit -enable true ($editor + "bluePlaneItem");

				if ($enableStereoDisplay)
				{
					if ($stereoMode == "redcyan" || $stereoMode == "redcyanlum")
					{
						menuItem -edit -enable false ($editor + "redPlaneItem");
						menuItem -edit -enable false ($editor + "greenPlaneItem");
						menuItem -edit -enable false ($editor + "bluePlaneItem");
					}
				}
			}
		}
	}
}

// Update pop-up color mask menu before posting
global proc refreshRenderViewPlaneMenu( string $editor )
{
	// Update icon menu popup color masks to be disabled if
	// in anaglyph mode.
	//
	if (`menuItem -q -ex allPlanesMenuRed`)
	{
		menuItem -edit -enable true allPlanesMenuRed;
		menuItem -edit -enable true allPlanesMenuGreen;
		menuItem -edit -enable true allPlanesMenuBlue;
		int $rigsSupported = multipleCamerasSupported();
		if ( $rigsSupported  )
		{
			// Get the number of buffers display vs the number used for the current render: -viewImageCount
			//
			int $enableStereoDisplay = 1;
			int $imageCount = `renderWindowEditor -query -displayImageViewCount $editor`;
			if ($imageCount < 2)
				$enableStereoDisplay = 0;

			if ($enableStereoDisplay)
			{
				string $stereoMode = `renderWindowEditor -q -stereoMode $editor`;
				if ($stereoMode == "redcyan" || $stereoMode == "redcyanlum")
				{
					menuItem -edit -enable false allPlanesMenuRed;
					menuItem -edit -enable false allPlanesMenuGreen;
					menuItem -edit -enable false allPlanesMenuBlue;
				}
			}
		}
	}
}

// Updates the icons in the toolbar.
global proc refreshRenderViewIcons(string $editor)
{
	refreshDisplayMenu($editor, "");
}


// Description:  This procedure is called to create both the
//      "Display" pulldown menu in render view window and the
//      right mouse button click tear off window --> "Display"
//      meanu.
//
proc createDisplayMenu(string $editor, string $menuType)
{
	string $display = (uiRes("m_renderWindowPanel.kDisplay"));
	if ($menuType == "popup")
	{
		menuItem
			-subMenu				true
			-label 					$display
			-postMenuCommand ("renderWindowRefreshMenu \"display\" " + $editor)
			-familyImage 			"menuIconDisplay.png"
			($editor + $menuType + "DisplayMenu");
	}
	else
	{
		menu
			-label 					$display
			-tearOff				true
			-postMenuCommand ("renderWindowRefreshMenu \"display\" " + $editor)
			-familyImage 			"menuIconDisplay.png"
			($editor + $menuType + "DisplayMenu");
	}

	radioMenuItemCollection	("renderWindowPlanesCollection" + $menuType);

	string $col = "renderWindowPlanesCollection" + $menuType;
	string $upd = ";refreshRenderViewIcons(\""+$editor+"\")";
	menuItem -label (uiRes("m_renderWindowPanel.kRedChannel"))  -radioButton false -collection $col
		-command
			("renderWindowEditor -edit -displayStyle \"color\" "
				+ "-scaleRed 1 -scaleGreen -1000 -scaleBlue -1000 "
				+ $editor + $upd )
		-annotation
			(uiRes("m_renderWindowPanel.kDisplaytheredchannelAnnot"))
		($editor + "redPlaneItem");

	menuItem -label (uiRes("m_renderWindowPanel.kGreenChannel")) -radioButton false -collection $col
		-command
			("renderWindowEditor -edit -displayStyle \"color\" "
				+ "-scaleRed -1000 -scaleGreen 1 -scaleBlue -1000 "
				+ $editor + $upd )
		-annotation
			(uiRes("m_renderWindowPanel.kDisplaythegreenchannelAnnot"))
		($editor + "greenPlaneItem");

	menuItem -label (uiRes("m_renderWindowPanel.kBlueChannel")) -radioButton false -collection $col
		-command
			("renderWindowEditor -edit -displayStyle \"color\" "
				+ "-scaleRed -1000 -scaleGreen -1000 -scaleBlue 1 "
				+ $editor + $upd )
		-annotation
			(uiRes("m_renderWindowPanel.kDisplaytheblue"))
		($editor + "bluePlaneItem");

	menuItem -label (uiRes("m_renderWindowPanel.kAllChannels")) -radioButton false -collection $col
		-command
			("renderWindowEditor -edit -displayStyle \"color\" "
				+ "-scaleRed 1 -scaleGreen 1 -scaleBlue 1 "
				+ $editor + $upd )
		-annotation
			(uiRes("m_renderWindowPanel.kDisplaytheredAnnot"))
		($editor + "allPlanesItem");

	menuItem -divider true;

	menuItem -label (uiRes("m_renderWindowPanel.kLuminance")) -radioButton false -collection $col
		-command
			("renderWindowEditor -edit -displayStyle \"lum\" " + $editor+ $upd)
		-annotation
			(uiRes("m_renderWindowPanel.kDisplaytheluminanceAnnot"))
		($editor + "luminanceItem");

	menuItem -label (uiRes("m_renderWindowPanel.kAlphaChannel")) -radioButton false -collection $col
		-command
			("renderWindowEditor -edit -displayStyle \"mask\" " + $editor+$upd)
		-annotation
			(uiRes("m_renderWindowPanel.kDisplaythealphachannelAnnot"))
		($editor + "maskPlaneItem");

	menuItem -divider true;

	// Stereo display options
	//
	int $rigSupported = multipleCamerasSupported();
	if ( $rigSupported )
	{
		menuItem
			-subMenu	true
			-tearOff	false
			-label		(uiRes("m_renderWindowPanel.kStereoSettings"))
			-annotation
				(uiRes("m_renderWindowPanel.kStereoDisplayModeAnnotation"))
			($editor + $menuType + "StereoDisplayItem");

			string $stereoMode = `renderWindowEditor -q -stereoMode $editor`;

			menuItem -label (uiRes("m_renderWindowPanel.kCameraStereoModeAnaglyph"))
				-checkBox ($stereoMode == "redcyan")
				-command("setStereoMode \"" + $editor + "\" \"redcyan\"")
				($editor + "Stereo_redcyan");
			menuItem -label (uiRes("m_renderWindowPanel.kCameraStereoModeAnaglyphLum"))
				-checkBox ($stereoMode == "redcyanlum")
				-command("setStereoMode \"" + $editor + "\" \"redcyanlum\"")
				($editor + "Stereo_redcyanlum");

			string $stereoOrient[] = `renderWindowEditor -q -stereoImageOrientation $editor`;
			menuItem -label (uiRes("m_renderWindowPanel.kCameraStereoModeParallel"))
				-checkBox (($stereoMode == "both") && ($stereoOrient[0] == "normal"))
				-command("setStereoMode \"" + $editor + "\" \"parallel\"")
				($editor + "Stereo_parallel");
			menuItem -label (uiRes("m_renderWindowPanel.kCameraStereoModeCrossed"))
				-checkBox (($stereoMode == "both") && ($stereoOrient[0] == "mirrored"))
				-command("setStereoMode \"" + $editor + "\" \"mirrored\"")
				($editor + "Stereo_crossed");

			menuItem -label (uiRes("m_renderWindowPanel.kCameraStereoModeLeftOnly"))
				-checkBox ($stereoMode == "leftonly")
				-command("setStereoMode \"" + $editor + "\" \"leftonly\"")
				($editor + "Stereo_leftonly");
			menuItem -label (uiRes("m_renderWindowPanel.kCameraStereoModeRightOnly"))
				-checkBox ($stereoMode == "rightonly")
				-command("setStereoMode \"" + $editor + "\" \"rightonly\"")
				($editor + "Stereo_rightonly");
			menuItem -label (uiRes("m_renderWindowPanel.kCameraStereoModeStereo"))
				-checkBox  ($stereoMode == "stereo")
				-command ("setStereoMode \"" + $editor + "\" \"stereo\"")
				($editor + "Stereo_stereo");

			setParent -menu ..;
		menuItem -divider true;
	}

    // Render info users can choose to display in the render view caption.
    //
    menuItem
        -label (uiRes("m_renderWindowPanel.kRenderInfo"))
        -subMenu    true
        -tearOff    true
		($editor + "renderInfoItem");

        string $choiceName = "renderViewShowFrameNumber";
        int $choiceValue = 1;

        if (!`optionVar -exists $choiceName`)
        {
            optionVar -intValue $choiceName 1;
            $choiceValue = 1;
        }
        else
        {
            $choiceValue = `optionVar -query $choiceName`;
        }
    	menuItem -label (uiRes("m_renderWindowPanel.kFrameNumber")) -checkBox $choiceValue
    		-command		("renderWindowMenuCommand ShowFrameNumber " + $editor)
            -annotation     (uiRes("m_renderWindowPanel.kCheckeduncheckednumberAnnot"))
            ($editor + "frameNumberItem");

        $choiceName = "renderViewShowRenderTime";
        if (!`optionVar -exists $choiceName`)
        {
            optionVar -intValue $choiceName 1;
            $choiceValue = 1;
        }
        else
        {
            $choiceValue = `optionVar -query $choiceName`;
        }
    	menuItem 
		-label (uiRes("m_renderWindowPanel.kRenderTime")) 
		-checkBox $choiceValue
    		-command		("renderWindowMenuCommand ShowRenderTime " + $editor)
            -annotation   (uiRes("m_renderWindowPanel.kCheckedunchckedrenderAnnot"))
            ($editor + "renderTimeItem");

        $choiceName = "renderViewShowCameraName";
        if (!`optionVar -exists $choiceName`)
        {
            optionVar -intValue $choiceName 1;
            $choiceValue = 1;
        }
        else
        {
            $choiceValue = `optionVar -query $choiceName`;
        }
    	menuItem -label (uiRes("m_renderWindowPanel.kCameraName")) -checkBox $choiceValue
    		-command		("renderWindowMenuCommand ShowCameraName " + $editor)
            -annotation     (uiRes("m_renderWindowPanel.kCheckeduncheckedcameranameAnnot"))
            ($editor + "cameraNameItem");

        $choiceName = "renderViewShowLayerName";
        if (!`optionVar -exists $choiceName`)
        {
            optionVar -intValue $choiceName 1;
            $choiceValue = 1;
        }
        else
        {
            $choiceValue = `optionVar -query $choiceName`;
        }

    	menuItem -label (uiRes("m_renderWindowPanel.kLayerName")) -checkBox $choiceValue
    		-command		("renderWindowMenuCommand ShowLayerName " + $editor)
            -annotation    (uiRes("m_renderWindowPanel.kCheckedunlayerAnnot"))
            ($editor + "layerNameItem");

        $choiceName = "renderViewShowRenderTargetName";
        if (!`optionVar -exists $choiceName`)
        {
            // Default for render target render info is off.
            optionVar -intValue $choiceName 0;
            $choiceValue = 0;
        }
        else
        {
            $choiceValue = `optionVar -query $choiceName`;
        }

    	menuItem -label (uiRes("m_renderWindowPanel.kRenderTargetName"))
            -checkBox $choiceValue
    		-command ("renderWindowMenuCommand ShowRenderTargetName " + $editor)
            -annotation (uiRes("m_renderWindowPanel.kCheckedunrendertargetAnnot"))
            ($editor + "renderTargetNameItem");

    	menuItem -label (uiRes("m_renderWindowPanel.kCustomComment2"))
    	-command		("renderWindowMenuCommand customComment " + $editor)
            -annotation    (uiRes("m_renderWindowPanel.kEditcustomcommentAnnot"))
            ($editor + "customCommentItem");

    setParent -menu ..; // from Render Info menu

	menuItem -divider true;


	menuItem -label (uiRes("m_renderWindowPanel.kDithered")) -checkBox true
		-command		("renderWindowMenuCommand dithered " + $editor)
		-annotation		(uiRes("m_renderWindowPanel.kCheckedunimageAnnot"))
		($editor + "ditheredItem");

	menuItem -divider true;


	menuItem -label (uiRes("m_renderWindowPanel.kToolbar")) -checkBox true
		-command			("renderWindowMenuCommand toolbar " + $editor)
		-annotation (uiRes("m_renderWindowPanel.kShoworhidetoolbarAnnot"))
		($editor + "toolbarItem");

	setParent -menu ..; // from Display menu

    // update the menuItem information.
    //
    refreshDisplayMenu($editor, $menuType);
}

global proc renderWindowCreateCameraSubmenu(
	string	$subMenu,
	string	$command,
	string	$editor)
{
	popupMenu -edit -deleteAllItems $subMenu;
	// Set up the stereo plug-in
	if ( !`pluginInfo -query -loaded "stereoCamera"` )
		loadPlugin -qt "stereoCamera";
    python("from maya.app.stereo import stereoCameraRig");
    python("from maya.app.stereo import stereoCameraMenus");

	//
	//	Get the current model panel and then get the render view resolution.
	//
	string	$camera 		= `getCurrentCamera`;

	//
	//	Build items.
	//

	// Don't want stereo cameras for IPR menu
	int $iprMenu = `gmatch $subMenu "*Ipr*"`;

	setParent -menu $subMenu;

	//
	// Create a menu item for the current camera / camera rig
	//
	if( size($camera) != 0 )
	{
		string $currentCam = $camera;
		if ($iprMenu == 0)
		{
			$camRig = `renderWindowEditor -q -currentCameraRig $editor`;
			if (size($camRig))
				$currentCam = $camRig;
		}
		string $label = (uiRes("m_renderWindowPanel.kCurrentCam"));
		$label = `format -stringArg $currentCam $label`;
		menuItem -label $label -command ($command + $currentCam);
		menuItem -divider true ;
	}

	//
	// Create a menu item for each of the perspective cameras
    //
    string	$persps1[] = `listCameras -perspective`;

	// Filter out rig and non rig cameras.
	string $monoPersps[];
	string $stereoPersps[];
	string $stereoPerspsChildren[];
	int $numMono = 0;
	int $numStereo = 0;
	int $wantStereo = 0;
	if ($iprMenu == 0)
	{
		$wantStereo = multipleCamerasSupported();
	}

	// List all the mono cameras. If stereo is not enabled for this
	// menu, consider all cameras as mono.
	for( $camera in $persps1 )
	{
		if ((!$wantStereo) ||
			python("stereoCameraRig.rigRoot('"+$camera+"') == ''"))
		{
			menuItem -label $camera -command ($command + $camera);
		}
	}

	// Build the stereo rig menus
	if ($wantStereo) {
		menuItem -divider true;
		string $pyCmd = ("'"+$command+" %(arg1)s'");
		python("stereoCameraMenus.createStereoCameraSubmenus("+$pyCmd+","+$pyCmd+",True)");
	}

	menuItem -divider true;

	//
	// Create a menu item for each of the orthographic cameras
    //
    string	$orthos[] = `listCameras -orthographic`;

	for( $camera in $orthos )
	{
		menuItem -label $camera -command ($command + $camera);
	}
}

//////////////////////////////////////////////////////////////////////
//
//  Procedure Name:
//      buildRenderViewContextHelpItems
//
//  Description:
//		Build context sensitive menu items for the render view.
//
//  Input Arguments:
//		$nameRoot - name to use as the root of all item names
//		$menuParent - the name of the parent of this menu
//
//  Return Value:
//      None
//
global proc buildRenderViewContextHelpItems(string $nameRoot, string $menuParent)
{
	menuItem 
		-label (uiRes("m_renderWindowPanel.kHelponRenderView"))
		-enableCommandRepeat false
		-command "showHelp RenderView";
}

global proc renderWindowRefreshMenu(string $menu, string $editor)
{
	if ($menu == "file")
	{
		refreshFileMenu($editor, "menubar");
		refreshFileMenu($editor, "popup");
	}
	else if ($menu == "render")
	{
		refreshRenderMenu($editor, "menubar");
		refreshRenderMenu($editor, "popup");
	}
	else if ($menu == "ipr")
	{
		refreshIprMenu($editor, "menubar");
		refreshIprMenu($editor, "popup");
	}
	else if ($menu == "options")
	{
		refreshOptionsMenu($editor, "menubar");
		refreshOptionsMenu($editor, "popup");
	}
	else if ($menu == "view")
	{
		refreshViewMenu($editor, "menubar");
		refreshViewMenu($editor, "popup");
	}
	else if ($menu == "display")
	{
		refreshDisplayMenu($editor, "menubar");
		refreshDisplayMenu($editor, "popup");
	}
}

//---------------------------------------------------------------------------//
// Procedures which call the menu generation procedures and create other
// user interface elements within the render view window or panel
//---------------------------------------------------------------------------//

proc createMenubar(string $editor)
{
	createFileMenu($editor, "menubar");
	createViewMenu($editor, "menubar");
	createRenderMenu($editor, "menubar");
	createIprMenu($editor, "menubar");
	createOptionsMenu($editor, "menubar");

	// Make sure that stereo plugin is loaded before we create the Display menus
	// Can't do this for now as this seems to break OpenMaya vital tests !
	//string $oldParent = `setParent -q`;
	//if (!`pluginInfo -query -loaded "stereoCamera"`)
	//{
	//	loadPlugin -qt "stereoCamera";
	//}
	//setParent $oldParent;

	createDisplayMenu($editor, "menubar");
}

proc createPopupMenu(string $editor)
{
	popupMenu
		-button				3
		-parent				$editor
		-allowOptionBoxes	true
		($editor + "popupMenu");

	createFileMenu($editor, "popup");
	createViewMenu($editor, "popup");
	createRenderMenu($editor, "popup");
	createIprMenu($editor, "popup");
	createOptionsMenu($editor, "popup");
	createDisplayMenu($editor, "popup");
}

proc createLayout(string $editor)
{
	int $iconSize = 26;

	// Make sure that there is no template active
	setUITemplate -pushTemplate NONE;

	formLayout renderViewForm;
	formLayout renderViewToolbarForm;
	flowLayout renderViewToolbar;

     string $currentRendererName = currentRenderer();
     string $renUIName = `renderer -q -rendererUIName $currentRendererName`;

	string $annotMsg = (uiRes("m_renderWindowPanel.kRedoprevrenderAnnot"));
	 iconTextButton -i1 "rvRender.png" -width $iconSize -height $iconSize
		 -annotation (`format -s $renUIName $annotMsg`)
		 -command ("renderWindowRender redoPreviousRender " + $editor)
		 renderButton;
	 popupMenu -b 3 -alt false -p renderButton
		 -postMenuCommand ("renderWindowCreateCameraSubmenu RenderCameraMenu "+
						   "\"renderWindowRenderCamera render "+$editor+" \" "+
						   $editor)
		 RenderCameraMenu;
	string $annotRender = (uiRes("m_renderWindowPanel.kRenderregionlayoutAnnot"));
	 iconTextButton -i1 "rvRenderRegion.png" -width $iconSize -height $iconSize
		 -annotation (`format -s $renUIName $annotRender`)
		 -command ("renderWindowRenderRegion " + $editor)
		 renderRegionButton;

	 iconTextButton -i1 "rvSnapshot.png" -width $iconSize -height $iconSize
		 -annotation (uiRes("m_renderWindowPanel.kSnapshotlayoutAnnot"))
		 -command ("renderWindowRenderCamera snapshot " + $editor + " \"\"")
		 renderSnapshotButton;
	 popupMenu -b 3 -alt false -p renderSnapshotButton
		 -postMenuCommand ("renderWindowCreateCameraSubmenu SnapshotCameraMenu "+
						   "\"renderWindowRenderCamera snapshot "+$editor+" \" "+
						   $editor)
		 SnapshotCameraMenu;

	 separator -height $iconSize -horizontal false -style single rvSeparator1;

		string $prevrenderAnnot = (uiRes("m_renderWindowPanel.kRedoprevIPRrenderAnnot"));
	 iconTextButton -i1 "rvIprRender.png" -width $iconSize -height $iconSize
		 -annotation (`format -s $renUIName $prevrenderAnnot`)
		 -command ("renderWindowRender redoPreviousIprRender " + $editor)
		 iprRenderButton;
	 popupMenu -b 3 -alt false -p iprRenderButton
		 -postMenuCommand ("renderWindowCreateCameraSubmenu IprCameraMenu "+
						   "\"renderWindowRenderCamera iprRender "+$editor+" \" "+
						   $editor)
		 IprCameraMenu;
		string $renderiprimageAnnot = (uiRes("m_renderWindowPanel.kRefreshIPRimageAnnot"));
	 iconTextButton -i1 "rvIPRRefresh.png" -width $iconSize -height $iconSize
		 -enable false
		 -annotation (`format -s $renUIName $renderiprimageAnnot`)
		 -command "refreshIprImage"
		 refreshIprButton;

	 separator -height $iconSize -horizontal false -style single rvSeparator2;


	string $openrenderAnnot = (uiRes("m_renderWindowPanel.kOpenRenderAnnot"));
	 iconTextButton -i1 "rvRenderGlobals.png" -width $iconSize -height $iconSize
		 -annotation (`format -s $renUIName $openrenderAnnot`)
		 -command "unifiedRenderGlobalsWindow"
		 renderGlobalsButton;

	 separator -height $iconSize -horizontal false -style single rvSeparator3;

	 string $upd = ";renderWindowRefreshMenu(\"display\", \"" + $editor + "\")";
	 string $res = `iconTextButton -i1 "rvAllPlanes.png" -width $iconSize -height $iconSize
		 -annotation (uiRes("m_renderWindowPanel.kDisplayRGBChannelsAnnot"))
		 -command ("renderWindowEditor -edit -displayStyle \"color\" "
				   + "-scaleRed 1 -scaleGreen 1 -scaleBlue 1 "
				   + $editor + $upd )
		 rvAllPlanesButton`;
	 popupMenu -b 3 -alt false -p rvAllPlanesButton
		-postMenuCommand ("refreshRenderViewPlaneMenu(\"" + $editor + "\")")
		allPlanesMenu;
	 menuItem -label (uiRes("m_renderWindowPanel.kRGBChannels"))
		 -command ("renderWindowEditor -edit -displayStyle \"color\" -scaleRed 1 -scaleGreen 1 -scaleBlue 1 " + $editor + $upd);
	 menuItem -label (uiRes("m_renderWindowPanel.kRed"))
		 -command ("renderWindowEditor -edit -displayStyle \"color\" -scaleRed 1 -scaleGreen -1000 -scaleBlue -1000 " + $editor + $upd)
		 allPlanesMenuRed;
	 menuItem -label (uiRes("m_renderWindowPanel.kGreen"))
		 -command ("renderWindowEditor -edit -displayStyle \"color\" -scaleRed -1000 -scaleGreen 1 -scaleBlue -1000 " + $editor + $upd)
		 allPlanesMenuGreen;
	 menuItem -label (uiRes("m_renderWindowPanel.kBlue"))
		 -command ("renderWindowEditor -edit -displayStyle \"color\" -scaleRed -1000 -scaleGreen -1000 -scaleBlue 1 " + $editor + $upd)
		 allPlanesMenuBlue;
	 menuItem -label (uiRes("m_renderWindowPanel.kLuminanceLabel"))
		 -command ("renderWindowEditor -edit -displayStyle \"lum\" " + $editor + $upd);
	 eval($upd);

	 iconTextButton -i1 "rvMaskPlane.png" -width $iconSize -height $iconSize
		 -annotation (uiRes("m_renderWindowPanel.kDisplayAlphaChannelAnnot"))
		 -command ("renderWindowEditor -edit -displayStyle \"mask\" "
				   + $editor + $upd )
		 rvMaskButton;

	 iconTextButton -i1 "rvRealSize.png" -width $iconSize -height $iconSize
		 -annotation (uiRes("m_renderWindowPanel.kDisplayRealSizeAnnot"))
		 -command ("renderWindowEditor -edit -realSize " + $editor)
		 realSizeButton;

	 separator -height $iconSize -horizontal false -style single rvSeparator4;

	 iconTextButton -i1 "rvKeepIt.png" -width $iconSize -height $iconSize
		 -annotation (uiRes("m_renderWindowPanel.kKeepImageAnnot"))
		 -command ("renderWindowMenuCommand keepImageInRenderView " + $editor)
		 keepImageButton;

	    popupMenu -b 3 -alt false -p keepImageButton ;
        menuItem -label (uiRes("m_renderWindowPanel.kKeepImageLabel"))
		    -command ("renderWindowMenuCommand keepImageInRenderView " + $editor);
        menuItem -label (uiRes("m_renderWindowPanel.kKeepImagewithComment"))
    		-command		("renderWindowMenuCommand customComment " + $editor+"; "
                +
		        "renderWindowMenuCommand keepImageInRenderView " + $editor);


	 iconTextButton -i1 "rvRemoveIt.png" -width $iconSize -height $iconSize
		 -annotation (uiRes("m_renderWindowPanel.kRemoveImageAnnot"))
		 -command ("renderWindowMenuCommand removeImageFromRenderView " + $editor)
		 removeImageButton;

		popupMenu -b 3 -alt false -p removeImageButton ;
        menuItem -label (uiRes("m_renderWindowPanel.kRemoveCurrentImage"))
		    -command ("renderWindowMenuCommand removeImageFromRenderView " + $editor);
        menuItem -label (uiRes("m_renderWindowPanel.kRemoveAllImages"))
    		-command		("renderWindowMenuCommand removeAllImagesFromRenderView " + $editor);

	 separator -height $iconSize -horizontal false -style single rightSeparator;

	 // Renderer selection option menu

	 string $renderers[] = `renderer -query -namesOfAvailableRenderers`;
	 string $rendererUIName = "";

	 optionMenu -height $iconSize
		 -annotation (uiRes("m_renderWindowPanel.kSelectRendererAnnot"))
		 -cc  "updateCurrentRendererSel(\"rendererSelOptionMenu\")"
		 rendererSelOptionMenu;

	 for ($i = 0; $i < size($renderers); $i += 1)
	 {
		 $rendererUIName = `renderer -query -rendererUIName $renderers[$i]`;
		 menuItem -l $rendererUIName -enableCommandRepeat false ("rendererSelOptionMenuItem" +$i);
	 }

	 // Update the Renderer selection option box to reflect current renderer
	 //
	 for ($i = 0; $i < size($renderers); $i++)
	 {
		 if($renderers[$i] == currentRenderer())
		 {
			 optionMenu -edit -select ($i+1) rendererSelOptionMenu;
		 }
	 }

	 separator -height $iconSize -horizontal false -style single 
                 renderTargetSeparator;

    // ADSK_CLR_MGT_GAM_EXP_BEGIN

    // When we open the renderview, we reset the gamma and exposure toggles
    resetRVTogleStates();
    resetColorManagementControlRange();
 
    rowLayout -numberOfColumns 3
              -columnAttach3 "both" "both" "both"
    renderExposureGroup;
 
        iconTextButton
            -version "2016"
            -i1 "rvExposureControlIcon.png"
            -width $iconSize
            -height $iconSize
            -marginWidth 0
            -marginHeight 0
            -command ("toggleRenderViewExposure")
            exposureRenderViewImageButton;
        
        floatField
            -value 0.0
            -precision 2
            -width 40
            -step 0.1
            -changeCommand "resetRVExposureTogleState; updateRenderViewExposureSlider"
            -dragCommand "resetRVExposureTogleState; updateRenderViewExposureSlider"
            exposureRenderViewFieldItem;
            
        floatSlider
            -value 0.5
            -height 27
            -width 80
            -min 0.0 -max 1.0
            -changeCommand "resetRVExposureTogleState; updateRenderViewExposureField"
            -dragCommand "resetRVExposureTogleState; updateRenderViewExposureField"
            exposureRenderViewSliderItem;
 
    setParent ..;
 
    rowLayout -numberOfColumns 3
              -columnAttach3 "both" "both" "both"
    renderGammaGroup;
 
        iconTextButton
            -version "2016"
            -i1 "rvGammaControlIcon.png"
            -width $iconSize
            -height $iconSize
            -marginWidth 0
            -marginHeight 0
            -command ("toggleRenderViewGamma")
            gammaRenderViewImageButton;
 
        floatField
            -value 1.0
            -minValue 0.0
            -precision 2
            -width 40
            -step 0.1
            -changeCommand "resetRVGammaTogleState; updateRenderViewGammaSlider"
            -dragCommand "resetRVGammaTogleState; updateRenderViewGammaSlider"
            gammaRenderViewFieldItem;
                
        floatSlider
            -value 0.5
            -height 27
            -width 80
            -min 0.0 -max 1.0
            -changeCommand "resetRVGammaTogleState; updateRenderViewGammaField"
            -dragCommand "resetRVGammaTogleState; updateRenderViewGammaField"
            gammaRenderViewSliderItem;
            
    setParent ..;
 
    updateRenderViewGammaState();
    updateRenderViewExposureState();
    // ADSK_CLR_MGT_GAM_EXP_END

    // ADSK_CLR_MGT_BEGIN

    // On mapping to the screen, set the renderWindowEditor color management
    // state to match the global color management state.
    int $cmEnabled = `colorManagementPrefs -query -cmEnabled`;
    string $editorViewTransformName = `colorManagementPrefs -q -viewTransformName`;
    renderWindowEditor -e -cmEnabled $cmEnabled $editor;
    renderWindowEditor -e -viewTransformName $editorViewTransformName $editor;
   
    rowLayout -numberOfColumns 2
              -columnAttach2 "both" "both"
    renderViewTransformGroup;

        symbolCheckBox
            -onImage "rvViewingPipelineOn.png"
            -offImage "rvViewingPipelineOff.png"
            -width $iconSize
            -height $iconSize
            -changeCommand "renderWindowEditor -e -cmEnabled #1 renderView"
            -enable $cmEnabled
            -value $cmEnabled
            renderViewEnableButton;
        
        optionMenu
            -height $iconSize
            -changeCommand "onRVViewTransformMenuChange"
            renderViewViewTransformSelOptionMenu;
            
    setParent ..;
   
    string $viewTransformNames[] = `colorManagementPrefs -q -viewTransformNames`; 
    int $i, $numNames = size($viewTransformNames);
    for($i = 0 ; $i < $numNames ; $i++)
    {
        menuItem -label $viewTransformNames[$i];
    }
   
    optionMenu -e -v $editorViewTransformName renderViewViewTransformSelOptionMenu;

    scriptJob -event "colorMgtEnabledChanged" onRVColorMgtEnableChange;
    scriptJob -event "colorMgtPrefsReloaded" "onRVColorMgtEnableChange; updateRenderViewTransformSelMenu";
    scriptJob -event "colorMgtConfigChanged" updateRenderViewTransformSelMenu;
    scriptJob -event "colorMgtPrefsViewTransformChanged" updateRenderViewTransformSelMenu;
    // ADSK_CLR_MGT_END

    global string $gRenderPassLockUnlockImage[];
    int $forceRender = getRenderTargetForceDependenciesRender();
    iconTextButton -i1 $gRenderPassLockUnlockImage[$forceRender]
      -width $iconSize -height $iconSize -annotation
      (uiRes("m_renderWindowPanel.kRenderPassLockUnlockAnnot"))
      -c toggleRenderTargetForceDependenciesRender renderPassLockUnlockButton;
    scriptJob -event SceneOpened "setRenderTargetForceDependenciesRender 1"
      -parent $editor;

     // Show the current render layer.
     //
     string $currentRenderLayer = currentRenderLayerLabel();
     text -height $iconSize -label $currentRenderLayer -align "left" currentRenderLayerName;

     scriptJob -event renderLayerManagerChange ("updateRenderViewForRenderLayerChange "+$editor)
        -parent $editor;
     scriptJob -event renderLayerChange ("updateRenderViewCurrentRenderLayerLabel "+$editor)
        -parent $editor;

     // Show the current render target.
     //
     text -height $iconSize -label "" -align "left" currentRenderTargetName;
     updateRenderViewCurrentRenderTarget($editor);

	 // Create and populate render target selection menu.
     menu -l (uiRes("m_renderWindowPanel.kRenderTarget"))
       -postMenuCommand populateRenderTargetMenu renderTargetMenu;

	 populateRenderTargetMenu();
     setRenderTargetSupport();

	 setParent ..;

	 iconTextCheckBox -i1 "rvPauseIprTuning.png" -width $iconSize -height $iconSize
		 -enable false
		 -annotation (uiRes("m_renderWindowPanel.kPauseIPRTuning2Annot"))
		 -onCommand ("renderViewTogglePauseIpr " + $editor)
		 -offCommand ("renderViewTogglePauseIpr " + $editor)
		 pauseIprButton;

	 text -label (uiRes("m_renderWindowPanel.kIPR0MB"))  iprMemEstText;

	 iconTextButton -i1 "rvIPRStop.png" -width $iconSize -height $iconSize
		 -enable false
		 -annotation (uiRes("m_renderWindowPanel.kCloseIPRFileTuningAnnot"))
		 -command ("stopIprRendering " + $editor)
		 closeIprButton;

	 int $margin = 1;

	 formLayout
		 -edit

		 -attachForm    "renderViewToolbar"   	"left"	 $margin
		 -attachControl "renderViewToolbar"   	"right"  $margin "pauseIprButton"
		 -attachForm    "renderViewToolbar"   	"top"	 $margin
		 -attachForm    "renderViewToolbar"   	"bottom" $margin

		 -attachNone	"closeIprButton"	"left"
		 -attachForm    "closeIprButton"	"right"	 $margin
		 -attachForm 	"closeIprButton"	"top"	 $margin
		 -attachForm 	"closeIprButton"	"bottom" $margin

		 -attachNone	"iprMemEstText"		"left"
		 -attachControl "iprMemEstText"		"right"  $margin "closeIprButton"
		 -attachForm 	"iprMemEstText"		"top"	 $margin
		 -attachForm 	"iprMemEstText"		"bottom" $margin

		 -attachNone	"pauseIprButton"	"left"
		 -attachControl "pauseIprButton"	"right"  $margin "iprMemEstText"
		 -attachForm 	"pauseIprButton"	"top"	 $margin
		 -attachForm 	"pauseIprButton"	"bottom" $margin
		 renderViewToolbarForm;
	 setParent ..;

	 formLayout editorForm;

	 renderWindowEditor
		 -edit
		 -parent "editorForm"
		 $editor;
	 formLayout
		 -edit
		 -attachForm	$editor	"left"		0
		 -attachForm	$editor	"right"		0
		 -attachForm	$editor	"top"		0
		 -attachForm	$editor	"bottom"	0
		 editorForm;
	setParent ..;

	formLayout scrollBarForm;
	intScrollBar
		-step 1
		-largeStep 1
		-height	15
		-horizontal true
		-changeCommand ("renderWindowScrollDisplayImage " + $editor)
		scrollBar;

	formLayout
		-edit
		-attachForm	"scrollBar"	"left"		0
		-attachForm	"scrollBar"	"right"		0
		-attachForm	"scrollBar"	"top"		0
		-attachForm	"scrollBar"	"bottom"	0
		scrollBarForm;
	setParent ..;

	formLayout
		-edit

		-attachForm		"renderViewToolbarForm"		"left"		0
		-attachForm		"renderViewToolbarForm"		"right"		0
		-attachForm		"renderViewToolbarForm"		"top"		0
		-attachNone		"renderViewToolbarForm"		"bottom"

		-attachForm		"editorForm"		"left"		0
		-attachForm		"editorForm"		"right"		0
		-attachControl	"editorForm"		"top"		0 "renderViewToolbarForm"
		-attachControl	"editorForm"		"bottom"	0 "scrollBarForm"

		-attachForm		"scrollBarForm"		"left"		0
		-attachForm		"scrollBarForm"		"right"		0
		-attachNone		"scrollBarForm"		"top"
		-attachForm		"scrollBarForm"		"bottom"	0

		renderViewForm;

	createPopupMenu($editor);

	setUITemplate -popTemplate;
}

// Description:  This procedure is called to refresh the renderer specific
//  UIs in the render view window.
//
proc renderWindowRendererSpecificRefresh(string $panel)
{
    string $oldParent = `setParent -q`;
    setParent $panel;
     string $currentRendererName = currentRenderer();
     string $renUIName = `renderer -q -rendererUIName $currentRendererName`;

	// Refresh captions of render buttons to update current renderer tag
	//
	string $redoAnnot = (uiRes("m_renderWindowPanel.kRedopreviousrender2Annot"));
	iconTextButton -edit
		-annotation (`format -s $renUIName $redoAnnot`)
		renderButton;
	string $renderAnnot = (uiRes("m_renderWindowPanel.kRenderregionAnnot"));
	iconTextButton -edit
		-annotation (`format -s $renUIName $renderAnnot`)
		renderRegionButton;
	string $settingsAnnot = (uiRes("m_renderWindowPanel.kOpenrendersettingswindow"));
	iconTextButton -edit
		-annotation (`format -s $renUIName $settingsAnnot`)
		renderGlobalsButton;

    // Update IPR related buttons.
    //
	if (`renderer -query -iprRenderProcedure $currentRendererName` != "")
	{
		// enable IPR related UI if current renderer supports IPR
		//
		string $iprredoAnnot = (uiRes("m_renderWindowPanel.kRedopreviousIPRrender1Annot"));
		iconTextButton -edit
			-enable true
			-annotation (`format -s $renUIName $iprredoAnnot`)
			iprRenderButton;

	    global int $gIprTuningPaused;

        // When we first switch the renderer, pause tuning and
        // refresh IPR should be off.
        //
        $gIprTuningPaused = false;
		iconTextCheckBox -edit -enable false
            -value ($gIprTuningPaused)
			-annotation (uiRes("m_renderWindowPanel.kPauseIPRtuning1Annot"))
            pauseIprButton;
        string $refreshAnnot = (uiRes("m_renderWindowPanel.kRefreshIPRimageWindowAnnot"));
		iconTextButton -edit
			-enable false
			-annotation (`format -s $renUIName $refreshAnnot`)
			refreshIprButton;
	}
	else
	{
		string $commonAnnot = (uiRes("m_renderWindowPanel.kNotavailablerenderer"));
		// If the current renderer does not support IPR, disable all
		// ipr related UI
		//
		text -edit -enable false iprMemEstText;

		iconTextButton -edit
			-enable false
			-annotation $commonAnnot
			closeIprButton;

		iconTextCheckBox -edit
			-enable false
			-annotation $commonAnnot
			pauseIprButton;

		iconTextButton -edit
			-enable false
			-annotation $commonAnnot
			refreshIprButton;

		iconTextCheckBox -edit -value false pauseIprButton;

		iconTextButton -edit
			-enable false
			-annotation $commonAnnot
			iprRenderButton;
	}

    // Update IPR related menus.
    //
	renderWindowRefreshMenu("ipr",$panel);


	string $renderers[] = `renderer -query -namesOfAvailableRenderers`;

	// Check for any updates in the renderer list
	//
	int $numItems = `optionMenu -query -numberOfItems rendererSelOptionMenu`;

	// Make sure all the renderers are being shown in the option menu
	//
	if($numItems != size($renderers))
	{

		setParent -menu rendererSelOptionMenu;

		string $menuItemNames[] = `optionMenu -query -itemListLong rendererSelOptionMenu`;

		// Remove all the menuItems and create new ones to reflect the
		// renderers currently available
		//
		for ($i = 0; $i < size($menuItemNames); $i++)
		{
			deleteUI $menuItemNames[$i];
		}

		for ($i = 0; $i < size($renderers); $i++)
		{
            $rendererUIName = `renderer -query -rendererUIName $renderers[$i]`;
			menuItem -l $rendererUIName -enableCommandRepeat false
				("rendererSelOptionMenuItem" +$i);
		}

		setParent ..;

	}

	// Update the Renderer selection option box to reflect current renderer
	//

	for ($i = 0; $i < size($renderers); $i++)
	{
		if($renderers[$i] == currentRenderer())
		{
			optionMenu -edit -select ($i+1) rendererSelOptionMenu;
		}
	}

    // Disable the render target menu if the current renderer doesn't
    // support it.
    setRenderTargetSupport();
    setParent $oldParent;
}

global proc renderWindowRefreshLayout(string $editor)
{
	setParent $editor;

	formLayout -edit -manage `isToolbarDisplayed` renderViewToolbarForm;

	//
	// Refresh the scroll bar
	//

	// Determine how many images are stored in the buffer
	//
	int $numImages = `renderWindowEditor -query -nbImages $editor`;

	// Determine what the index of the current image is
	//
	int $currImage = `renderWindowEditor -query -displayImage $editor`;

	if ($numImages > 0)
	{
		// There is at least one image in the buffer, so we should display the
		// scroll bar with appropriate max, min and index.
		//
		intScrollBar -edit -manage true
			-min -1 -max ($numImages - 1) -value $currImage
			scrollBar;
	}
	else
	{
		// There aren't any images in the buffer.
		// Hide the scroll bar.
		//
		intScrollBar
			-edit
			-manage	false
			scrollBar;
	}
}

//---------------------------------------------------------------------------//
// Procedures which are accessed from outside the renderview
//---------------------------------------------------------------------------//

proc matchViewportStereoModeDisplay( string $editor )
{
	// Switch the display mode to match the model view if possible.
	string $modelViewMode = `stereoCameraView -q -displayMode $editor`;
	string $renderPanel = `getRenderWindowPanel`;

	if (!size($modelViewMode) || !size($renderPanel))
		return;

	if ($modelViewMode == "active")
	{
		setStereoMode( $renderPanel, "stereo" );
	}
	else if ($modelViewMode == "anaglyph")
	{
		setStereoMode( $renderPanel, "redcyan" );
	}
	else if ($modelViewMode == "anaglyphLum")
	{
		setStereoMode( $renderPanel, "redcyanlum" );
	}
	else if ($modelViewMode == "freeview")
	{
		setStereoMode( $renderPanel, "parallel" );
	}
	else if ($modelViewMode == "freeviewX")
	{
		setStereoMode( $renderPanel, "mirrored" );
	}
	else
	{
		// Not everything matches currently, so put out a warning to tell the
		// user that we are going to switch to anaglyph mode.
		warning((uiRes("m_renderWindowPanel.kNoStereoModeMatch")));
		setStereoMode( $renderPanel, "redcyan" );
	}
}

global proc renderIntoNewWindow(string $renderMode)
{
	// Determine what model panel the user wants to render.
	//
	string $currentPanel = `getPanel -wf`;
	string $camera = "";

	if( `getPanel -to $currentPanel` != "modelPanel" )
	{
		if (`getPanel -to $currentPanel` == "scriptedPanel") {
			// It is potentially a Paint Effects panel.
			int $isCustomView = 0;
			string $scriptedType = `scriptedPanel -q -type $currentPanel`;
			$isCustomView =
				`scriptedPanelType -q -customView $scriptedType`;

			if ( $isCustomView ) {
				// We assume the editor name follows the pattern,
				// panelName + "Editor". In the future, we may want
				// to abstract this a bit to make it arbitrary.
				//
				$editor = $currentPanel + "Editor";
				$camera = `modelEditor -query -camera $editor`;
				// Get rig if not doing IPR rendering
				if ($renderMode != "iprRender")
				{
					$cameraRig = `getParentCameraRig $camera`;
					if (size($cameraRig))
					{
						$camera = $cameraRig;

						// Switch render view to use the viewport's stereo mode if possible.
						matchViewportStereoModeDisplay $editor;
					}
				}
			}

			if ( `scriptedPanel -q -l $currentPanel` == "Paint Effects" ) {
				// It is! It is a Paint Effects panel. Get the name of
				// the camera we are using.
				if (`about -mac`) {
				    // Temporary fix for 4.5. getPanel needs to be
				    // properly fixed in 5.0 for Mac.
					string $dynPanel = `getPanel -containing dynPaintScriptedPanelEd`;
				    if ((size($dynPanel) != 0)) {
						$camera = `dynPaintEditor -query -camera dynPaintScriptedPanelEd`;
					}
				} else {
						$camera = `dynPaintEditor -query -camera dynPaintScriptedPanelEd`;
				}
			}
		}

		// Check if there's only 1 model panel visible.
		// If so, render that darn panel even if it's not selected!
		//
		string $visiblePanels[] = `getPanel -vis`;
		int $numberOfModelPanels = 0;
		int $modelPanelIndex;
		int $isCustomView = 0;
		int $i;
		for ($i=0 ; $i<size($visiblePanels) ; $i++){
			string $panel = $visiblePanels[$i];
			string $type = `getPanel -to $panel`;
			if ( $type == "scriptedPanel" ) {
				string $scriptedType = `scriptedPanel -q -type $panel`;
				$isCustomView =
					`scriptedPanelType -q -customView $scriptedType`;
			}

			if( $type == "modelPanel" || $isCustomView ){
				$numberOfModelPanels++;
				$modelPanelIndex = $i;
			}
		}
		if ($numberOfModelPanels == 1){

			int $isCustomView = 0;
			string $panel = $visiblePanels[$modelPanelIndex];
			string $type = `getPanel -to $panel`;
			if ( $type == "scriptedPanel" ) {
				string $scriptedType = `scriptedPanel -q -type $panel`;
				$isCustomView =
					`scriptedPanelType -q -customView $scriptedType`;
			}

			if ( $isCustomView ) {
				// We assume the editor name follows the pattern,
				// panelName + "Editor". In the future, we may want
				// to abstract this a bit to make it arbitrary.
				//
				$editor = $visiblePanels[$modelPanelIndex] + "Editor";
				$camera = `modelEditor -query -camera $editor`;
				if ($renderMode != "iprRender")
				{
					$cameraRig = `getParentCameraRig $camera`;
					if (size($cameraRig))
					{
						$camera = $cameraRig;

						// Switch render view to use the viewport's stereo mode if possible.
						matchViewportStereoModeDisplay $editor;
					}
				}
			} else {
				$camera = `modelPanel -query -camera $visiblePanels[$modelPanelIndex]`;
			}

		}
		string $okButton = (uiRes("m_renderWindowPanel.kOK2"));
		if ($camera == "") {
			confirmDialog
				-message (uiRes("m_renderWindowPanel.kSelectrenderMessage"))
				-button   $okButton
				-defaultButton $okButton;
			return;
		}
	}
	else
	{
		// Find out what the current camera is
		//
		$camera = `modelPanel -query -camera $currentPanel`;
	}

	// Get the render view.
	//
	string $editor = `getRenderWindowPanel`;

	//
	// If not tore off, do It !
	//
	if( !`scriptedPanel -q -tearOff $editor` )
	{
		scriptedPanel -e -tearOff $editor;
	}

	//
	//	Now gets the right resolution.
	//
	int		$res[] = `getTestResolution( $currentPanel )`;

	//
	//	If the render view is too small, resize it.
	//
	string	$renderWindowControl = `scriptedPanel -q -control $editor`;
	string	$renderWindow;
	string	$buffer[];

	tokenize( $renderWindowControl, "|", $buffer );
	$renderWindow = $buffer[0];

	int		$width = `control -q -w $renderWindowControl`;
	int		$height = `control -q -h $renderWindowControl`;

	$width -= 40;
	$height -= 120;

	if( $width < $res[0] || $height < $res[1] )
	{
		$width = $res[0] + 40;
		$height = $res[1] + 120;
		window -e -w $width -h $height -retain $renderWindow;
	}

	//
	//	Render the current camera panel at the test resolution...
	//
	showWindow $renderWindow;

	renderWindowRenderCamera($renderMode, $editor, $camera);
}


//	This one can be used by hotkeys to check whether the render view is
//	visible or not before calling redoLastRender procedure.
//
global proc redoPreviousRender(string $renderMode)
{
	string $editor = `showRenderView`;
	renderWindowRender($renderMode, $editor);
}

global proc renderWindowScrollDisplayImage(string $editor)
{
	int $index  = `intScrollBar -query -value scrollBar`;
	renderWindowEditor -edit -displayImage $index $editor;
	renderWindowRefreshMenu("file", $editor);
}


//---------------------------------------------------------------------------//
// Procedures which support scripted panel capability
//---------------------------------------------------------------------------//

global proc createRenderWindowPanel(string $whichPanel)
{
    renderWindowEditor  -unParent  $whichPanel ;

	//
	//	Set the options variables.
	//
	setRenderOptionVars;

	//	Adds support for the Context Sensitive Help Menu.
	//
	addContextHelpProc $whichPanel "buildRenderViewContextHelpItems";
}

global proc addRenderWindowPanel(string $editor)
{
	//
	//  Build Menubar.
	//
	createMenubar($editor);

	// Create the layout of the renderview
	//
	createLayout($editor);
	renderWindowRefreshLayout($editor);

	//
	//	Tells the renderWindowEditor what the renderViewAutoResize value
	//	is.
	//
	$var = `optionVar -q renderViewAutoResize`;
	renderWindowEditor -e -ar $var $editor;
}

global proc removeRenderWindowPanel(string $whichPanel)
{
	// If the current renderer was in IPR mode, then stop previous IPR.
    //
    if (isRunningIpr())
    {
        // Stop previous IPR.
        //
        string  $panel = `getRenderWindowPanel`;
        stopIprRendering($panel);
    }

    renderWindowEditor -e -unParent $whichPanel ;
}


global proc renderWindowPanel(string $panelName)
//
//  Description:
//		This proc defines the render window panel type and instantiates
//		one.
//
{
	global string $gMainPane;

	//  Define the type of panel and its callbacks
	//
	if (!`scriptedPanelType -exists renderWindowPanel`)
	{
		scriptedPanelType
			-unique true
			-createCallback 	"createRenderWindowPanel"
			-addCallback 		"addRenderWindowPanel"
			-removeCallback 	"removeRenderWindowPanel"
			renderWindowPanel;

	    //  Create an instance of the render window panel
		//
		setParent $gMainPane;
		scriptedPanel -unParent -type "renderWindowPanel" $panelName;
	}
}


//
// Description:
//		This procedure is called by TrenderWindowSelectCtx.cc that defines
//	a region. It checks if a region can be rendered.
//
global proc renderWindowCheckAndRenderRegion
 ( float	$top,
   float	$left,
   float	$bottom,
   float	$right )
{
	//
	//	If there's no current camera (first render), do what has to be
	//	done...
	//
	string	$renderPanel = `getRenderWindowPanel`;
	int		$snapped = 0;

	if ( !isRunningIpr() ) {
		if( `renderWindowEditor -q -currentCamera $renderPanel` == "" )
		{
			//
			//	Take a snapshot of the first persp camera found.
			//
			string $cameras[] = `listCameras -perspective`;

			if( size($cameras) )
			{
				string	$camera = $cameras[0];
				string	$panel = `getCameraPanel( $camera )`;
				int		$res[] = `getTestResolution( $panel )`;

				renderWindowTakeSnapshot( $res[0], $res[1], $camera );
				$snapped = 1;
			}
			else
			{
				$cameras = `listCameras`;

				if( size($cameras) )
				{
					string	$camera = $cameras[0];
					string	$panel = `getCameraPanel( $camera )`;
					int		$res[] = `getTestResolution( $panel )`;

					renderWindowTakeSnapshot( $res[0], $res[1], $camera );
					$snapped = 1;
				}
			}
		}
		else {
			$snapped = 1;
		}
	} else
		$snapped = 1;


	//
	//	Otherwise, set the region and render if the renderViewAutoRenderRegion
	//	is set to true.
	//
	if( $snapped )
	{
		renderWindowEditor -e -mq $top $left $bottom $right $renderPanel;

		// We can't autoRenderRegion if ipr is on
		if( `optionVar -exists renderViewAutoRenderRegion` &&
			`optionVar -query renderViewAutoRenderRegion` != 0 
			&& !isRunningIpr()
			)
		{
				string $editor = `showRenderView`;

				renderWindowRenderRegion($editor);
		}

	}

	if (isRunningIpr())
    {
        // Change the region for IPR
        //
        string $changeIprRegionProc =
            `renderer -q -changeIprRegionProcedure (currentRenderer())`;
        eval $changeIprRegionProc $renderPanel;
    }
}

//
// Description:
//			This procedure is called when an image is to be rendered using
//			the maya renderer. It is used to standardize the render command
//			calls , since not all renderers take the same arguments
// 	Returns: render result
//
global proc string mayaSoftwareRender(int $width, int $height, int $doShadows,
									  int $doGlowPass, string $camera,
									  string $option)
{
	string $cmd = "render -x " + $width + " -y " + $height + " -nsh " + $doShadows
				+ " -ngl " + $doGlowPass + " " + $option + " " + $camera ;
	string $result = eval ($cmd);
	return $result;
}

global proc string mayaSoftwareIprRender(int $width, int $height, int $doShadows,
									  int $doGlowPass, string $camera)
{
	return mayaSoftwareRender($width, $height, $doShadows, $doGlowPass, $camera, "");
}

//
// Description:
//			Checks if the current render supports the reder region feature
//			and if so, calls the render region procedure for the current renderer.
//	Returns: None
//
global proc renderWindowRenderRegionCommon(string $editor)
{
	string $renderer = currentRenderer();

	// if render region is support calls the corresponding
	// procedure for the current renderer
	//
	string $command = `renderer -query -renderRegionProcedure $renderer`;
    if ($command != "")
	{
		// Disallow render region if viewing multiple images at the same time
		//
		int $imageCount = `renderWindowEditor -query -viewImageCount $editor`;
		int $disallowRender = 0;
		if ($imageCount > 1)
		{
			string $stereoMode = `renderWindowEditor -q -stereoMode $editor`;
			if ($stereoMode == "both")
			{
				warning((uiRes("m_renderWindowPanel.kNoRenderRegionInFreeView")));
				$disallowRender = 1;
			}
		}
		if (!$disallowRender)
		{
			// Suspend material view renderer while Render View rendering is running
			renderer -materialViewRendererSuspend true;

			float $startTime = `timerX`;
			catch($result = `eval $command $editor`);
			float $renderTime = `timerX -startTime $startTime`;

			// Resume material view renderer
			renderer -materialViewRendererSuspend false;

			string $renUIName = renderWindowCaption((uiRes("m_renderWindowPanel.kRegionCaption")), $renderTime);
			renderWindowEditor -edit -pca $renUIName $editor;
		}
    }
    else
    {
		// Feature not supported: report error
		//
		string $renderWarn = (uiRes("m_renderWindowPanel.kCurrentrenderWarn"));
	    warning (`format -s $renderer $renderWarn`);
	}
}

//
// Description:
//			Entry point for render region command called from UI
//	Returns: None
//
global proc renderWindowRenderRegion(string $editor)
{
	renderWindowRenderRegionCommon($editor);
}


//
// Description:
//			This procedure is called when a render region command is issued
//			for the maya software renderer. It is used to standardize the render
//			command calls , since not all renderers take the same arguments
// 	Returns: render result
//
global proc mayaRenderRegion(string $editor)
{
	string $cmd = "renderWindowRender renderRegion";
	eval $cmd $editor;
}


//
// Description: Builds the "Render Using" Menu to allow for renderer selection
// Returns: None
//
global proc buildRenderUsingMenu
 ( string $subMenuName,
   string $panelName )
{
	popupMenu -e -deleteAllItems $subMenuName;
	setParent -m $subMenuName;

	string $renderers[] = `renderer -query -namesOfAvailableRenderers`;
	int $isCurrent   = 0;
	string $funcName = "";
	string $rendererUIName = "";

	radioMenuItemCollection	("renderWindowRenderUsingCollection"+$subMenuName);

	for ($i = 0; $i < size($renderers); $i += 1)
	{
		$isCurrent = 0;
		if($renderers[$i] == currentRenderer()) $isCurrent = 1;

		$funcName = "setCurrentRenderer " + $renderers[$i];
        $rendererUIName = `renderer -query -rendererUIName $renderers[$i]`;

		menuItem -l $rendererUIName
			 -radioButton $isCurrent
			 -collection ("renderWindowRenderUsingCollection" + $subMenuName)
			 -c  $funcName
			 ($panelName + "renderUsingItem" + $i);
	}
}

//
// Description: Called when UI specific to the current renderer has to be
// updated (usually when current renderer is changed).
//
// Returns:	None.
//
global proc updateRenderWindowPanelRendererSpecificUI()
{

	string  $panel = `getRenderWindowPanel`;
	string	$renderWindowControl = `scriptedPanel -q -control $panel`;
	string	$renderWindow;
	string	$buffer[];
	tokenize( $renderWindowControl, "|", $buffer );
	$renderWindow = $buffer[0];

	string $renderWindowExists = `window -ex $renderWindow`;

	if($renderWindowExists)
	{
		// Make sure the option menu exists.
		// The only time the render window panel is open and the
		// option menu does not exist is when the render window panel
		// is open on plug-in load
		//
		if(!`optionMenu -query -exists rendererSelOptionMenu`)
		{
			string	$parent;

			// Get the name of the parent (i.e one level above
			// $renderWindowControl). In order to do this we break up the name
			// and re-assemble it leaving out the last control.
			//
			$parent = $buffer[0];

			for($i = 1; $i < size($buffer) - 1; $i++)
			{
				$parent = $parent + "|" + $buffer[$i];
			}

			// In order to update all the menu toolbar, the panel is removed and
			// inserted back
			//
			scriptedPanel -edit -unParent $panel;
			scriptedPanel -edit -parent $parent $panel;

		}

        // Stop all Ipr render.
        //
        stopIprRendering($panel);
		renderWindowRendererSpecificRefresh($panel);
	}
}

// Description:
//      This procedure updates the render view's current render layer
//      label when current render layer is changed.
//
global proc updateRenderViewCurrentRenderLayerLabel(string $panel)
{
    string $oldParent = `setParent -q`;
    setParent $panel;

    string $currentRenderLayer = currentRenderLayerLabel();
    text -edit
        -label $currentRenderLayer -align "left" currentRenderLayerName;

    setParent $oldParent;

    // $currentRenderLayer is not necessarily layer node name.
    string $layerNode = `editRenderLayerGlobals -q -currentRenderLayer`;
    scriptJob -runOnce true -parent $panel -nodeNameChanged $layerNode
      ("updateRenderViewCurrentRenderLayerLabel "+$panel);
}

// Update the render view's current render target.
global proc updateRenderViewCurrentRenderTarget(string $panel)
{
  string $oldParent = `setParent -q`;
  setParent $panel;

  string $currentRenderTarget = getRenderViewRenderTarget();
  if (currentRenderLayerLabel() != "" && $currentRenderTarget != "") {
    $currentRenderTarget = ": " + $currentRenderTarget;
  }
  text -edit
      -label $currentRenderTarget -align "left" currentRenderTargetName;

  setParent $oldParent;

  // If the render target is none, must disable the render pass lock /
  // unlock button.
  int $support = rendererRenderTargetSupport(currentRenderer());
  iconTextButton -edit -manage $support
    -enable (getRenderViewRenderTarget() != "") renderPassLockUnlockButton;
}

// Description:  This procedure is called to update the render view
//      window when the current render layer changed.
//
global proc updateRenderViewForRenderLayerChange(string $panel)
{
    updateRenderViewCurrentRenderLayerLabel($panel);
	stopIprRendering($panel);
}

// Description: Switch stereo display mode
global proc setStereoMode( string $editor, string $mode )
{
	if (($mode == "parallel") || ($mode == "mirrored"))
	{
		if ($mode == "mirrored")
			renderWindowEditor -edit -stereoMode "both"
				-stereoImageOrientation "mirrored" "normal" $editor;
		else
			renderWindowEditor -edit -stereoMode "both"
				-stereoImageOrientation "normal" "mirrored" $editor;
	}
	else
		renderWindowEditor -edit -stereoMode $mode $editor;
}


// Register the procedure responsible for updating all renderer
// related UI created in this script.
//
registerUpdateRendererUIProc("updateRenderWindowPanelRendererSpecificUI");
