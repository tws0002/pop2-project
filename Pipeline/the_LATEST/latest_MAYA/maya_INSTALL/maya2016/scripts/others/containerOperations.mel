// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// This file contains helper functions for container node manipulation
//

global proc createContainerWithNodes(string $nodes[])
{
	// If all nodes belong to the same container, the new container will be created it,
	// otherwise, new container will be created on top level

	if(size($nodes) == 0) return;
	
	// Get the current common container for nodes
	string $currentContainer = `container -q -findContainer $nodes`; 
	// Create new container and move nodes to it
	string $newContainer = `container -force -addNode $nodes`; 
	// If there was a common container for all nodes, put new container in it
	if(size($currentContainer) > 0) {
		container -edit -addNode $newContainer $currentContainer;
	}
}


global proc string getNodesToRemoveFromContainer(string $mouseOverNode)
//
// If the mouse is RMB over a node that is not selected,
// then only act on it, otherwise act on all selected nodes.
// Returns the result as a single string.
//
// The length of the returned string can also be used to determine
// whether to dim the "Remove from container" menu item.	
//
{
	string $nodesToRemoveAsString;

	string $sel[] = `ls -sl -shortNames`;
	string $nodeShortName[] = `ls -shortNames $mouseOverNode`;
	string $nodesToRemove[];

	if (stringArrayContains($nodeShortName[0],$sel)) {
		$nodesToRemoveAsString = "`ls -sl`";
		$nodesToRemove = `ls -sl`;
	} else {
		$nodesToRemoveAsString = ("{\""+$mouseOverNode+"\"}");
		$nodesToRemove[0] = $mouseOverNode;
	}
	
	int $enableRemove = 0;
	for ($obj in $nodesToRemove) {
		string $existingContainer = `container -q -findContainer $obj`;
		if (size($existingContainer) > 0) {
			$enableRemove = 1;
			break;
		}
	}

	if (!$enableRemove) {
		$nodesToRemoveAsString = "";
	}
	return $nodesToRemoveAsString;
}

global proc string getNodesToAddToContainer(string $mouseOverNode)
//
// Based on the selection, determine which nodes may be added to the 
// specified container. Return as a single string representing a string
// array for the command.
//
{
	string $nodesToAdd[];

	string $sel[] = `ls -sl`;
	for ($obj in $sel) {
		if ($obj == $mouseOverNode) continue;
		string $existingContainer = `container -q -findContainer $obj`;
		if ($existingContainer != $mouseOverNode) {
			$nodesToAdd[size($nodesToAdd)] = $obj;
		}
	}

	string $result;
	int $count = size($nodesToAdd);
	if ($count > 0) {
		$result = "{ ";
		for ($ii = 0; $ii < $count; $ii++) {
			$result += ("\""+$nodesToAdd[$ii]+"\"");
			if ($ii != ($count-1)) {
				$result += ", ";
			}
		}
		$result += " }";
	}
	return $result;
}

global proc string hierarchyFlags( int $includeHier )
//
//	Description:
//		Given an include hierarchy preference, return the appropriate flag
//	combination to be used with the container command.
//
//	Inputs:
//		$includeHier	: desired include hierarchy behaviour
//
//	Return Value:
//		flag combination for container command
//
{
	string $flags;
	// include hierarchy
	//  0 = ignore (but we always include transforms for shapes)
	//  1 = shapes
	//  2 = below
    //  3 = above
	//  4 = above and below
	//
	switch ($includeHier) {
		case 0: {
			$flags = "-includeTransform ";
			break;
		}
		case 1: {
			$flags = "-includeShapes -includeTransform ";
			break;
		}
		case 2: {
			$flags = "-includeHierarchyBelow -includeTransform ";
			break;
		}
		case 3: {
			$flags = "-includeHierarchyAbove ";
			break;
		}
		case 4: {
			$flags = "-includeHierarchyAbove -includeHierarchyBelow ";
			break;		
		}
	}
	return( $flags );
}

global proc removeNodesFromContainer(string $nodes[],
									 string $baseCmd,
									 int $echo)
//
//	Description:
//		Remove the given nodes from the container. If a node to be removed is a
//	DAG node, use the containerRemoveIncludeHier optionVar to control what else
//	should also be removed, if anything. If the optionVar is not defined, we'll
//	remove the transform and the shape.
//
//	Inputs:
//		$nodes		: list of nodes to be removed
//		$baseCmd	: base command override
//		$echo		: whether or not to echo commands
//
//	Return Value:
//		None.
//
{
	if( $baseCmd == "" ){
		$baseCmd = "container -e ";
		int $includeHier = 1;	// Default
		if( `optionVar -exists containerRemoveIncludeHier` ){
			$includeHier = `optionVar -q containerRemoveIncludeHier`;
		}
		$baseCmd += hierarchyFlags( $includeHier );
	}
	$baseCmd += "-removeNode ";
	// Move each node one level up of its container
	// This is now done automatically by the -removeNode flag
	//
	string $node;
	for($node in $nodes) {
		// Get the current container for node
		string $currentContainer = `container -q -findContainer $node`;
		if(size($currentContainer) > 0) {
			// Remove node from current container

			string $cmd = ($baseCmd + $node + " " + $currentContainer);
			if( $echo ){
				evalEcho $cmd;
			} else {
				eval($cmd);
			}
		}
	}
}

global proc unpackAndRemoveContainer(string $containers[])
{
	// Moves all the nodes from container one level up and removes container node
	string $container;
	for($container in $containers) {
		// Get nodes in container
		string $nodes[] = `container -q -nodeList $container`;
		// Get container one level up of current container
		string $oneLevelUpContainer = `container -q -findContainer $container`;
		// Remove container node
		container -edit -removeContainer $container;
		// Put nodes in container one level up if there was one
		if(size($oneLevelUpContainer) > 0 && size($nodes) > 0) {
			container -edit -addNode $nodes $oneLevelUpContainer;
		}
	}
}

global proc transferNodesToContainer(string $nodes[], string $container)
{
	// Moves nodes into new container.
	// If $container is empty string, nodes just removed from their current containers
	string $node;
	for($node in $nodes) {
		// Get the current container for node
		string $currentContainer = `container -q -findContainer $node`;
		if(size($currentContainer) > 0) {
			// Remove node from current container
			container -edit -removeNode $node $currentContainer;
		}
		// Put node in container one level up if there was one
		if(size($container) > 0) {
			container -edit -addNode $node $container;
		}
	}
}
