//**************************************************************************/
// Copyright (c) 2009 Allegorithmic, SAS.
//***************************************************************************/

global int $sbs_debug = 0;

global int	$sbs_PreventSubstanceOutColorFromBeingConnectedDirectly = 1;
global int	$sbs_OverrideDefaulTextureSize							= 1;
global int	$sbs_DefaultTextureSize									= 512;

global float $sbsTextureSizeAspectRatio								= 1.0;
global float $sbsTextureSizeAspectRatioExportImages					= 1.0;
global int $sbs_PackageHasJustBeenChanged							= 0;
global int $sbs_Indent												= 170;
global int $sbs_AutomaticBakeCheck									= 0;

//Export images to disk globals
global string	$sbsExportImagesToDiskPath							= "";
global int		$sbsCreateShaderNetworkExportImages					= 0;
global int		$sbsTextureWidthExportImages						= 512;
global int		$sbsTextureHeightExportImages						= 512;
global int		$sbsKeepAspectRatioExportImages						= 1;
global string	$sbsImageFormatExportImages							= "jpg";

//Image/Icons files
global string $g_OutputConnectedUpAndDownStreamImage	= "sbs_button_green.png";
global string $g_OutputConnectedUpStreamImage			= "sbs_button_orange.png";
global string $g_OutputNotConnectedImage				= "sbs_button_grey.png";
//global string $g_GoToMarketPlace						= "sbs_marketplace.png";

global proc sbsDebugPrint(string $msg) {
	global int $sbs_debug;
	if ($sbs_debug) {
		print ($msg + "\n");
	}
}

global proc closeOurPackagesBrowseWindow() {
	if (`window -exists browseSBSGraphs`) {
		deleteUI -wnd browseSBSGraphs;
	}
}

global proc createAllChannelsAttributes(string $nodeName, string $channelsNames[]) {
	string $prefix		= "outputdyn_";
	
	int $prefixSize		= size($prefix);
	
	//Ignore changes
    setAttr ($nodeName+".ignoreChanges") 1.0;
    
	//We must remove the old dynamic channels attributes if any
	string $attrNames[] = `listAttr $nodeName`;
	string $curChannel = "";
	for ($attrName in $attrNames) {
		if (size($attrName) > $prefixSize && substring($attrName,1,$prefixSize) == $prefix) {
			//It's a dynamic attribute, so remove it
			if ( `attributeQuery -exists -node $nodeName $attrName` == true) {	
				// Remove old connected nodes
				string $connectedNodes[] = `listConnections -type "substanceOutput" ($nodeName+"."+$attrName)`;
				if (size($connectedNodes)) {
					// Check if it's used
					int $used = 0;
					$curChannel = "";
					for ($curChannel in $channelsNames) {
						$attrChannelName = $prefix + $curChannel+"_Name";
						$attrChannelColor = $prefix + $curChannel+"_Color";
						$attrChannelUV = $prefix + $curChannel+"_uvCoord";
						$attrChannelAlpha = $prefix + $curChannel+"_Alpha";
						if ($attrName==$attrChannelName || $attrName==$attrChannelColor || $attrName==$attrChannelUV || $attrName==$attrChannelAlpha) {
							$used = 1;
						}
					}
					if ($used==0) {
						// Remove it
						delete $connectedNodes[0];
					}
				}
			
				deleteAttr -at $attrName $nodeName; //It may happen when deleting the parent of an attribute that the children are automatically deleted
			}
		}
	}
	
	$curChannel = "";
	//Create all channels attributes
	for ($curChannel in $channelsNames) {
		//Create the substance channel name attribute
		$attrNameWithPrefix = $prefix + $curChannel+"_Name";
		if ( `attributeQuery -exists -node $nodeName $attrNameWithPrefix` == false) {
			addAttr -w 1 -r 1 -s 1 -k 0 -h 1 -dt "string" -ln $attrNameWithPrefix $nodeName;
			setAttr ($nodeName+"."+$attrNameWithPrefix) -type "string" $curChannel; 
		}
		
		//Create the out color attribute
		$attrNameWithPrefix = $prefix + $curChannel+"_Color";
		string $colorName = $attrNameWithPrefix;
		if ( `attributeQuery -exists -node $nodeName $attrNameWithPrefix` == false) {
			//Will containt the R,G and B
			addAttr -w 0 -r 1 -s 0 -h 1 -k 0 -at float3 -ln $attrNameWithPrefix $nodeName;
			
			//Add the subattributes
			string $subattr = $attrNameWithPrefix+"_r";
			addAttr -w 0 -r 1 -s 0 -h 1 -k 0 -at "float" -ln $subattr -parent $attrNameWithPrefix $nodeName;
			$subattr = $attrNameWithPrefix+"_g";
			addAttr -w 0 -r 1 -s 0 -h 1 -k 0 -at "float" -ln $subattr -parent $attrNameWithPrefix $nodeName;
			$subattr = $attrNameWithPrefix+"_b";
			addAttr -w 0 -r 1 -s 0 -h 1 -k 0 -at "float" -ln $subattr -parent $attrNameWithPrefix $nodeName;
		}
		
		//Create the UVCoord attributes
		string $uvCoordsAttr = $prefix + $curChannel+"_uvCoord";
		if ( `attributeQuery -exists -node $nodeName $uvCoordsAttr` == false) {
			//Will containt the U and V coordinates
			addAttr -w 0 -r 1 -s 0 -h 1 -k 0 -at float2 -ln $uvCoordsAttr $nodeName;
			
			//Add the subattributes U and V
			string $subattr = $uvCoordsAttr+"_u";
			addAttr -w 0 -r 1 -s 0 -h 1 -k 0 -at "float" -ln $subattr -parent $uvCoordsAttr $nodeName;
			$subattr = $uvCoordsAttr+"_v";
			addAttr -w 0 -r 1 -s 0 -h 1 -k 0 -at "float" -ln $subattr -parent $uvCoordsAttr $nodeName;
		}
		
		//Not attached to the parent	
		$attrNameWithPrefix = $prefix + $curChannel+"_Alpha";
		string $alphaName	= $attrNameWithPrefix;
		if ( `attributeQuery -exists -node $nodeName $attrNameWithPrefix` == false) {
			addAttr -w 0 -r 1 -s 0 -h 1 -k 0 -at "float" -ln $attrNameWithPrefix $nodeName;
		}
		
		//TODO, ignored at this time
		//sbs_AffectedByAllInputs($nodeName, $colorName, true);
		//sbs_AffectedByAllInputs($nodeName, $alphaName, false);
		
		//This tells that the UVs attribute affects the color and alpha attributes
		//string $attrAffected[] = {$colorName, $alphaName};
		//sbs_AffectTheseAttributes($nodeName, $uvCoordsAttr, $attrAffected);
	}
	
	setAttr ($nodeName+".ignoreChanges") 0.0; //reset ignore flag
}

global proc int isNormalFormatPresent(string $nodeName) {
	sbsDebugPrint("Calling isNormalFormatPresent for node : "+$nodeName);
	string $packageName = `getAttr ($nodeName+".package")`;
    string $graphName	= `getAttr ($nodeName+".graph")`;
    if (! size($packageName) || ! size($graphName)) {
		return 0;
	}
		
    string $inputs[]	= sbs_GetAllInputsFromSubstanceNode($nodeName);
	
	int $numAttr = size($inputs) / 9;
	int $i=0;
	int $imageNumber = 0;
	for ($i=0; $i<$numAttr; $i++) {
		int $index		 = 9 * $i;
		string $attrName = $inputs[$index+2];
		sbsDebugPrint("isNormalFormatPresent, attrname = "+$attrName);
		if ( ($attrName == "NormalFormat") || ($attrName == "$normalformat") || ($attrName == "normalformat") ) {
			return 1;
		}
	}
	
	return 0;
}

global proc TweaksNew(string $attributeName) {
	TweaksReplace($attributeName);
}

global proc TweaksReplace(string $attributeName) {
	string $kLayoutSubstance = getPluginResource("SubstancePlugin", "kAELayoutSubstance");

	if (`columnLayout -exists $kLayoutSubstance`) {
		deleteUI -layout $kLayoutSubstance;
	}
	
	setUITemplate -pst attributeEditorTemplate;
	
	columnLayout -adjustableColumn true $kLayoutSubstance;
	
	string $nodeName = `match "[^.]*" $attributeName`;
	string $prefix = "dyn_";
    string $inputs[] = sbs_GetAllInputsFromSubstanceNode($nodeName);
	string $group = "";
	int $hasGroup = 0;
	
	int $numAttr = size($inputs)/9;
	int $i=0;
	for ($i=0; $i<$numAttr; $i++) {
		int $index = 9 * $i;
		string $attrType = $inputs[$index+0];
		string $attrWidgetType = $inputs[$index+1];
		string $attrName = $inputs[$index+2];
		string $labelName = $inputs[$index+3];
		string $groupName = $inputs[$index+4];
		string $attrVal = $inputs[$index+5];
		string $attrMin = $inputs[$index+6];
		string $attrMax = $inputs[$index+7];
		string $attrClamp = $inputs[$index+8];
		
		if (size($attrName)>0 && substring($attrName,1,1)=="$") { continue;	}

		if ($groupName != $group) {
			if ($hasGroup==1) {
				setParent ..;
			}
				
			frameLayout 
				-bv false $groupName;
			$group = $groupName;
			$hasGroup = 1;
		}
		
		string $prefixWithAttr = $prefix + $attrName;
		string $prefixWithAttrX = $prefix + $attrName + "_x";
		string $prefixWithAttrY = $prefix + $attrName + "_y";
		string $prefixWithAttrZ = $prefix + $attrName + "_z";
		string $prefixWithAttrW = $prefix + $attrName + "_w";
		string $prefixWithAttrA = $prefix + $attrName + "_alpha_compound";
		if (`attributeQuery -exists -node $nodeName $prefixWithAttr`==false
			&& `attributeQuery -exists -node $nodeName $prefixWithAttrX`==false
			&& `attributeQuery -exists -node $nodeName $prefixWithAttrY`==false
			&& `attributeQuery -exists -node $nodeName $prefixWithAttrZ`==false
			&& `attributeQuery -exists -node $nodeName $prefixWithAttrW`==false
			&& `attributeQuery -exists -node $nodeName $prefixWithAttrA`==false)
		{
			continue;
		}
			
		if ($attrType == "float" || $attrType == "long") {
			if ($attrType == "long" && $attrWidgetType=="combo") {				
				string $enumContent = "";
				int $count = sbs_GetEnumCount($nodeName, $attrName);
				for ($k=0 ; $k<$count ; ++$k)
				{
					string $enumName = sbs_GetEnumName($nodeName, $attrName, $k);
					int $enumValue = sbs_GetEnumValue($nodeName, $attrName, $k);
					$enumContent = $enumContent + " -ei " + $enumValue + " \"" + $enumName + "\" ";
				}				
				eval("attrEnumOptionMenuGrp -l \""+$labelName+"\" -at "+$nodeName + "." + $prefixWithAttr + $enumContent +" -enable 1");
			}
			else {
				int $isClamped = substring( $attrClamp, size($attrClamp), size($attrClamp)) == "1";
				if ($isClamped && size($attrMin)>4 && size($attrMax)>4) {
					eval("attrFieldSliderGrp -attribute "+$nodeName + "." + $prefixWithAttr+" -label \""+$labelName+"\" -min "+substring($attrMin, 5,size($attrMin))+" -max "+substring($attrMax, 5,size($attrMax)));
				} else {
					attrFieldSliderGrp -attribute ($nodeName + "." + $prefixWithAttr) -label $labelName;
				}
			}
		} else if ( $attrType == "float2" || $attrType == "long2" ) {
			attrFieldGrp -attribute ($nodeName + "." + $prefixWithAttr) -label $labelName -numberOfFields 2;
		} else if ( $attrType == "float3" && $attrWidgetType=="color" || $attrType == "image") {
			attrColorSliderGrp -attribute ($nodeName + "." + $prefixWithAttr) -label $labelName;
		} else if ( $attrType == "float3" || $attrType == "long3" ) {
			attrFieldGrp -attribute ($nodeName + "." + $prefixWithAttr) -label $labelName -numberOfFields 3;
		} else if ( $attrType == "float4" && $attrWidgetType=="color") {
			attrColorSliderGrp -attribute ($nodeName + "." + $prefixWithAttr) -label $labelName;
			attrFieldSliderGrp -attribute ($nodeName + "." + $prefixWithAttrA) -label ($labelName+" Alpha");
		} else if ( $attrType == "float4" || $attrType == "long4" ) {
			attrFieldSliderGrp -attribute ($nodeName + "." + $prefixWithAttrX) -label ($labelName+".x");
			attrFieldSliderGrp -attribute ($nodeName + "." + $prefixWithAttrY) -label ($labelName+".y");
			attrFieldSliderGrp -attribute ($nodeName + "." + $prefixWithAttrZ) -label ($labelName+".z");
			attrFieldSliderGrp -attribute ($nodeName + "." + $prefixWithAttrW) -label ($labelName+".w");
		}
	}
	
	setParent ..;
	setUITemplate -ppt;
}

global proc CreateInput(string $nodeName, string $inputs[], int $input_index) {
	string $prefix		= "dyn_";
	int $index = 9 * $input_index;
	string $attrType = $inputs[$index+0];
	string $attrWidgetType = $inputs[$index+1];
	string $attrName = $inputs[$index+2];
	string $labelName = $inputs[$index+3];
	string $groupName = $inputs[$index+4];
	string $attrVal = $inputs[$index+5];
	string $attrMin = $inputs[$index+6];
	string $attrMax = $inputs[$index+7];
	string $attrClamp= $inputs[$index+8];
	
	if ($attrName == "$time") {
		$attrName = "inTime";
		$labelName = "inTime";
		$attrType = "time";
	}
	
	int $isClamped = substring( $attrClamp, size($attrClamp), size($attrClamp)) == "1";
			
	string $attrNameWithSpaces = $labelName;
	string $attrNameWithPrefix = $prefix + $attrName;
	
	string $cmd = "addAttr -w 1 -r 1 -s 1 -k 1 -h 1 -ln \""+$attrNameWithPrefix+"\" -nn \""+$attrNameWithSpaces+"\"";
	
	if ((($attrType == "float3" || $attrType == "float4") && $attrWidgetType=="color") || $attrType=="image") {
		$cmd += " -usedAsColor";
	}
	
	if ( size($attrVal) > 4 && ( $attrType == "float" || $attrType == "long" ) ) {
		//value has been set, so add it (remove "val=" inside)
		string $realAttrval = substring($attrVal, 5,size($attrVal));
		$cmd += " -dv "+$realAttrval;
	
		if (size($attrMin) > 4) {
			string $realAttrMin = substring($attrMin, 5,size($attrMin));
			$cmd += " -smn "+$realAttrMin;
			
			if ($isClamped) {
				//min value has been set, so add it (remove "min=" inside)
				$cmd += " -min "+$realAttrMin;
			}
		}
		
		if (size($attrMax) > 4) {
			//max value has been set, so add it (remove "max=" inside)
			string $realAttrMax = substring($attrMax, 5,size($attrMax));
			$cmd += " -smx "+$realAttrMax;
			
			if ($isClamped) {
				$cmd += " -max "+$realAttrMax;
			}
		}
	}

	if ($attrType == "string") {
		$cmd += " -dt \""+$attrType + "\" " +$nodeName; //Data type
	} else if ($attrType == "float4" && $attrWidgetType=="color") {
		$cmd += " -at \"float3\" " +$nodeName; //Attribute type
	} else if ($attrType == "float4" || $attrType == "long4") {
		$cmd += " -at \"compound\" -nc 4 " +$nodeName;
	} else if ( $attrType == "image" ) {
		$cmd += " -at \"float3\" " +$nodeName; //Attribute type
	} else {
		$cmd += " -at \""+$attrType + "\" " +$nodeName; //Attribute type
	}
	
	//sbsDebugPrint($cmd);
	eval($cmd);
		
	if ($attrName == "inTime") {
		connectAttr -f "time1.outTime" ($nodeName+".dyn_inTime");
	}
	
	//Attribute values will be used for float2, 3 and 4	
	//and long2, 3 and 4
	string $realAttrval = "";
	if (size($attrVal) > 4) {
		$realAttrval = substring($attrVal, 5,size($attrVal));
	}
		
	if ( $attrType == "float2") {
		//Add the subattributes
		string $subattr = $attrNameWithPrefix+"_x";
		addAttr -hidden true -at "float" -ln $subattr -p $attrNameWithPrefix $nodeName;
		
		$subattr = $attrNameWithPrefix+"_y";
		addAttr -hidden true -at "float" -ln $subattr -p $attrNameWithPrefix $nodeName;
	} else if ( $attrType == "float3" || $attrType == "image") {
		//Add the subattributes
		string $subattr = $attrNameWithPrefix+"_x";
		addAttr -hidden true -at "float" -ln $subattr -p $attrNameWithPrefix $nodeName;
		
		$subattr = $attrNameWithPrefix+"_y";
		addAttr -hidden true -at "float" -ln $subattr -p $attrNameWithPrefix $nodeName;
		
		$subattr = $attrNameWithPrefix+"_z";
		addAttr -hidden true -at "float" -ln $subattr -p $attrNameWithPrefix $nodeName;
	} else if ( $attrType == "float4" && $attrWidgetType=="color") {
		//Add the subattributes
		string $subattr = $attrNameWithPrefix+"_x";
		addAttr -hidden true -at "float" -ln $subattr -p $attrNameWithPrefix $nodeName;
		
		$subattr = $attrNameWithPrefix+"_y";
		addAttr -hidden true -at "float" -ln $subattr -p $attrNameWithPrefix $nodeName;
		
		$subattr = $attrNameWithPrefix+"_z";
		addAttr -hidden true -at "float" -ln $subattr -p $attrNameWithPrefix $nodeName;
			
		string $realAttrs[] = stringToStringArray($realAttrval, " ");			
		string $cmd = "addAttr -w 1 -r 1 -s 1 -k 1 -h 1 -at \"float\" -ln \""+$attrNameWithPrefix+"_alpha_compound\" -nn \""+$attrNameWithSpaces+" Alpha\" -dv "+$realAttrs[3]+" -smn 0.0 -smx 1.0";
		eval($cmd);
	} else if ( $attrType == "float4") {
		//Add the subattributes
		string $subattr = $attrNameWithPrefix+"_x";
		string $nnattr = $attrNameWithSpaces + " X";
		addAttr -hidden true -at "float" -ln $subattr -nn $nnattr -p $attrNameWithPrefix $nodeName;
		
		$subattr = $attrNameWithPrefix+"_y";
		$nnattr = $attrNameWithSpaces + " Y";
		addAttr -hidden true -at "float" -ln $subattr -nn $nnattr -p $attrNameWithPrefix $nodeName;
		
		$subattr = $attrNameWithPrefix+"_z";
		$nnattr = $attrNameWithSpaces + " Z";
		addAttr -hidden true -at "float" -ln $subattr -nn $nnattr -p $attrNameWithPrefix $nodeName;
		
		$subattr = $attrNameWithPrefix+"_w";
		$nnattr = $attrNameWithSpaces + " W";
		addAttr -hidden true -at "float" -ln $subattr -nn $nnattr -p $attrNameWithPrefix $nodeName;
	} else if ( $attrType == "long2") {
		//Add the subattributes
		string $subattr = $attrNameWithPrefix+"_x";
		addAttr -hidden true -at "long" -ln $subattr -p $attrNameWithPrefix $nodeName;
		
		$subattr = $attrNameWithPrefix+"_y";
		addAttr -hidden true -at "long" -ln $subattr -p $attrNameWithPrefix $nodeName;
	} else if ( $attrType == "long3") {
		//Add the subattributes
		string $subattr = $attrNameWithPrefix+"_x";
		addAttr -hidden true -at "long" -ln $subattr -p $attrNameWithPrefix $nodeName;
		
		$subattr = $attrNameWithPrefix+"_y";
		addAttr -hidden true -at "long" -ln $subattr -p $attrNameWithPrefix $nodeName;
		
		$subattr = $attrNameWithPrefix+"_z";
		addAttr -hidden true -at "long" -ln $subattr -p $attrNameWithPrefix $nodeName;
	} else if ( $attrType == "long4") {
		//Add the subattributes
		string $subattr = $attrNameWithPrefix+"_x";
		string $nnattr = $attrNameWithSpaces + " X";
		addAttr -hidden true -at "long" -ln $subattr -nn $nnattr -p $attrNameWithPrefix $nodeName;
		
		$subattr = $attrNameWithPrefix+"_y";
		$nnattr = $attrNameWithSpaces + " Y";
		addAttr -hidden true -at "long" -ln $subattr -nn $nnattr -p $attrNameWithPrefix $nodeName;
		
		$subattr = $attrNameWithPrefix+"_z";
		$nnattr = $attrNameWithSpaces + " Z";
		addAttr -hidden true -at "long" -ln $subattr -nn $nnattr -p $attrNameWithPrefix $nodeName;
		
		$subattr = $attrNameWithPrefix+"_w";
		$nnattr = $attrNameWithSpaces + " W";
		addAttr -hidden true -at "long" -ln $subattr -nn $nnattr -p $attrNameWithPrefix $nodeName;
	}

	if ( $attrType == "float2" || $attrType == "float3" || $attrType == "long2" || $attrType == "long3" ) {
		$cmd = "setAttr \""+$nodeName +"."+$attrNameWithPrefix+"\" -type \""+$attrType+"\" "+$realAttrval;
		eval($cmd);
	} else if( $attrType == "float4" && $attrWidgetType=="color") {
		$cmd = "setAttr \""+$nodeName +"."+$attrNameWithPrefix+"\" -type \"float3\" "+$realAttrval;
		eval($cmd);
		string $realAttrs[] = stringToStringArray($realAttrval, " ");
		$subattr = $attrNameWithPrefix+"_alpha_compound";
		$cmd = "setAttr "+$nodeName +"."+$subattr+" "+$realAttrs[3];		
	} else if( $attrType == "float4" || $attrType == "long4" ) {
		string $realAttrs[] = stringToStringArray($realAttrval, " ");
		string $subattr = $attrNameWithPrefix+"_x";
		
		$cmd = "setAttr "+$nodeName +"."+$subattr+" "+$realAttrs[0];
		eval($cmd);
		$subattr = $attrNameWithPrefix+"_y";
		$cmd = "setAttr "+$nodeName +"."+$subattr+" "+$realAttrs[1];
		eval($cmd);
		$subattr = $attrNameWithPrefix+"_z";
		$cmd = "setAttr "+$nodeName +"."+$subattr+" "+$realAttrs[2];
		eval($cmd);
		$subattr = $attrNameWithPrefix+"_w";
		$cmd = "setAttr "+$nodeName +"."+$subattr+" "+$realAttrs[3];
		eval($cmd);					
	}
}

global proc updateTweaks(string $nodeName, string $packageName, string $graphName) {
	//Ignore changes
    setAttr ($nodeName+".ignoreChanges") 1.0;
    
	string $prefix		= "dyn_";
   
	//Load all tweaks from graph
    string $inputs[]	= sbs_GetAllInputsFromSubstanceNode($nodeName);
   
	// returned inputs follow this convention :
	//$inputs[n*9+0] = type
	//$inputs[n*9+1] = widget type
	//$inputs[n*9+2] = name
	//$inputs[n*9+3] = label
	//$inputs[n*9+4] = group
	//$inputs[n*9+5] = "val=xxx" or "val=" if no default value is present
	//$inputs[n*9+6] = "min=xxx" or "min=" if no min is present
	//$inputs[n*9+7] = "max=xxx" or "max=" if no max is present
	//$inputs[n*9+8] = "clamp=0" or "clamp=1"
	
	int $numAttr = size($inputs) / 9;
	int $i=0;
	for ($i=0; $i<$numAttr; $i++) {
		int $index		 = 9 * $i;
		string $attrType = $inputs[$index+0];
		string $attrWidgetType = $inputs[$index+1];
		string $attrName = $inputs[$index+2];
		string $labelName = $inputs[$index+3];
	
		if ( $attrType == "boolean" || 
			$attrType == "float" || $attrType == "float2" || $attrType == "float3" || $attrType == "float4" ||
			$attrType == "long" || $attrType == "long2" || $attrType == "long3" || $attrType == "long4" || $attrType == "image" )
		{
			if ($attrName != "$time" && size($attrName)>0 && substring($attrName,1,1)=="$") {
				continue;
			}
			
			string $attrNameWithPrefix = $prefix + $attrName;
			
			// convert old float4
			if (`attributeQuery -exists -node $nodeName $attrNameWithPrefix`==true) {
				if ($attrType == "float4" && $attrWidgetType=="color") {
					string $alphaAttribute = $attrNameWithPrefix+"_alpha_compound";
					if (`attributeQuery -exists -node $nodeName $alphaAttribute`==false) {
						$cmd = "deleteAttr \""+$nodeName+"."+$attrNameWithPrefix+"\"";
						eval($cmd);
					}
				}
			}
			
			if (`attributeQuery -exists -node $nodeName $attrNameWithPrefix`==false) {
				// create input if it doesn't exist
				CreateInput($nodeName, $inputs, $i);
			}
			else if (`attributeQuery -node $nodeName -hidden $attrNameWithPrefix`==false) {
				// re-create input with hidden flag when it comes from an older Maya version
				string $cmd;
				
				// create temporary node
				if (`objExists substanceOldVersionConverter`==false) {
					$cmd = "createNode \"transform\" -n \"substanceOldVersionConverter\"";
					eval($cmd);
				}
				
				// create temporary input
				CreateInput("substanceOldVersionConverter", $inputs, $i);
				
				// copy input to temporary one
				$cmd = "copyAttr -inConnections -outConnections -containerParentChild -values -attribute \""+$attrNameWithPrefix+"\" \""+$nodeName+"\" substanceOldVersionConverter";
				eval($cmd);
				
				// delete deprecated input
				$cmd = "deleteAttr \""+$nodeName+"."+$attrNameWithPrefix+"\"";
				eval($cmd);
				
				// create valid input
				CreateInput($nodeName, $inputs, $i);
				
				// copy temporary input to new one
				$cmd = "copyAttr -inConnections -outConnections -containerParentChild -values -attribute \""+$attrNameWithPrefix+"\" substanceOldVersionConverter \""+$nodeName+"\"";
				eval($cmd);
			}
		}
	}

	if (`objExists substanceOldVersionConverter`==true) {
		string $cmd = "delete substanceOldVersionConverter";
		eval($cmd);
	}
	
	setAttr ($nodeName+".ignoreChanges") 0.0; //reset ignore flag	
}

global proc createTweaks(string $nodeName, string $packageName, string $graphName) {

	//Ignore changes
    setAttr ($nodeName+".ignoreChanges") 1.0;
    
	sbsDebugPrint( "calling createTweaks, nodename  = " +$nodeName+ " packagename = "+$packageName +" graphname = "+$graphName);
	
    string $prefix		= "dyn_";
   
	//We must remove the old dynamic attributes if any
	string $attrNames[] = `listAttr $nodeName`;
	for ($attrName in $attrNames) {
		if (size($attrName) > 4 && substring($attrName,1,4) == $prefix) {
			//It's a dynamic attribute, so remove it
			if ( `attributeQuery -exists -node $nodeName $attrName` == true)
				deleteAttr -at $attrName $nodeName; //It may happen when deleting the parent of an attribute that the children are automatically deleted
		}
	}
	setAttr ($nodeName+".ignoreChanges") 0.0; //reset ignore flag
	
	updateTweaks($nodeName, $packageName, $graphName);
}

global proc string getFilenameWithoutExtensionFromFullPathFilename(string $FPFilename) {
	string $filepart			= match( "[^/\\]*$", $FPFilename);//remove path
	int $pointCharPlace			= size($filepart) - 4;
	string $filenameOnly = substring ($filepart, 1, $pointCharPlace); //remove extension
	return $filenameOnly;
}

global proc updateUIWithCurrentSubstanceFile(string $nodeName) {
	global string $g_OutputConnectedUpAndDownStreamImage;
	global string $g_OutputConnectedUpStreamImage;
	global string $g_OutputNotConnectedImage;

	string $package = `getAttr ($nodeName+".package")`;
    string $graph	= `getAttr ($nodeName+".graph")`;
    
    sbsDebugPrint("updateUIWithCurrentSubstanceFile, package =" +$package+" graph = "+$graph+"\n");
    
	//Update UI
	string $channelsNames[]	= sbs_GetChannelsNamesFromSubstanceNode($nodeName);
	
	int $relocalized = `getAttr ($nodeName+".relocalized")`;
	if (!$relocalized) {
		//Create all out attributes from all channels names, one for each channel to tell if it is available or not
		createAllChannelsAttributes($nodeName, $channelsNames);		
		reconnectShadingNetwork($nodeName, $channelsNames);
	}
		
	int $numChannels			= size($channelsNames);
	int $i;
	treeView -e -ra treeControlChannel;
	for ($i=0; $i<$numChannels; $i++) {
		string $channelName = $channelsNames[$i];
		//string $localizedChannelName = getPluginResource("SubstancePlugin", ("kAE" + $channelName));
		treeView -e -addItem $channelName "" treeControlChannel;
		int $state = getSubstanceOutputNodeState($nodeName, $channelName);
		switch ($state) {
			case 1:
				treeView -e -image ($channelName) 1 $g_OutputConnectedUpStreamImage treeControlChannel;
				break;
			case 2:
				treeView -e -image ($channelName) 1 $g_OutputConnectedUpAndDownStreamImage treeControlChannel;
				break;
			case 0:
			default:
				treeView -e -image ($channelName) 1 $g_OutputNotConnectedImage treeControlChannel;
			break;
		}
	} 
		
	//Update button caption
	//string $packageName = getFilenameWithoutExtensionFromFullPathFilename($package);
	textField -e -text $package textFieldSubstanceFile;
	
	int $relocalized = `getAttr ($nodeName+".relocalized")`;
	if (!$relocalized) {
		//Create the dynamic parameters
		createTweaks($nodeName, $package, $graph);

		//Replace outColor connection, if any with Diffuse output connection
		sbs_SubstanceTextureOutColorConnected(($nodeName+".outColor"));
	    
		if (`attrEnumOptionMenuGrp -exists attrEnumOptionGroupNormalFormat`) {
			int $enabled		= isNormalFormatPresent($nodeName);
			attrEnumOptionMenuGrp -e -enable $enabled attrEnumOptionGroupNormalFormat;
		}
	}
	
	if ($relocalized) {
		setAttr ($nodeName+".relocalized") 0;
	}
}

global proc loadGraph(string $nodeName) {
	//Get selected graph
	string $graph[] = `textScrollList -q -si textScrollListGraphs`;  
    if ($graph[0] == "") {
		string $kError = getPluginResource("SubstancePlugin", "kAEGraphError");
		print($kError+"\n");
		return;
	}
	
	//Set graph in attribute
	setAttr ($nodeName+".graph") -type "string" ($graph[0]);
	
	updateUIWithCurrentSubstanceFile($nodeName);
	
	closeOurPackagesBrowseWindow();
}

global proc updateImageAttr(string $attributeName, string $attrImageValue) {
	setAttr -type "string" $attributeName $attrImageValue; //Update our attribute
}

global proc getTextFromTextFieldAndSetItInAttribute(string $attributeName, string $textFieldName) {
	sbsDebugPrint("Substance, getTextFromTextFieldAndSetItInAttribute : "+$attributeName+" "+$textFieldName);
	
	string $attrImageValue = `textField -q -tx $textFieldName`;
	if (size($attrImageValue)) {
		updateImageAttr($attributeName, $attrImageValue);
	}
}

global proc BrowseImagesButtonPressed(string $attributeName, string $textFieldName) {
	sbsDebugPrint("Substance, BrowseImagesButtonPressed : "+$attributeName+" "+$textFieldName);
	
	string $result[] = `fileDialog2 -caption "Choose a bitmap file" -fm 1 -dialogStyle 2`;
	if (size($result) != 1) {
		return; //user has cancelled or selected too much files (should not happen)
	}
	
	textField -e -tx ($result[0]) $textFieldName;

	getTextFromTextFieldAndSetItInAttribute($attributeName, $textFieldName);
}

global proc SubstanceFileEntered(string $nodeName) {
	//Set package filename in attribute
	string $filename			= `textField -q -text textFieldSubstanceFile`;
	sbsRemoveAllDynamicAttributes($nodeName);
	setAttr ($nodeName+".package") -type "string" ($filename);
}

global proc sbsRemoveAllDynamicAttributes(string $nodeName) {	
	string $prefix		= "dyn_";
   
    //We must remove the old dynamic attributes if any
	string $attrNames[] = `listAttr $nodeName`;
	for ($attrName in $attrNames) {
		if (size($attrName) > 4 && substring($attrName,1,4) == $prefix) {
			//It's a dynamic attribute, so remove it
			if ( `attributeQuery -exists -node $nodeName $attrName` == true) {
				deleteAttr -at $attrName $nodeName; //It may happen when deleting the parent of an attribute that the children are automatically deleted
			}
		}
	}
}

global proc Relocalize(string $nodeName, string $newpath) {
	setAttr ($nodeName+".relocalized") 1;
	setAttr ($nodeName+".package") -type "string" ($newpath);
	updateGraphItems($nodeName);
	GraphReplace($nodeName+".package");
}

global proc BrowsePackagesButtonPressed(string $nodeName) {
	global int $sbs_PackageHasJustBeenChanged;
	
	string $kSubstanceArchives = getPluginResource("SubstancePlugin", "kAESubstanceArchives");
	string $kSubstanceFiles = getPluginResource("SubstancePlugin", "kAESubstanceFiles");
	string $kChooseSubstance = getPluginResource("SubstancePlugin", "kAEChooseSubstance");
	
	// Single filter with a description.
	string $multipleFilters = $kSubstanceArchives + "(*.sbsar);;" + $kSubstanceFiles +"(*.xml);;";

	string $defaultDir = `workspace -q -fullName` + "/sourceimages/";
	
	string $result[] = `fileDialog2 -caption $kChooseSubstance -fm 1 -fileFilter $multipleFilters -selectFileFilter ($kSubstanceArchives+"(*.sbsar)") -dialogStyle 2 -startingDirectory $defaultDir`;
	if (!size($result)) {
		return; //user has cancelled
	}
	
	string $packageFilename = `getAttr ($nodeName+".package")`;
	
	$sbs_PackageHasJustBeenChanged = 1; //update our global variable
	
	if (sbs_IsSubstanceRelocalized($result[0], $packageFilename)) {
		Relocalize($nodeName, $result[0]);
	} else {
		sbsRemoveAllDynamicAttributes($nodeName);
		
		//Set package filename in attribute (it's a fullpath name)
		string $filename			= $result[0];
		setAttr ($nodeName+".package") -type "string" ($filename); //Set the filename, it may be a relative or absolute (including path) filename
		
		updateGraphItems($nodeName);
	}
}

global proc BrowseGraphs(string $nodeName, string $graphNames[]) {
	closeOurPackagesBrowseWindow();
	
	string $kBrowseGraphs = getPluginResource("SubstancePlugin", "kAEBrowseGraph");
	string $kGraphs = getPluginResource("SubstancePlugin", "kAEGraphs");
	string $kOk = getPluginResource("SubstancePlugin", "kAEOk");
	string $kCancel = getPluginResource("SubstancePlugin", "kAECancel");
	
	window -t $kBrowseGraphs
		-w 300
		-h 250
		browseSBSGraphs;

	columnLayout;
		text -label $kGraphs;
		textScrollList 
				-numberOfRows 7
				-w 195
				-allowMultiSelection false 
				-shi 1
				textScrollListGraphs;
		
		for ($graphName in $graphNames) {
			textScrollList -e -append $graphName textScrollListGraphs;
		}
		setParent ..;//Rowlayout
		
		rowLayout -nc 2;
			button -l $kOk
				-c ("loadGraph(\""+$nodeName+"\")")
				sbsOkButton;

			button -l $kCancel
				-c "closeOurPackagesBrowseWindow()"
				sbsCancelButton;
		setParent ..;//Rowlayout
	setParent ..;	//columnLayout
	showWindow;
}

//Return values are :
// 0 if it's not present
// 1 it is connected upstream to the substance node
// 2 it is connected upstream to the substance node and downstream to something else
global proc int getSubstanceOutputNodeState(string $nodeName, string $channelName) {
	string $prefix					= "outputdyn_";	
	string $postfixChannelColor		= "_Color";
	
	string $substanceAttributeName	= $prefix + $channelName + $postfixChannelColor;
	
	if ( `attributeQuery -exists -node $nodeName $substanceAttributeName` == false) {
		return 0;
	}
	
	string $connectedNodes[] = `listConnections -type "substanceOutput" ($nodeName+"."+$substanceAttributeName)`;

	if (!size($connectedNodes)) {
		return 0;
	}
		
	//Use first if several are present.
	string $outputNodeName = $connectedNodes[0];
	string $connectedNodesFromOutput[] = `listConnections ($outputNodeName+".outColor")`;
	if (!size($connectedNodesFromOutput)) {
		//Some output nodes have only their outColorR connected
		$connectedNodesFromOutput = `listConnections ($outputNodeName+".outColorR")`;
		if (!size($connectedNodesFromOutput)) {
			//Some output nodes have only their outAlpha connected
			$connectedNodesFromOutput = `listConnections ($outputNodeName+".outAlpha")`;
			if (!size($connectedNodesFromOutput)) {
				return 1;
			}
		}
	}
	
	string $connectedNodeFromOutput = "";
	for ($connectedNodeFromOutput in $connectedNodesFromOutput) {
		if (isConnectedDownstreamToSurfaceShaderOrShadingGroup($connectedNodeFromOutput)) {
			return 2;
		}
	}
	
	return 1; //Not connected to a surface/shader
}

global proc int isConnectedDownstreamToSurfaceShaderOrShadingGroup(string $node) {
	if (sbs_IsMaterialNode($node) || sbs_IsShadingGroupNode($node)) {
		return 1;
	}
	
	string $connectedNodes[] = `listConnections -source false -destination true $node`;
	
	string $connectedNode ="";
	for ($connectedNode in $connectedNodes) {
		if (isConnectedDownstreamToSurfaceShaderOrShadingGroup($connectedNode)) {
			return 1;
		}
	}
	
	return 0;
}

global proc string getSubstanceOutputNodeConnected(string $nodeName, string $channelName) {
	string $prefix					= "outputdyn_";	
	string $postfixChannelColor		= "_Color";
	
	string $substanceAttributeName	= $prefix + $channelName + $postfixChannelColor;
	
	if ( `attributeQuery -exists -node $nodeName $substanceAttributeName` == false) {
		return "";
	}
	
	string $connectedNodes[] = `listConnections -type "substanceOutput" ($nodeName+"."+$substanceAttributeName)`;
	if (size($connectedNodes)) {
		return $connectedNodes[0];
	}
		
	return "";
}

global proc createOrGetSubstanceOutputNode(string $nodeName, string $channelName) {
	//check first if it already exist
	string $outputNodeName = getSubstanceOutputNodeConnected($nodeName, $channelName);
	if ($outputNodeName == "") {
		//It doesn't exist so create it
		$outputNodeName = `createRenderNodeCB -as2DTexture "" substanceOutput ""`;
		rename $outputNodeName ($channelName+"_"+$nodeName);
		$outputNodeName = ($channelName+"_"+$nodeName); //update our variable to reflect the new name
	}
	
	sbsConnectShadingNetwork($nodeName, $outputNodeName, $channelName);
		
	//Keep our node selected
	select $nodeName;
}

global proc int sbs_IsMaterialNode(string $node) {
	if ($node=="swatchShadingGroup") {
		return 0;
	}
		
	string $classes[] = getClassification( `nodeType $node` );
	string $class = "";
	for ($class in $classes) {
		if (match("shader/surface", $class) != "") {
			return 1;
		}
	}

	return 0;
}

global proc int sbs_IsShadingGroupNode(string $node) {
	if ($node=="swatchShadingGroup") {
		return 1;
	}
		
	string $classes[] = getClassification( `nodeType $node` );
	string $class = "";
	for ($class in $classes) {
		if (match("shadingEngine", $class) != "") {
			return 1;
		}
	}

	return 0;
}

global proc string sbs_GetMaterialFromSubstanceNodeOrCreateIt(string $nodeName) {
	string $material = "";	
	string $connectedNodes[] = `listConnections ($nodeName+".outColor")`;
	int $numNodes = size($connectedNodes);

	if ($numNodes) {
		int $i;		
		for ($i=0; $i<$numNodes; $i++) {
			if ($connectedNodes[$i]!="swatchShadingGroup") {
				$material = $connectedNodes[$i];
				return $material;
			}
		}
	}
	
	//Get all channels and try to get a material connected to an output node
	string $package = `getAttr ($nodeName+".package")`;
    string $graph	= `getAttr ($nodeName+".graph")`;
    if (size($package) && size($graph)) {
		string $prefix				= "outputdyn_";
		string $postfix				= "_Color";
			
		string $channelsNames[]		= sbs_GetChannelsNamesFromSubstanceNode($nodeName);
		int $numChannels			= size($channelsNames);
		int $i;
		for ($i=0; $i<$numChannels; $i++) {
			string $channelName			= $channelsNames[$i];
			string $outputNodeConnected = getSubstanceOutputNodeConnected($nodeName, $channelName);
			
			if ($outputNodeConnected != "") {
				string $connectedNodes[] = `listConnections $outputNodeConnected`;
				if (size($connectedNodes)) {
					string $matNode = "";
					for ($matNode in $connectedNodes) {
						if (sbs_IsMaterialNode($matNode)) {
							return $matNode;
						}
					}
				} else {
					//If shader is bump or normal, go one level to get material and ignore bump2d node
					$connectedNodes = `listConnections -type "bump2d" $outputNodeConnected`;
					if (size($connectedNodes)) {
						//Use first bump2d node found
						string $connectedNodesBump2D[] = `listConnections -type "material" $connectedNodes[0]`;
						int $numNodes = size($connectedNodesBump2D);
						if ($numNodes) {
							int $i;		
							for ($i=0; $i<$numNodes; $i++) {
								if ($connectedNodesBump2D[$i]!="swatchShadingGroup") {
									return $connectedNodesBump2D[$i];
								}
							}
						}
					}
					//If shader is a 
					$connectedNodes = `listConnections -type "reverse" $outputNodeConnected`;
					
					if (size($connectedNodes)) {
						//Use first reverse node found
						string $connectedNodesReverse[] = `listConnections -type "material" $connectedNodes[0]`;
						int $numNodes = size($connectedNodesReverse);
						if ($numNodes) {
							int $i;		
							for ($i=0; $i<$numNodes; $i++) {
								if ($connectedNodesReverse[$i]!="swatchShadingGroup") {
									return $connectedNodesReverse[$i];
								}
							}
						}
					}
				}
			}
		}
	}

	//Last try with its name...	
	$material					= ($nodeName + "_Material");
	string $materialNodeName[]	= `ls $material`;
	
	//If not found, we create it
	if (!size($materialNodeName)) {
		//Doesn't exist yet so create material and shading group
		$material				= `shadingNode -asShader phongE`;
		string $shadingGroup    = `sets -renderable true -noSurfaceShader true -empty -name phongE2SG`;
		// connect material2shadingG //
		connectAttr -f ($material + ".outColor") ($shadingGroup + ".surfaceShader");
	    
		select -r $material;
		rename $material ($nodeName + "_Material");
		$material = ($nodeName + "_Material");
		hyperShade -sn $material;
	}
	
	sbsDebugPrint("sbs_GetMaterialFromSubstanceNodeOrCreateIt returned : "+ $material);
	return $material;
}

global proc string sbs_GetShadingGroupFromMaterial(string $material) {
	if (`attributeQuery -exists -node $material "outColor"` == true) {
		string $shadingGroups[] = `listConnections ($material + ".outColor")`;
		if (size($shadingGroups)) {
			return $shadingGroups[0]; //return first
		}
	}
	
	return "";
}

global proc sbs_RearrangeHypershadeGraph() {
	string $panel = `getPanel -withFocus`;
	if ($panel == "") { return; }
		
	string $type = `getPanel -typeOf $panel`;
	if ($type == "scriptedPanel") {
		string $scriptedType = `scriptedPanel -query -type $panel`;
		if ($scriptedType == "hyperShadePanel") {
			hyperShadePanelGraphCommand($panel, "rearrangeGraph");
		}
		if ($scriptedType == "nodeEditorPanel") {
			nodeEditor -e -frameAll -layout ($panel + "NodeEditorEd");
			nodeEditor -e -layout ($panel + "NodeEditorEd");
		}
    }
}

global proc ChannelTreeViewButtonClickCommand(string $nodeName, string $itemClicked, int $buttonState) {
	global string $g_OutputConnectedImage;
	global int $sbs_AutomaticBakeCheck;

	//sbsDebugPrint( "item : "+$itemClicked+" = "+$buttonState+"\n");
	string $channelName = $itemClicked;
	
	createOrGetSubstanceOutputNode($nodeName, $channelName); //This function checks if the node already exists or not
	
	//Create material and shading group
    string $material = sbs_GetMaterialFromSubstanceNodeOrCreateIt($nodeName);
    if (! size($material))
		return;
    
	string $shadingGroup = sbs_GetShadingGroupFromMaterial($material);
    
    //We are testing it but it should be present as we have built it
    string $outputNodeName = getSubstanceOutputNodeConnected($nodeName, $channelName);
	if ($outputNodeName != "") {
		if ($channelName == "Opacity" && ( `attributeQuery -exists -node $material "transparency"` == true)) {
			if ($sbs_AutomaticBakeCheck == 1) {
				string $imageBaking = "";
				string $imageBakingConnected[] = `listConnections - type "file" ($outputNodeName + ".outImage")`;
				if (size($imageBakingConnected)) {
					$imageBaking = $imageBakingConnected[0];
				} else {
					$imageBaking = `shadingNode -asTexture file`;
				}
				
				string $reverse = "";
				string $reverseConnected[] = `listConnections -type "reverse" ($outputNodeName + ".outColor")`;
				if (size($reverseConnected)) {
					$reverse = $reverseConnected[0];
				} else {
					$reverse = `shadingNode -asUtility reverse`;
				}
				
				string $attr = ($outputNodeName + ".outImage");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $imageBaking);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($imageBaking + ".fileTextureName");
					string $Place2DTextureNode[] = `listConnections ($outputNodeName+".uv")`;
					connectAttr ($Place2DTextureNode[0]+".outUV") ($imageBaking+".uv");
					connectAttr ($Place2DTextureNode[0]+".outUvFilterSize") ($imageBaking+".uvFilterSize");
				}
				
				string $attr = ($imageBaking + ".outColor");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $reverse);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($reverse + ".input");
				}
				
				string $attr = ($reverse + ".output");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
				if (! $alreadyConnected) {
					connectAttr -f $attr ($material + ".transparency");
				}
			}
			if ($sbs_AutomaticBakeCheck == 0) {
				string $reverse = "";
				string $reverseConnected[] = `listConnections -type "reverse" ($outputNodeName + ".outColor")`;
				if (size($reverseConnected)) {
					$reverse = $reverseConnected[0];
				} else {
					$reverse = `shadingNode -asUtility reverse`;
				}
			
				string $attr = ($outputNodeName + ".outColor");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $reverse);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($reverse + ".input");
				}
			
				string $attr = ($reverse + ".output");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($material + ".transparency");
				}
			}			
		} else if ($channelName == "Diffuse" && ( `attributeQuery -exists -node $material "color"` == true)) {
			if ($sbs_AutomaticBakeCheck == 1) {
				string $imageBaking = "";
				string $imageBakingConnected[] = `listConnections - type "file" ($outputNodeName + ".outImage")`;
				if (size($imageBakingConnected)) {
					$imageBaking = $imageBakingConnected[0];
				} else {
					$imageBaking = `shadingNode -asTexture file`;
				}
			
				string $attr = ($outputNodeName + ".outImage");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $imageBaking);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($imageBaking + ".fileTextureName");
					string $Place2DTextureNode[] = `listConnections ($outputNodeName+".uv")`;
					connectAttr ($Place2DTextureNode[0]+".outUV") ($imageBaking+".uv");
					connectAttr ($Place2DTextureNode[0]+".outUvFilterSize") ($imageBaking+".uvFilterSize");
				}
			
				string $attr = ($imageBaking + ".outColor");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($material + ".color");
				}
			}
			if ($sbs_AutomaticBakeCheck == 0) {
				string $attr = ($outputNodeName + ".outColor");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($material + ".color");
				}
			}			
		} else if ($channelName == "Emissive" && ( `attributeQuery -exists -node $material "incandescence"` == true)) {
			if ($sbs_AutomaticBakeCheck == 1) {
				string $imageBaking = "";
				string $imageBakingConnected[] = `listConnections - type "file" ($outputNodeName + ".outImage")`;
				if (size($imageBakingConnected)) {
					$imageBaking = $imageBakingConnected[0];
				} else {
					$imageBaking = `shadingNode -asTexture file`;
				}
			
				string $attr = ($outputNodeName + ".outImage");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $imageBaking);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($imageBaking + ".fileTextureName");
					string $Place2DTextureNode[] = `listConnections ($outputNodeName+".uv")`;
					connectAttr ($Place2DTextureNode[0]+".outUV") ($imageBaking+".uv");
					connectAttr ($Place2DTextureNode[0]+".outUvFilterSize") ($imageBaking+".uvFilterSize");
				}
			
				string $attr = ($imageBaking + ".outColor");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($material + ".incandescence");
				}
			}
			if ($sbs_AutomaticBakeCheck == 0) {
				string $attr = ($outputNodeName + ".outColor");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($material + ".incandescence");
				}
			}			
		} else if ($channelName == "Glossiness" && ( `attributeQuery -exists -node $material "roughness"` == true)) {
			if ($sbs_AutomaticBakeCheck == 1) {
				string $imageBaking = "";
				string $imageBakingConnected[] = `listConnections - type "file" ($outputNodeName + ".outImage")`;
				if (size($imageBakingConnected)) {
					$imageBaking = $imageBakingConnected[0];
				} else {
					$imageBaking = `shadingNode -asTexture file`;
				}
			
				string $attr = ($outputNodeName + ".outImage");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $imageBaking);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($imageBaking + ".fileTextureName");
					string $Place2DTextureNode[] = `listConnections ($outputNodeName+".uv")`;
					connectAttr ($Place2DTextureNode[0]+".outUV") ($imageBaking+".uv");
					connectAttr ($Place2DTextureNode[0]+".outUvFilterSize") ($imageBaking+".uvFilterSize");
				}
			
				string $attr = ($imageBaking + ".outColorR");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($material + ".roughness");
				}
			}
			if ($sbs_AutomaticBakeCheck == 0) {
				string $attr = ($outputNodeName + ".outColorR");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($material + ".roughness");
				}
			}			
        } else if ($channelName == "Gloss" && ( `attributeQuery -exists -node $material "roughness"` == true)) {
			if ($sbs_AutomaticBakeCheck == 1) {
				string $imageBaking = "";
				string $imageBakingConnected[] = `listConnections - type "file" ($outputNodeName + ".outImage")`;
				if (size($imageBakingConnected)) {
					$imageBaking = $imageBakingConnected[0];
				} else {
					$imageBaking = `shadingNode -asTexture file`;
				}
			
				string $attr = ($outputNodeName + ".outImage");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $imageBaking);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($imageBaking + ".fileTextureName");
					string $Place2DTextureNode[] = `listConnections ($outputNodeName+".uv")`;
					connectAttr ($Place2DTextureNode[0]+".outUV") ($imageBaking+".uv");
					connectAttr ($Place2DTextureNode[0]+".outUvFilterSize") ($imageBaking+".uvFilterSize");
				}
			
				string $attr = ($imageBaking + ".outColorR");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($material + ".roughness");
				}
			}
			if ($sbs_AutomaticBakeCheck == 0) {
				string $attr = ($outputNodeName + ".outColorR");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($material + ".roughness");
				}
			}
        } else if ($channelName == "Specular" && ( `attributeQuery -exists -node $material "specularColor"` == true)) {
			if ($sbs_AutomaticBakeCheck == 1) {
				string $imageBaking = "";
				string $imageBakingConnected[] = `listConnections - type "file" ($outputNodeName + ".outImage")`;
				if (size($imageBakingConnected)) {
					$imageBaking = $imageBakingConnected[0];
				} else {
					$imageBaking = `shadingNode -asTexture file`;
				}
			
				string $attr = ($outputNodeName + ".outImage");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $imageBaking);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($imageBaking + ".fileTextureName");
					string $Place2DTextureNode[] = `listConnections ($outputNodeName+".uv")`;
					connectAttr ($Place2DTextureNode[0]+".outUV") ($imageBaking+".uv");
					connectAttr ($Place2DTextureNode[0]+".outUvFilterSize") ($imageBaking+".uvFilterSize");
				}
			
				string $attr = ($imageBaking + ".outColor");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($material + ".specularColor");
				}
			}
			if ($sbs_AutomaticBakeCheck == 0) {
				string $attr = ($outputNodeName + ".outColor");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($material + ".specularColor");
				}
			}			
		} else if ($channelName == "Normal" && ( `attributeQuery -exists -node $material "normalCamera"` == true)) {
			if ($sbs_AutomaticBakeCheck == 1) {
				string $imageBaking = "";
				string $imageBakingConnected[] = `listConnections - type "file" ($outputNodeName + ".outImage")`;
				if (size($imageBakingConnected)) {
					$imageBaking = $imageBakingConnected[0];
				} else {
					$imageBaking = `shadingNode -asTexture file`;
				}
			
				string $attr = ($outputNodeName + ".outImage");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $imageBaking);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($imageBaking + ".fileTextureName");
					string $Place2DTextureNode[] = `listConnections ($outputNodeName+".uv")`;
					connectAttr ($Place2DTextureNode[0]+".outUV") ($imageBaking+".uv");
					connectAttr ($Place2DTextureNode[0]+".outUvFilterSize") ($imageBaking+".uvFilterSize");
				}
					
				//**	
				string $connectedNodes[] = `listConnections ($material + ".normalCamera")`;
				if (!size($connectedNodes)) {
					string $bump2d = "";
					string $bumpConnected[] = `listConnections -type "bump2d" ($outputNodeName + ".outAlpha")`;
					if (size($bumpConnected)) {
						$bump2d = $bumpConnected[0];
					} else {
						$bump2d = `shadingNode -asUtility bump2d`;
					}
					
					string $attr = ($imageBaking + ".outAlpha");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $bump2d);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($bump2d + ".bumpValue");
					}
					
					$attr = ($bump2d + ".outNormal");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($material + ".normalCamera");
					}
						
					select -r $bump2d;
					setAttr ($bump2d + ".bumpInterp") 1;
					rename $bump2d ($nodeName + "_bump2d");
				} else {
					string $bumpsConnected[] = `listConnections -type "bump2d" ($outputNodeName + ".outAlpha")`;
					
					int $found = 0;
					string $connectedNode = "";
					for ($connectedNode in $connectedNodes) {
						string $bump2dNode = "";
						for ($bump2dNode in $bumpsConnected) {
							if ($connectedNode == $bump2dNode) { //Is this bump2dnode conencted to the material ?
								//They are already connected, so don't warn user.
								$found = 1;
								break;
							}
						}
					}
					
					if (!$found) {
						string $bump2d = `shadingNode -asUtility bump2d`;
						string $attr = ($imageBaking + ".outAlpha");
						connectAttr -f $attr ($bump2d + ".bumpValue");
						select -r $bump2d;
						rename $bump2d ($nodeName + "_bump2d");
						
						//Something is already connected in the ($material + ".normalCamera") attribute
						string $ok = getPluginResource("SubstancePlugin", "kAEOk");
						confirmDialog -message ("Substance Normal Output node is created, but connection to attribute : \""+$material+".normalCamera\" could not be made  previous connections exist") -button $ok -defaultButton $ok;
					}
				}
			}
			if ($sbs_AutomaticBakeCheck == 0) {
				string $connectedNodes[] = `listConnections ($material + ".normalCamera")`;
				if (!size($connectedNodes)) {
					string $bump2d = "";
					string $bumpConnected[] = `listConnections -type "bump2d" ($outputNodeName + ".outAlpha")`;
					if (size($bumpConnected)) {
						$bump2d = $bumpConnected[0];
					} else {
						$bump2d = `shadingNode -asUtility bump2d`;
					}
					
					string $attr = ($outputNodeName + ".outAlpha");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $bump2d);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($bump2d + ".bumpValue");
					}
					
					$attr = ($bump2d + ".outNormal");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($material + ".normalCamera");
					}
						
					select -r $bump2d;
					setAttr ($bump2d + ".bumpInterp") 1;
					rename $bump2d ($nodeName + "_bump2d");
				} else {
					string $bumpsConnected[] = `listConnections -type "bump2d" ($outputNodeName + ".outAlpha")`;
					
					int $found = 0;
					string $connectedNode = "";
					for ($connectedNode in $connectedNodes) {
						string $bump2dNode = "";
						for ($bump2dNode in $bumpsConnected) {
							if ($connectedNode == $bump2dNode) { //Is this bump2dnode conencted to the material ?
								//They are already connected, so don't warn user.
								$found = 1;
								break;
							}
						}
					}
					
					if (!$found) {
						string $bump2d = `shadingNode -asUtility bump2d`;
						string $attr = ($outputNodeName + ".outAlpha");
						connectAttr -f $attr ($bump2d + ".bumpValue");
						select -r $bump2d;
						rename $bump2d ($nodeName + "_bump2d");
						
						//Something is already connected in the ($material + ".normalCamera") attribute
						string $ok = getPluginResource("SubstancePlugin", "kAEOk");
					confirmDialog -message ("Substance Normal Output node is created, but connection to attribute : \""+$material+".normalCamera\" could not be made  previous connections exist") -button $ok -defaultButton $ok;
					}
				}
			}
		} else if ($channelName == "Bump" && ( `attributeQuery -exists -node $material "normalCamera"` == true)) {
			if ($sbs_AutomaticBakeCheck == 1) {
				string $imageBaking = "";
				string $imageBakingConnected[] = `listConnections - type "file" ($outputNodeName + ".outImage")`;
				if (size($imageBakingConnected)) {
					$imageBaking = $imageBakingConnected[0];
				} else {
					$imageBaking = `shadingNode -asTexture file`;
				}
			
				string $attr = ($outputNodeName + ".outImage");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $imageBaking);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($imageBaking + ".fileTextureName");
					string $Place2DTextureNode[] = `listConnections ($outputNodeName+".uv")`;
					connectAttr ($Place2DTextureNode[0]+".outUV") ($imageBaking+".uv");
					connectAttr ($Place2DTextureNode[0]+".outUvFilterSize") ($imageBaking+".uvFilterSize");
				}
					
				//**	
				string $connectedNodes[] = `listConnections ($material + ".normalCamera")`;
				if (!size($connectedNodes)) {
					string $bump2d = "";
					string $bumpConnected[] = `listConnections -type "bump2d" ($outputNodeName + ".outAlpha")`;
					if (size($bumpConnected)) {
						$bump2d = $bumpConnected[0];
					} else {
						$bump2d = `shadingNode -asUtility bump2d`;
					}
					
					string $attr = ($imageBaking + ".outAlpha");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $bump2d);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($bump2d + ".bumpValue");
					}
					
					$attr = ($bump2d + ".outNormal");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($material + ".normalCamera");
					}
						
					select -r $bump2d;
					//setAttr ($bump2d + ".bumpInterp") 1;
					rename $bump2d ($nodeName + "_bump2d");
				} else {
					string $bumpsConnected[] = `listConnections -type "bump2d" ($outputNodeName + ".outAlpha")`;
					
					int $found = 0;
					string $connectedNode = "";
					for ($connectedNode in $connectedNodes) {
						string $bump2dNode = "";
						for ($bump2dNode in $bumpsConnected) {
							if ($connectedNode == $bump2dNode) { //Is this bump2dnode conencted to the material ?
								//They are already connected, so don't warn user.
								$found = 1;
								break;
							}
						}
					}
					
					if (!$found) {
						string $bump2d = `shadingNode -asUtility bump2d`;
						string $attr = ($imageBaking + ".outAlpha");
						connectAttr -f $attr ($bump2d + ".bumpValue");
						select -r $bump2d;
						rename $bump2d ($nodeName + "_bump2d");
						
						//Something is already connected in the ($material + ".normalCamera") attribute
						string $ok = getPluginResource("SubstancePlugin", "kAEOk");
						confirmDialog -message ("Substance Normal Output node is created, but connection to attribute : \""+$material+".normalCamera\" could not be made  previous connections exist") -button $ok -defaultButton $ok;
					}
				}
				
			}
			if ($sbs_AutomaticBakeCheck == 0) {
				string $connectedNodes[] = `listConnections ($material + ".normalCamera")`;
				if (!size($connectedNodes)) {
					string $bump2d = "";
					string $bumpConnected[] = `listConnections -type "bump2d" ($outputNodeName + ".outAlpha")`;
					if (size($bumpConnected)) {
						$bump2d = $bumpConnected[0];
					} else {
						$bump2d = `shadingNode -asUtility bump2d`;
					}
					
					string $attr = ($outputNodeName + ".outAlpha");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $bump2d);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($bump2d + ".bumpValue");
					}
					
					$attr = ($bump2d + ".outNormal");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $material);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($material + ".normalCamera");
					}
						
					select -r $bump2d;
					//setAttr ($bump2d + ".bumpInterp") 1;
					rename $bump2d ($nodeName + "_bump2d");
				} else {
					string $bumpsConnected[] = `listConnections -type "bump2d" ($outputNodeName + ".outAlpha")`;
					
					int $found = 0;
					string $connectedNode = "";
					for ($connectedNode in $connectedNodes) {
						string $bump2dNode = "";
						for ($bump2dNode in $bumpsConnected) {
							if ($connectedNode == $bump2dNode) { //Is this bump2dnode conencted to the material ?
								//They are already connected, so don't warn user.
								$found = 1;
								break;
							}
						}
					}
					
					if (!$found) {
						string $bump2d = `shadingNode -asUtility bump2d`;
						string $attr = ($outputNodeName + ".outAlpha");
						connectAttr -f $attr ($bump2d + ".bumpValue");
						select -r $bump2d;
						rename $bump2d ($nodeName + "_bump2d");
						
						//Something is already connected in the ($material + ".normalCamera") attribute
						string $ok = getPluginResource("SubstancePlugin", "kAEOk");
						confirmDialog -message ("Substance Normal Output node is created, but connection to attribute : \""+$material+".normalCamera\" could not be made  previous connections exist") -button $ok -defaultButton $ok;
					}
				}
			}
		} else if (($channelName == "Height") && $shadingGroup != "") {
			if ($sbs_AutomaticBakeCheck == 1) {
				string $imageBaking = "";
				string $imageBakingConnected[] = `listConnections - type "file" ($outputNodeName + ".outImage")`;
				if (size($imageBakingConnected)) {
					$imageBaking = $imageBakingConnected[0];
				} else {
					$imageBaking = `shadingNode -asTexture file`;
				}
			
				string $attr = ($outputNodeName + ".outImage");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $imageBaking);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($imageBaking + ".fileTextureName");
					string $Place2DTextureNode[] = `listConnections ($outputNodeName+".uv")`;
					connectAttr ($Place2DTextureNode[0]+".outUV") ($imageBaking+".uv");
					connectAttr ($Place2DTextureNode[0]+".outUvFilterSize") ($imageBaking+".uvFilterSize");
				}
					
				string $connectedDispShaders[] = `listConnections ($shadingGroup + ".displacementShader")`;
				if (!size($connectedDispShaders)) {
					string $dispShader = "";
					string $dispShaderConnected[] = `listConnections -type "displacementShader" ($outputNodeName + ".outColorR")`;
					if (size($dispShaderConnected)) {
						$dispShader = $dispShaderConnected[0];
					} else {
						$dispShader = `shadingNode -asShader displacementShader`;
					}
				
					select -r $dispShader;
					$dispShader = `rename $dispShader ($nodeName + "_heightMap")`;
					
					string $attr = ($imageBaking + ".outColorR");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $dispShader);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($dispShader + ".displacement");
					}
					
					string $attr = ($dispShader + ".displacement");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $shadingGroup);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($shadingGroup + ".displacementShader");
					}
			   } else {
				   //Something is already connected to the shading group .displacement shader
				   string $dispShaderConnected[] = `listConnections -type "displacementShader" ($outputNodeName + ".outColorR")`;
					
					//Is this displacement shader already connected ?
					int $found = 0;
					string $connectedDispShader = "";
					for ($connectedDispShader in $connectedDispShaders) {
						string $dispshader = "";
						for ($dispshader in $dispShaderConnected) {
							if ($connectedDispShader == $dispshader) {
								//They are already connected, so don't warn user.
								$found = 1;
								break;
							}
						}
					}
					if (!$found) {
						string $dispShader = `shadingNode -asShader displacementShader`;
						select -r $dispShader;
						$dispShader = `rename $dispShader ($nodeName + "_heightMap")`;
						
						string $attr = ($imageBaking + ".outColorR");
						connectAttr -f $attr ($dispShader + ".displacement");
						
						//Something is already connected in the ($shadingGroup + ".displacementShader") attribute
						string $ok = getPluginResource("SubstancePlugin", "kAEOk");
						confirmDialog -message ("Substance Height Output node is created, but connection to attribute : \""+$shadingGroup + ".displacementShader\" could not be made  previous connections exist") -button $ok -defaultButton $ok;
					}
			   }
		   }
			if ($sbs_AutomaticBakeCheck == 0) {
				string $connectedDispShaders[] = `listConnections ($shadingGroup + ".displacementShader")`;
				if (!size($connectedDispShaders)) {
					string $dispShader = "";
					string $dispShaderConnected[] = `listConnections -type "displacementShader" ($outputNodeName + ".outColorR")`;
					if (size($dispShaderConnected)) {
						$dispShader = $dispShaderConnected[0];
					} else {
						$dispShader = `shadingNode -asShader displacementShader`;
					}
				
					select -r $dispShader;
					$dispShader = `rename $dispShader ($nodeName + "_heightMap")`;
					
					string $attr = ($outputNodeName + ".outColorR");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $dispShader);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($dispShader + ".displacement");
					}
					
					string $attr = ($dispShader + ".displacement");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $shadingGroup);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($shadingGroup + ".displacementShader");
					}
			   } else {
				   //Something is already connected to the shading group .displacement shader
				   string $dispShaderConnected[] = `listConnections -type "displacementShader" ($outputNodeName + ".outColorR")`;
					
					//Is this displacement shader already connected ?
					int $found = 0;
					string $connectedDispShader = "";
					for ($connectedDispShader in $connectedDispShaders) {
						string $dispshader = "";
						for ($dispshader in $dispShaderConnected) {
							if ($connectedDispShader == $dispshader) {
								//They are already connected, so don't warn user.
								$found = 1;
								break;
							}
						}
					}
					if (!$found) {
						string $dispShader = `shadingNode -asShader displacementShader`;
						select -r $dispShader;
						$dispShader = `rename $dispShader ($nodeName + "_heightMap")`;
						
						string $attr = ($outputNodeName + ".outColorR");
						connectAttr -f $attr ($dispShader + ".displacement");
						
						//Something is already connected in the ($shadingGroup + ".displacementShader") attribute
						string $ok = getPluginResource("SubstancePlugin", "kAEOk");
						confirmDialog -message ("Substance Height Output node is created, but connection to attribute : \""+$shadingGroup + ".displacementShader\" could not be made  previous connections exist") -button $ok -defaultButton $ok;
					}
			   }
		   }
        } else if (($channelName == "Displacement") && $shadingGroup != "") {
			if ($sbs_AutomaticBakeCheck == 1) {
				string $imageBaking = "";
				string $imageBakingConnected[] = `listConnections - type "file" ($outputNodeName + ".outImage")`;
				if (size($imageBakingConnected)) {
					$imageBaking = $imageBakingConnected[0];
				} else {
					$imageBaking = `shadingNode -asTexture file`;
				}
			
				string $attr = ($outputNodeName + ".outImage");
				int $alreadyConnected = sbsAreAlreadyConnected($attr, $imageBaking);
				if (!$alreadyConnected) {
					connectAttr -f $attr ($imageBaking + ".fileTextureName");
					string $Place2DTextureNode[] = `listConnections ($outputNodeName+".uv")`;
					connectAttr ($Place2DTextureNode[0]+".outUV") ($imageBaking+".uv");
					connectAttr ($Place2DTextureNode[0]+".outUvFilterSize") ($imageBaking+".uvFilterSize");
				}
			
				string $connectedDispShaders[] = `listConnections ($shadingGroup + ".displacementShader")`;
				if (!size($connectedDispShaders)) {
					string $dispShader = "";
					string $dispShaderConnected[] = `listConnections -type "displacementShader" ($outputNodeName + ".outColorR")`;
					if (size($dispShaderConnected)) {
						$dispShader = $dispShaderConnected[0];
					} else {
						$dispShader = `shadingNode -asShader displacementShader`;
					}
				
					select -r $dispShader;
					$dispShader = `rename $dispShader ($nodeName + "_DisplacementMap")`;
					
					string $attr = ($imageBaking + ".outColorR");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $dispShader);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($dispShader + ".displacement");
					}
					
					string $attr = ($dispShader + ".displacement");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $shadingGroup);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($shadingGroup + ".displacementShader");
					}
			   } else {
				   //Something is already connected to the shading group .displacement shader
				   string $dispShaderConnected[] = `listConnections -type "displacementShader" ($outputNodeName + ".outColorR")`;
					
					//Is this displacement shader already connected ?
					int $found = 0;
					string $connectedDispShader = "";
					for ($connectedDispShader in $connectedDispShaders) {
						string $dispshader = "";
						for ($dispshader in $dispShaderConnected) {
							if ($connectedDispShader == $dispshader) {
								//They are already connected, so don't warn user.
								$found = 1;
								break;
							}
						}
					}
					if (!$found) {
						string $dispShader = `shadingNode -asShader displacementShader`;
						select -r $dispShader;
						$dispShader = `rename $dispShader ($nodeName + "_DisplacementMap")`;
						
						string $attr = ($imageBaking + ".outColorR");
						connectAttr -f $attr ($dispShader + ".displacement");
						
						//Something is already connected in the ($shadingGroup + ".displacementShader") attribute
						string $ok = getPluginResource("SubstancePlugin", "kAEOk");
						confirmDialog -message ("Substance Displacement Output node is created, but connection to attribute : \""+$shadingGroup + ".displacementShader\" could not be made  previous connections exist") -button $ok -defaultButton $ok;
					}
			   }
		   }
			if ($sbs_AutomaticBakeCheck == 0) {
				string $connectedDispShaders[] = `listConnections ($shadingGroup + ".displacementShader")`;
				if (!size($connectedDispShaders)) {
					string $dispShader = "";
					string $dispShaderConnected[] = `listConnections -type "displacementShader" ($outputNodeName + ".outColorR")`;
					if (size($dispShaderConnected)) {
						$dispShader = $dispShaderConnected[0];
					} else {
						$dispShader = `shadingNode -asShader displacementShader`;
					}
				
					select -r $dispShader;
					$dispShader = `rename $dispShader ($nodeName + "_DisplacementMap")`;
					
					string $attr = ($outputNodeName + ".outColorR");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $dispShader);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($dispShader + ".displacement");
					}
					
					string $attr = ($dispShader + ".displacement");
					int $alreadyConnected = sbsAreAlreadyConnected($attr, $shadingGroup);
					if (!$alreadyConnected) {
						connectAttr -f $attr ($shadingGroup + ".displacementShader");
					}
			   } else {
				   //Something is already connected to the shading group .displacement shader
				   string $dispShaderConnected[] = `listConnections -type "displacementShader" ($outputNodeName + ".outColorR")`;
					
					//Is this displacement shader already connected ?
					int $found = 0;
					string $connectedDispShader = "";
					for ($connectedDispShader in $connectedDispShaders) {
						string $dispshader = "";
						for ($dispshader in $dispShaderConnected) {
							if ($connectedDispShader == $dispshader) {
								//They are already connected, so don't warn user.
								$found = 1;
								break;
							}
						}
					}
					if (!$found) {
						string $dispShader = `shadingNode -asShader displacementShader`;
						select -r $dispShader;
						$dispShader = `rename $dispShader ($nodeName + "_DisplacementMap")`;
						
						string $attr = ($outputNodeName + ".outColorR");
						connectAttr -f $attr ($dispShader + ".displacement");
						
						//Something is already connected in the ($shadingGroup + ".displacementShader") attribute
						string $ok = getPluginResource("SubstancePlugin", "kAEOk");
						confirmDialog -message ("Substance Displacement Output node is created, but connection to attribute : \""+$shadingGroup + ".displacementShader\" could not be made  previous connections exist") -button $ok -defaultButton $ok;
					}
			   }
		   }
        }
	}
	
	select -r $nodeName;
	
	sbs_RearrangeHypershadeGraph();

	treeView -e  -image $itemClicked 1 $g_OutputConnectedImage treeControlChannel;
}

//Called on user rename of items in tree view, no matter which layer it is in.
//Return the new identifier for the item in the tree view, or an empty string
//in the item should not be renamed
global proc string precompExportEditorItemOnRename(string $oldName, string $newName) {
    return "";
}

global proc sbs_SubstanceTextureOutColorConnected(string $attrFullName) {
	string $nodeName = `match "[^.]*" $attrFullName`;
	
	string $packageFilename = `getAttr ($nodeName+".package")`;
	if (!size($packageFilename)) { return; }
	
	//Get all attribute at which the outColor of the substance tex is connected
	//and replace this connection by the diffuse output outColor attribute
	
	string $destinations[] = `connectionInfo -destinationFromSource $attrFullName`;
	string $outputNodeName = "";
	if (size($destinations)) {
		//Create or Get substanceoutput Diffuse node
		string $channelName = "Diffuse";
		createOrGetSubstanceOutputNode($nodeName, $channelName); //This function checks if the node already exists or not

		//We are testing it as it may not exist when using for example some nodes that have only one output which is not diffuse (noises)
		string $outputNodeName = getSubstanceOutputNodeConnected($nodeName, $channelName);
		if ($outputNodeName == "") { return; }
		
		string $dest = "";
		for ($dest in $destinations) {
			string $destNode = `match "[^.]*" $dest`;
			if ($destNode != "swatchShadingGroup") {
				//disconnect old attribute
				disconnectAttr $attrFullName $dest;
				
				//Connect the diffuse output to the .color attribute, if any
				if (`attributeQuery -exists -node $destNode "color"` == true) {
					connectAttr -f ($outputNodeName+".outColor") ($destNode+".color");
					select $destNode;
				}
			}
		}
	}
}

global proc NormalFormatNew(string $attributeName) {
	setUITemplate -pst attributeEditorTemplate;
	
	string $kNormalMapFormat = getPluginResource("SubstancePlugin", "kAENormalMapFormat");
	string $kNMF0 = getPluginResource("SubstancePlugin", "kAENM0");
	string $kNMF1 = getPluginResource("SubstancePlugin", "kAENM1");
	string $kNMF2 = getPluginResource("SubstancePlugin", "kAENM2");
	string $kNMF3 = getPluginResource("SubstancePlugin", "kAENM3");
	string $kNMF4 = getPluginResource("SubstancePlugin", "kAENM4");
	string $kNMF5 = getPluginResource("SubstancePlugin", "kAENM5");
	string $kNMF6 = getPluginResource("SubstancePlugin", "kAENM6");
	string $kNMF7 = getPluginResource("SubstancePlugin", "kAENM7");
						
	attrEnumOptionMenuGrp
            -l $kNormalMapFormat
            -at $attributeName
            -ei 0  $kNMF0
            -ei 1  $kNMF1
            -ei 2  $kNMF2
            -ei 3  $kNMF3
            -ei 4  $kNMF4
            -ei 5  $kNMF5
            -ei 6  $kNMF6
            -ei 7  $kNMF7
            -enable 1 
            attrEnumOptionGroupNormalFormat;
	setParent ..;
	setUITemplate -ppt;

	NormalFormatReplace($attributeName);
}

global proc NormalFormatReplace(string $attributeName) {
	string $nodeName	= `match "[^.]*" $attributeName`;
	int $enabled		= isNormalFormatPresent($nodeName);
	attrEnumOptionMenuGrp -e -at $attributeName -enable $enabled attrEnumOptionGroupNormalFormat;
}

global proc GraphNew(string $attributeName) {
	global int $sbs_PreventSubstanceOutColorFromBeingConnectedDirectly;
	//global string $g_GoToMarketPlace;
	string $kEditTtip = getPluginResource("SubstancePlugin", "kAEEditTtip");
	
	setUITemplate -pst attributeEditorTemplate;
	
	string $nodeName = `match "[^.]*" $attributeName`;
	
	if ($sbs_PreventSubstanceOutColorFromBeingConnectedDirectly) {
		int $scriptJobAdded = `getAttr ($nodeName+".scriptJobAdded")`;
		if (! $scriptJobAdded) {
			//If we connect the outColor of this substance texture, replace with an output
			string $outcolorAttr = ($nodeName+".outColor");
			scriptJob -killWithScene -connectionChange $outcolorAttr ("sbs_SubstanceTextureOutColorConnected "+$outcolorAttr);
			setAttr ($nodeName+".scriptJobAdded") 1;
		}
	}
	
	string $kSubstanceFile = getPluginResource("SubstancePlugin", "kAESubstanceFile");
	string $kEdit = getPluginResource("SubstancePlugin", "kAEEdit");
	string $kReload = getPluginResource("SubstancePlugin", "kAEReload");
	string $kPreset = getPluginResource("SubstancePlugin", "kAEPreset");
	string $kSubstanceGraph = getPluginResource("SubstancePlugin", "kAESubstanceGraph");
		
	/*rowLayout -nc 4 -adjustableColumn 2 textureNameLayout;
		text -label $kSubstanceFile;
		//textField -text "" textFieldSubstanceFile;
		textField -text ""  -width 20 textFieldSubstanceFile;
		symbolButton -image "navButtonBrowse.png" substanceFileBrowser;
		symbolButton -image $g_GoToMarketPlace -annotation "Get more Substance..." substanceMarketPlace; 

	setParent ..;*/
	
	rowLayout -numberOfColumns 3 textureNameLayout;
		//-cw4 20 30 10 10
		//-columnAlign 1 "left"
		text -label $kSubstanceFile;
		textField -text "" textFieldSubstanceFile;
		symbolButton -image "navButtonBrowse.png" substanceFileBrowser;
		//symbolButton -image $g_GoToMarketPlace -annotation "Get more Substance..." substanceMarketPlace; 

	setParent ..;
	
	
	rowColumnLayout -numberOfRows 1 localSizeLayout;
		optionMenuGrp -label $kSubstanceGraph -width 270 optionMenuGrpGraph;
		button -label $kEdit -width 70 -enable true -annotation $kEditTtip substanceEdit;
		//button -label $kEdit -width 70 -enable true -annotation "Edit current Substance in Substance Designer/Player" substanceEdit;
		//-annotation "Edit current Substance in Substance Designer/Player"
	
	setParent ..;
		
		//button -label $kPreset -width 40 -enable true substancePresetEdit;
	//setParent ..;
	
	rowLayout -numberOfColumns 1 Reloading;
	
		button -label $kReload -width 150 -enable true reloadButton;
	
	setParent ..;
	
	string $layout = `formLayout -h 120 -w 100`;

	//Set predefined options in combo box
	treeView -numberOfButtons 1 
        -abr false 
        -reverseTreeOrder false 
        -editLabelCommand "precompExportEditorItemOnRename"
        -pressCommand 1 ("ChannelTreeViewButtonClickCommand "+$nodeName)
        treeControlChannel;
    setParent ..;//$layout
	formLayout -e
		-attachForm  treeControlChannel "top" 0
		-attachForm  treeControlChannel "left" 0
		-attachForm  treeControlChannel "bottom" 0
		-attachForm  treeControlChannel "right" 0
	$layout;
	
	setUITemplate -ppt;
	
	GraphReplace($attributeName);
}

global proc commandGraphOptionGroup(string $nodeName) {
	global int $sbs_PackageHasJustBeenChanged;	
	string $selectedGraph	= `optionMenuGrp -q -v optionMenuGrpGraph`;
	string $currentGraph	= `getAttr ($nodeName+".graph")`;	
	
	if ($currentGraph != $selectedGraph) {
		if ($currentGraph != "" && !$sbs_PackageHasJustBeenChanged) {
			string $kConfirm = getPluginResource("SubstancePlugin", "kAEConfirm");
			string $kMsgReload = getPluginResource("SubstancePlugin", "kAEMsgReloadGraph");
			string $kYes = getPluginResource("SubstancePlugin", "kAEYes");
			string $kNo = getPluginResource("SubstancePlugin", "kAENo");
	
			string $answer = `confirmDialog -title $kConfirm -message $kMsgReload
				-button $kYes -button $kNo -defaultButton $kYes
				-cancelButton $kNo -dismissString $kNo`;
			if ($answer == $kYes) {
				setAttr ($nodeName+".graph") -type "string" ($selectedGraph);
				updateUIWithCurrentSubstanceFile($nodeName);
				$sbs_PackageHasJustBeenChanged = 0;//reset our global variable
			} else {
				//Reset previous seclection in menu
				optionMenuGrp -e -v $currentGraph  optionMenuGrpGraph;
			}
		} else {
			$sbs_PackageHasJustBeenChanged = 0;//reset our global variable
			setAttr ($nodeName+".graph") -type "string" ($selectedGraph);
			updateUIWithCurrentSubstanceFile($nodeName);
		}
	} else {
		sbsDebugPrint("sbs_PackageHasJustBeenChanged = "+$sbs_PackageHasJustBeenChanged);
		//Graphs are the same, but packages may have been changed
		if ($sbs_PackageHasJustBeenChanged) {
			sbsDebugPrint("sbs_PackageHasJustBeenChanged = 1");
			$sbs_PackageHasJustBeenChanged = 0;//reset our global variable
			setAttr ($nodeName+".graph") -type "string" ($selectedGraph);
			updateUIWithCurrentSubstanceFile($nodeName);
		} else {
			sbsDebugPrint("sbs_PackageHasJustBeenChanged = 0");
		}
	}
}

global proc updateGraphItems(string $nodeName) {
	sbsDebugPrint("updateGraphItems with nodeName = "+$nodeName);
	//Get all graphs names
	string $menuItems[] = `optionMenuGrp -q -ill optionMenuGrpGraph`;
	
	int $numMenuItems = size($menuItems);
	//Erase all of them
	int $i=0;
	for (; $i<$numMenuItems; $i++) {
		deleteUI -mi $menuItems[$i];
	}
	
	string $graphNames[]	= sbs_GetGraphsNamesFromSubstanceNode($nodeName);
	int $numGraphs			= size($graphNames);
	for ($i=0;$i<$numGraphs;$i++) {
		menuItem -parent ("optionMenuGrpGraph|OptionMenu") -label ($graphNames[$i]);
	}
	
	sbsDebugPrint("num graphs = "+$numGraphs);
	 
	//Select the suitable graph
	if ($numGraphs > 0) {
		string $graphName = `getAttr ($nodeName+".graph")`;
		sbsDebugPrint("graphname = "+$graphName);
		if (size($graphName)) {
			int $numMenuItems	= `optionMenuGrp -q -ni optionMenuGrpGraph`;
			sbsDebugPrint("numMenuItems = "+$numMenuItems);
			string $menuItems[] = `optionMenuGrp -q -ill optionMenuGrpGraph`;
			for ($i = 0; $i < $numMenuItems; $i++) {
				string $label = `menuItem -q -label $menuItems[$i]`;
				sbsDebugPrint("label = "+$label);
				if ( $label == $graphName ) {
					optionMenuGrp -e -v $graphName optionMenuGrpGraph;
					commandGraphOptionGroup($nodeName);
					return;
				}
			}
			
			if ($numMenuItems) {
				//We didn't found it so select the first
				optionMenuGrp -e -sl 1 optionMenuGrpGraph;
				commandGraphOptionGroup($nodeName);
			}
		} else {
			int $numMenuItems	= `optionMenuGrp -q -ni optionMenuGrpGraph`;
			if ($numMenuItems) {
				//select the first
				optionMenuGrp -e -sl 1 optionMenuGrpGraph;
				commandGraphOptionGroup($nodeName);
			}
		}
	}
}

global proc reloadPackage(string $nodeName) {
	updateUIWithCurrentSubstanceFile($nodeName); //Update UI first for tweaks to be resetted
	setAttr ($nodeName+".reload") 1.0;
}

global proc string getToolTipFromChannel(string $channel)
{
	string $ttip = "This button creates a "+$channel+" output node ";
	if ($channel == "Opacity")
	{
		$ttip += "to the transparency channel of a shading network.";
	}
	else
	if ($channel == "Diffuse")
	{
		$ttip += "to the color channel of a shading network.";
	}
	else
	if ($channel == "Emissive")
	{
		$ttip += "to the incandescence channel of a shading network.";
	}
	else
	if ($channel == "Specular")
	{
		$ttip += "to the specularColor channel of a shading network.";
	}
	else
	if ($channel == "Normal")
	{
		$ttip += "to the normalCamera channel of a shading network.";
	}
	else
	if ($channel == "Bump")
	{
		$ttip += "to the normalCamera channel of a shading network.";
	}	
	else
	if ($channel == "Displacement")
	{
		$ttip += "to the displacementShader channel of a shading group.";
	}	
	else
	if ($channel == "Height")
	{
		$ttip += "to the displacementShader channel of a shading group.";
	}	
	else
	if ($channel == "Gloss")
	{
		$ttip += "to the roughness channel of a shading network.";
	}
	else
	if ($channel == "Glossiness")
	{
		$ttip += "to the roughness channel of a shading network.";
	}
	else
	{
		$ttip += "that can be connected to a shading network";
	}
	
	return $ttip;		
}
			
global proc GraphReplace(string $attributeName) {
//This can't be undone(Gordon)
flushUndo;
	global string $g_OutputConnectedUpAndDownStreamImage;
	global string $g_OutputConnectedUpStreamImage;
	global string $g_OutputNotConnectedImage;
	global int $sbs_PreventSubstanceOutColorFromBeingConnectedDirectly;
	
	//Update the UI with this node's attributes values
	string $nodeName = `match "[^.]*" $attributeName`;

	
	string $package = `getAttr ($nodeName+".package")`;
    string $graph	= `getAttr ($nodeName+".graph")`;    
    
	textField -e -text $package -backgroundColor 1.0 0.0 0.0 textFieldSubstanceFile;			
		
	if ($sbs_PreventSubstanceOutColorFromBeingConnectedDirectly) {
		int $scriptJobAdded = `getAttr ($nodeName+".scriptJobAdded")`;
		if (! $scriptJobAdded) {
			//If we connect the outColor of this substance texture, replace with an output
			string $outcolorAttr = ($nodeName+".outColor");
			scriptJob -killWithScene -connectionChange $outcolorAttr ("sbs_SubstanceTextureOutColorConnected "+$outcolorAttr);
			setAttr ($nodeName+".scriptJobAdded") 1;
		}
	}
	
	sbsDebugPrint("calling GraphReplace with nodename = "+$nodeName);

	button -e  -c ("reloadPackage "+$nodeName) reloadButton;
	
	//Update node name in UI callback and reset caption
	textField -e -cc ( "SubstanceFileEntered(\"" + $nodeName + "\")" ) textFieldSubstanceFile;
	symbolButton -e -c ( "BrowsePackagesButtonPressed(\"" + $nodeName + "\")" ) substanceFileBrowser; 
	
	//Edit substance
	button -e -c ("sbs_EditSubstance \""+$package+"\"") substanceEdit;
	//symbolButton -e -c ( "sbs_GoToMarketPlace()" ) substanceMarketPlace;
	
	//Presets
	//button -e -c ("sbs_EditSubstance \""+$package+"\"") substancePresetEdit;
	
	//Update graphs drop down list
	optionMenuGrp -e -cc ("commandGraphOptionGroup "+$nodeName) optionMenuGrpGraph;
	updateGraphItems($nodeName);
	
	//remove all items from list
	treeView -e -ra -pressCommand 1 ("ChannelTreeViewButtonClickCommand "+$nodeName) treeControlChannel; //Remove all items and update nodeName in callback
	
	textField -e -text "" -backgroundColor 0.16 0.16 0.16 -enableBackground false textFieldSubstanceFile;	
	
	sbsDebugPrint("package attr is = "+$package);
    sbsDebugPrint("graph attr is = "+$graph);
    
    if ( size($package) && size($graph) )
    {    
		string $prefix				= "outputdyn_";			
		string $channelsNames[]		= sbs_GetChannelsNamesFromSubstanceNode($nodeName);
		int $numChannels			= size($channelsNames);
		int $i;
		for ($i=0;$i<$numChannels;$i++)
		{
			string $channelName = $channelsNames[$i];
			treeView -e -addItem $channelName "" treeControlChannel;
			
			string $ttip = getToolTipFromChannel($channelName);
			treeView -e -buttonTooltip $channelName 1 $ttip treeControlChannel;
			
			int $state = getSubstanceOutputNodeState($nodeName, $channelName);
			switch( $state )
			{
				case 1:
					treeView -e -image ($channelName) 1 $g_OutputConnectedUpStreamImage treeControlChannel;
					break;
				case 2:
					treeView -e -image ($channelName) 1 $g_OutputConnectedUpAndDownStreamImage treeControlChannel;
					break;
				case 0:
				default:
					treeView -e -image ($channelName) 1 $g_OutputNotConnectedImage treeControlChannel;
				break;
			}
		}	
		
		//Update button caption
		textField -e -text ($package) textFieldSubstanceFile;			
    }
//This can't be undone (Gordon)
flushUndo;
}

global proc int sbsGetPowerOfTwo(int $number) {
	int $power = 0;
	int $copy = $number;
	while ($copy != 1) {
	   $copy = $copy / 2;
	   $power++;
	}
	
	return $power;
}

global proc int sbsComputePowerOfTwo(int $power) {
	return `pow 2 $power`;
}

//Description
//			This adjusts the movment of Size X and Size Y slider to the values of
//			power of 2.
//
global proc int sbsMakePowerOfTwo(int $sz) {
	int $prevSize = 0, $nextSize = 1;
	while ($nextSize < $sz ) {
	   $prevSize = $nextSize;
	   $nextSize = $nextSize * 2;
	}
	
	int $newSize;
	
	if (($sz - $prevSize) < ($nextSize - $sz)) {
			$newSize = $prevSize;
	} else {
		$newSize = $nextSize;
	}
	return $newSize;
	
}

global proc int guiEngineReplace(string $attributeName) {
	string $nodeName = `match "[^.]*" $attributeName`;
	string $engineAtt = $nodeName + ".globalEngine";
	
	attrEnumOptionMenuGrp -e -at $engineAtt engineMenuGrp;
	int $globalEngine = sbs_GetEngine();
	setAttr $engineAtt $globalEngine;
	return $globalEngine;
}

global proc guiEngine(string $attributeName) {
	string $nodeName = `match "[^.]*" $attributeName`;
	string $engineAtt = $nodeName + ".globalEngine";
	
	setUITemplate -pst attributeEditorTemplate;
	
	string $kEngine = getPluginResource("SubstancePlugin", "kAEEngine");
	
	//rowLayout -nc 2 -columnWidth2 195 195 engineNameLayout;	
		attrEnumOptionMenuGrp
			-l $kEngine
			-at $engineAtt
			-ei 0  "Software"
			-ei 1  "Hardware"
			-enable true
			engineMenuGrp;
	//setParent ..;
	
	setUITemplate -ppt;
	
	
	
	if (guiEngineReplace($attributeName) == 1 ) {
    string $window = `window -title "Warning"
       -widthHeight 265 70`;
	columnLayout;
	   text -label "";
       text -label "You need to restart Maya in order to apply changes." -align "center";
	   text -label "";
       button -label "Ok" -width 260 -align "center" -command ("deleteUI -window " + $window);
	setParent ..;
	showWindow $window;
    }
	
}

global proc guiAutoBakingReplace(string $attributeName) {
	string $nodeName = `match "[^.]*" $attributeName`;
	string $formatAtt = $nodeName + ".bakeFormat";
	
	attrEnumOptionMenuGrp -e -at $formatAtt attrEnumOptionGroupBakeFormat;
	int $format = sbs_GetBakeFormat();
	setAttr $formatAtt $format;	
}

global proc guiAutoBaking(string $attributeName) {
	global int $sbs_Indent;
	global int $sbs_AutomaticBakeCheck;
	string $nodeName = `match "[^.]*" $attributeName`;
	string $formatAtt = $nodeName + ".bakeFormat";
	
	string $kFormat = getPluginResource("SubstancePlugin", "kAEAutoBakeFormat");
	string $kAutoBakeConnections = getPluginResource("SubstancePlugin", "kAEAutoBakeConnections");
	string $kConnectEachAnn = getPluginResource("SubstancePlugin", "kAEConnectEachAnn");
	string $kBakedBitmapsAnn = getPluginResource("SubstancePlugin", "kAEBakedBitmapsAnn");
	
	rowLayout -nc 2 -columnAttach2 "left" "both" -columnOffset2 0 -35 -columnWidth2 195 195 AutoBakingLayout;
		
		checkBoxGrp 
			-numberOfCheckBoxes 1
			-l $kAutoBakeConnections
			-ann $kConnectEachAnn
			-v1 false
			-en true
			-onc "$sbs_AutomaticBakeCheck = 1"
			-ofc "$sbs_AutomaticBakeCheck = 0" 
			guiAutoBakeCheck;	
			
		attrEnumOptionMenuGrp
				-l $kFormat
				-ann $kBakedBitmapsAnn
				-at $formatAtt
				-ei 0 "jpg"
				-ei 1 "png"
				-ei 2 "tif"
				-ei 3 "tga"
				-enable true
				attrEnumOptionGroupBakeFormat; 
	
	setParent..;		
		    
    guiAutoBakingReplace($attributeName);
}

global proc guiGlobalTextureReplace(string $attributeName) {
	string $nodeName = `match "[^.]*" $attributeName`;
	string $widthAtt = $nodeName + ".globalTextureWidth";
	string $heightAtt = $nodeName + ".globalTextureHeight";
	string $editionAtt = $nodeName + ".editionModeScale";
	
	attrEnumOptionMenuGrp -e -at $widthAtt attrEnumOptionGroupGlobalWidth;
	int $globalTextureWidth = sbs_GetGlobalTextureWidth() - 5;
	setAttr $widthAtt $globalTextureWidth;
	
	attrEnumOptionMenuGrp -e -at $heightAtt attrEnumOptionGroupGlobalHeight;
	int $globalTextureHeight = sbs_GetGlobalTextureHeight() - 5;
	setAttr $heightAtt $globalTextureHeight;
	
	attrEnumOptionMenuGrp -e -at $editionAtt attrEnumOptionGroupEditionScale;
	int $editionScale = sbs_GetEditionModeScale();
	setAttr $editionAtt $editionScale;
}

global proc guiGlobalTexture(string $attributeName) {
	string $nodeName = `match "[^.]*" $attributeName`;
	string $widthAtt = $nodeName + ".globalTextureWidth";
	string $heightAtt = $nodeName + ".globalTextureHeight";
	string $editionAtt = $nodeName + ".editionModeScale";
	
	string $kGlobalWidth = getPluginResource("SubstancePlugin", "kAEGlobalWidth");
	string $kGlobalHeight = getPluginResource("SubstancePlugin", "kAEGlobalHeight");
	string $kGlobalScale = getPluginResource("SubstancePlugin", "kAEGlobalScale");
	
	setUITemplate -pst attributeEditorTemplate;
	
	//rowLayout -nc 2 -columnWidth2 207 203 globalSizeLayout;
		attrEnumOptionMenuGrp
				-l $kGlobalWidth
				-at $widthAtt
				-ei 0  "32"
				-ei 1  "64"
				-ei 2  "128"
				-ei 3  "256"
				-ei 4  "512"
				-ei 5  "1024" 
				-ei 6  "2048"
				-enable true
				attrEnumOptionGroupGlobalWidth;
	    
		attrEnumOptionMenuGrp
				-l $kGlobalHeight
				-at $heightAtt
				-ei 0  "32"
				-ei 1  "64"
				-ei 2  "128"
				-ei 3  "256"
				-ei 4  "512"
				-ei 5  "1024" 
				-ei 6  "2048"
				-enable true
				attrEnumOptionGroupGlobalHeight;
	//setParent ..;
    
    attrEnumOptionMenuGrp
        -l $kGlobalScale
        -at $editionAtt
        -ei 0  "x1"
        -ei 1  "1/2"
        -ei 2  "1/4"
        -ei 3  "1/8"
        -enable true
        -visible false
        attrEnumOptionGroupEditionScale;
        
    setUITemplate -ppt;
    
    guiGlobalTextureReplace($attributeName);
}

global proc guiLocalTextureReplace(string $attributeName) {
	string $nodeName = `match "[^.]*" $attributeName`;
	string $absoluteWidthAtt = $nodeName + ".absoluteTextureWidth";
	string $absoluteHeightAtt = $nodeName + ".absoluteTextureHeight";
	string $relativeWidthAtt = $nodeName + ".relativeTextureWidth";
	string $relativeHeightAtt = $nodeName + ".relativeTextureHeight";
	string $widthAtt = $nodeName + ".textureWidth";
	string $heightAtt = $nodeName + ".textureHeight";
	string $absoluteAtt = $nodeName + ".textureSizeAbsolute";
	string $lockARAtt = $nodeName + ".textureLockAspectRatio";
	int $bAbsolute = `getAttr ($absoluteAtt)`;
	int $bLockAR = `getAttr ($lockARAtt)`;
	
	attrEnumOptionMenuGrp
		-e -at $relativeWidthAtt
		-enable (!$bAbsolute)
		attrEnumOptionGroupLocalRelativeWidth;
    
	attrEnumOptionMenuGrp
		-e -at $relativeHeightAtt
		-enable (!$bAbsolute && !$bLockAR)
		attrEnumOptionGroupLocalRelativeHeight;
	      
    attrEnumOptionMenuGrp
		-e -at $absoluteWidthAtt
		-enable ($bAbsolute)		
		attrEnumOptionGroupLocalAbsoluteWidth;
	
	attrEnumOptionMenuGrp
		-e -at $absoluteHeightAtt
		-enable ($bAbsolute && !$bLockAR)
		attrEnumOptionGroupLocalAbsoluteHeight;
			
	attrEnumOptionMenuGrp
		-e
		-at $widthAtt
		-enable false
		attrEnumOptionGroupLocalWidth;
		
	attrEnumOptionMenuGrp
		-e
		-at $heightAtt
		-enable false
		attrEnumOptionGroupLocalHeight;
		
	checkBoxGrp
		-e
		-value1 $bAbsolute
		guiLocalTextureAbsoluteCheck;            
    
    checkBoxGrp
		-e
		-value1 $bLockAR
		guiLocalTextureLockARCheck; 
		
	button -e -command ("sbsExportImagesToDisk "+$nodeName) exportImagesToDiskButton;
	button -e -command ("sbsCreateShadingNet "+$nodeName) createShadingNetButton;
}

global proc guiLocalTextureAbsoluteChanged(string $attributeName) {
	string $nodeName = `match "[^.]*" $attributeName`;
	string $absoluteAtt = $nodeName + ".textureSizeAbsolute";
	int $bAbsolute = `getAttr ($absoluteAtt)`;
	$bAbsolute = !$bAbsolute;
	if ($bAbsolute) {
		int $width = `getAttr ($nodeName + ".textureWidth")`;
		int $height = `getAttr ($nodeName + ".textureHeight")`;
		setAttr ($nodeName + ".absoluteTextureWidth") $width;
		setAttr ($nodeName + ".absoluteTextureHeight") $height;	
	} else {
		int $width = `getAttr ($nodeName + ".textureWidth")`;
		int $height = `getAttr ($nodeName + ".textureHeight")`;
		int $globalWidth = sbs_GetGlobalTextureWidth()-5;
		int $globalHeight = sbs_GetGlobalTextureHeight()-5;
		setAttr ($nodeName + ".relativeTextureWidth") ($width-$globalWidth+7);
		setAttr ($nodeName + ".relativeTextureHeight") ($height-$globalHeight+7);	
	}
	
	setAttr ($absoluteAtt) $bAbsolute;
		
	guiLocalTextureReplace($attributeName);
}

global proc guiLocalTextureLockARChanged(string $attributeName) {
	string $nodeName = `match "[^.]*" $attributeName`;
	string $lockAtt = $nodeName + ".textureLockAspectRatio";
	int $bLock = `getAttr ($lockAtt)`;
	$bLock = !$bLock;
	setAttr ($lockAtt) $bLock;
	guiLocalTextureReplace($attributeName);
}

global proc guiLocalTexture(string $attributeName) {
	global int $sbs_Indent;
	string $nodeName = `match "[^.]*" $attributeName`;
	string $absoluteWidthAtt = $nodeName + ".absoluteTextureWidth";
	string $absoluteHeightAtt = $nodeName + ".absoluteTextureHeight";
	string $relativeWidthAtt = $nodeName + ".relativeTextureWidth";
	string $relativeHeightAtt = $nodeName + ".relativeTextureHeight";
	string $widthAtt = $nodeName + ".textureWidth";
	string $heightAtt = $nodeName + ".textureHeight";
	string $absoluteAtt = $nodeName + ".textureSizeAbsolute";
	
	string $kRelativeWidth = getPluginResource("SubstancePlugin", "kAERelativeWidth");
	string $kRelativeHeight = getPluginResource("SubstancePlugin", "kAERelativeHeight");
	string $kAbsoluteWidth = getPluginResource("SubstancePlugin", "kAEAbsoluteWidth");
	string $kAbsoluteHeight = getPluginResource("SubstancePlugin", "kAEAbsoluteHeight");
	string $kAbsoluteSizes = getPluginResource("SubstancePlugin", "kAEAbsoluteSizes");
	string $kLockAR = getPluginResource("SubstancePlugin", "kAELockAR");
	string $kOutputWidth = getPluginResource("SubstancePlugin", "kAEOutputWidth");
	string $kOutputHeight = getPluginResource("SubstancePlugin", "kAEOutputHeight");
	string $kCreateNetwork = getPluginResource("SubstancePlugin", "kAECreateShaderNetwork");
	string $kExportImages = getPluginResource("SubstancePlugin", "kAEExportImages");
		
	setUITemplate -pst attributeEditorTemplate;
	
	rowLayout -nc 2 -columnAttach2 "both" "both" -columnOffset2 -50 -50 -columnWidth2 195 195 localRelativeSizeLayout;		
		attrEnumOptionMenuGrp
			-l $kRelativeWidth
			-at $relativeWidthAtt
			-ei 0  "1/128"
			-ei 1  "1/64"
			-ei 2  "1/32"
			-ei 3  "1/16"
			-ei 4  "1/8"
			-ei 5  "1/4" 
			-ei 6  "1/2"
			-ei 7  "x1"
			-ei 8  "x2"
			-ei 9  "x4"
			-ei 10  "x8"
			-ei 11  "x16"
			-ei 12  "x32"
			-ei 13  "x64"
			-ei 14  "x128"	
			attrEnumOptionGroupLocalRelativeWidth;
	    
	    attrEnumOptionMenuGrp
			-l $kRelativeHeight
			-at $relativeHeightAtt
			-ei 0  "1/128"
			-ei 1  "1/64"
			-ei 2  "1/32"
			-ei 3  "1/16"
			-ei 4  "1/8"
			-ei 5  "1/4" 
			-ei 6  "1/2"
			-ei 7  "x1"
			-ei 8  "x2"
			-ei 9  "x4"
			-ei 10  "x8"
			-ei 11  "x16"
			-ei 12  "x32"
			-ei 13  "x64"
			-ei 14  "x128"	
			attrEnumOptionGroupLocalRelativeHeight;
	setParent..;
	      
    rowLayout -nc 2 -columnAttach2 "both" "both" -columnOffset2 -50 -50 -columnWidth2 195 195 localAbsoluteSizeLayout;
		attrEnumOptionMenuGrp
			-l $kAbsoluteWidth
			-at $absoluteWidthAtt
			-ei 0  "32"
			-ei 1  "64"
			-ei 2  "128"
			-ei 3  "256"
			-ei 4  "512"
			-ei 5  "1024" 
			-ei 6  "2048"
			attrEnumOptionGroupLocalAbsoluteWidth;
		
		attrEnumOptionMenuGrp
			-l $kAbsoluteHeight
			-at $absoluteHeightAtt
			-ei 0  "32"
			-ei 1  "64"
			-ei 2  "128"
			-ei 3  "256"
			-ei 4  "512"
			-ei 5  "1024" 
			-ei 6  "2048"
			attrEnumOptionGroupLocalAbsoluteHeight;
	setParent..;
	
	rowLayout -nc 2 -columnAttach2 "both" "both" -columnOffset2 -75 -75 -columnWidth2 195 195 localOptionsSizeLayout;
		
		checkBoxGrp
			-numberOfCheckBoxes 1
			-columnWidth 1 $sbs_Indent
			-enable true
			-label $kAbsoluteSizes   
			-changeCommand ( "guiLocalTextureAbsoluteChanged(\"" + $nodeName + "\")" )
			guiLocalTextureAbsoluteCheck;            
	            
		checkBoxGrp
			-numberOfCheckBoxes 1
			-columnWidth 1 $sbs_Indent
			-enable true
			-label $kLockAR        
			-changeCommand ( "guiLocalTextureLockARChanged(\"" + $nodeName + "\")" )
			guiLocalTextureLockARCheck;            
	setParent..;
	
	rowLayout -nc 2 -columnAttach2 "both" "both" -columnOffset2 -50 -50 -columnWidth2 195 195 localSizeLayout;
		attrEnumOptionMenuGrp
			-l $kOutputWidth
			-at $widthAtt
			-enable false
			-ei 0  "32"
			-ei 1  "64"
			-ei 2  "128"
			-ei 3  "256"
			-ei 4  "512"
			-ei 5  "1024" 
			-ei 6  "2048"
			attrEnumOptionGroupLocalWidth;
			
		attrEnumOptionMenuGrp
			-l $kOutputHeight
			-at $heightAtt
			-enable false
			-ei 0  "32"
			-ei 1  "64"
			-ei 2  "128"
			-ei 3  "256"
			-ei 4  "512"
			-ei 5  "1024" 
			-ei 6  "2048"
			attrEnumOptionGroupLocalHeight;
	setParent..;
	     
	rowLayout -nc 2 -columnAttach2 "both" "both" -columnWidth2 195 195;
		button -label $kCreateNetwork -enable true -width 149 -command ("sbsCreateShadingNet "+$nodeName) createShadingNetButton;
		button -label $kExportImages -enable true -w 149 -command ("sbsExportImagesToDisk "+$nodeName) exportImagesToDiskButton;
	setParent ..;
	   
    setUITemplate -ppt;
    
    guiLocalTextureReplace($attributeName);
}

global proc AEsubstanceTemplate(string $nodeName) {
	string $kPanelTexture = getPluginResource("SubstancePlugin", "kAEPanelTexture");
	string $kPanelParameters = getPluginResource("SubstancePlugin", "kAEPanelParameters");
	string $kPanelNormal = getPluginResource("SubstancePlugin", "kAEPanelNormal");
	string $kPanelUV = getPluginResource("SubstancePlugin", "kAEPanelUV");
	string $kPanelEngine = getPluginResource("SubstancePlugin", "kAEPanelEngine");
	string $kPanelBaking = getPluginResource("SubstancePlugin", "kAEAutoBaking");
	
	string $package = `getAttr ($nodeName+".package")`;
    string $graph	= `getAttr ($nodeName+".graph")`;
    if ($package!="")
		updateTweaks($nodeName, $package, $graph);
	
	AEswatchDisplay $nodeName;
	editorTemplate -beginScrollLayout;

	editorTemplate -beginLayout $kPanelTexture -collapse 0;
		editorTemplate -callCustom "GraphNew" "GraphReplace" "graph";
		editorTemplate -callCustom "guiLocalTexture" "guiLocalTextureReplace" "textureWidth";
	editorTemplate -endLayout;
	
	editorTemplate -beginLayout $kPanelParameters -collapse 1;
		editorTemplate -callCustom "TweaksNew" "TweaksReplace" "tweaks";
	editorTemplate -endLayout;
	
	editorTemplate -beginLayout $kPanelNormal -collapse 1;
		editorTemplate -callCustom "NormalFormatNew" "NormalFormatReplace" "normalFormat";
	editorTemplate -endLayout;
	
	editorTemplate -beginLayout $kPanelUV -collapse 1;
		editorTemplate -addControl "uvCoord";
	editorTemplate -endLayout;
	
	editorTemplate -beginLayout $kPanelEngine -collapse 1;
		//editorTemplate -callCustom "guiEngine" "guiEngineReplace" "globalEngine";
		editorTemplate -callCustom "guiGlobalTexture" "guiGlobalTextureReplace" "globalTextureWidth";
	editorTemplate -endLayout;
	
	editorTemplate -beginLayout $kPanelBaking -collapse 1;
		editorTemplate -callCustom "guiAutoBaking" "guiAutoBakingReplace" "bakeFormat";
	editorTemplate -endLayout;
	
	// include/call base class/node attributes
	AEdependNodeTemplate $nodeName;

	editorTemplate -endScrollLayout;
}

global proc sbsTextureSizeChangeResolutionDragCmdExportImages(int $sz, string $sliderName, string $nodeName) {
	int $newSize = sbsMakePowerOfTwo($sz);
	intSliderGrp -e -value $newSize $sliderName;
	sbsDebugPrint("newSize = "+$newSize);
	
	sbsAdjustSizeSliderExportImages($sliderName, 1, $nodeName);
}

global proc sbsTextureSizeChangeResolutionChCmdExportImages(int $sz, string $sliderName, string $nodeName) {
	sbsAdjustSizeSliderExportImages($sliderName, 0, $nodeName);
}

//Description
//			This adjusts the x resolution and y resolution when the aspect 
//			ratio check box is toggled on
//
global proc sbsAdjustSizeSliderExportImages(string  $sliderName, int $makePowerTwoFlag, string $nodeName) {
	global float $sbsTextureSizeAspectRatioExportImages;
	
	int $newVal = 0;
	int $value = `checkBoxGrp -q -v1 checkBoxGrpTextureSizeAspectRatioExportImages`;
	if ($value) {
		if ($sliderName == "intSliderGrpTextureWidthExportImages") {
			int $valX		= eval("intSliderGrp -q -value intSliderGrpTextureWidthExportImages");
			int $tempVal	= $valX / $sbsTextureSizeAspectRatioExportImages;
			$newVal			= $tempVal;
			if ($makePowerTwoFlag) {
				$newVal = sbsMakePowerOfTwo($tempVal);
			}
			intSliderGrp -e -v $newVal intSliderGrpTextureHeightExportImages;
		} else {
			int $valY		= eval("intSliderGrp -q -value intSliderGrpTextureHeightExportImages");
			int $tempVal	= $valY * $sbsTextureSizeAspectRatioExportImages;
			$newVal			= $tempVal;
			if($makePowerTwoFlag) {
				$newVal = sbsMakePowerOfTwo($tempVal);
			}
			intSliderGrp -e -v $newVal intSliderGrpTextureWidthExportImages;
		}
	}
}

//Description
//			Calcuates the aspect ratio and maintains
//			it with respect to x and y resolution
//
global proc sbsTextureSizeLockAspectRatioCmdExportImages(int $aspect) {
	global float $sbsTextureSizeAspectRatioExportImages;
		
	if ($aspect) {
		float $sizeX = `intSliderGrp -q -value intSliderGrpTextureWidthExportImages`;
		float $sizeY = `intSliderGrp -q -value intSliderGrpTextureHeightExportImages`;

		$sbsTextureSizeAspectRatioExportImages = $sizeX / $sizeY;
	}
}

global proc sbsExportImagesToDisk(string $nodeName) {
	global int $sbs_Indent;
	global string	$sbsExportImagesToDiskPath;
	global int		$sbsCreateShaderNetworkExportImages;
	global int		$sbsTextureWidthExportImages;
	global int		$sbsTextureHeightExportImages;
	global int		$sbsKeepAspectRatioExportImages;
	global string	$sbsImageFormatExportImages;
	
	string $kSBSBake = getPluginResource("SubstancePlugin", "kAESBSBake");
	string $kSubstancePath = getPluginResource("SubstancePlugin", "kAESubstancePath");
	string $kCreateNetwork = getPluginResource("SubstancePlugin", "kAECreateShaderNetwork");
	string $kSBPath = getPluginResource("SubstancePlugin", "kAESBSPath");
	string $kSBImageFormat = getPluginResource("SubstancePlugin", "kAESBSImageFormat");
	string $kSBExport = getPluginResource("SubstancePlugin", "kAEExport");
	string $kSBClose = getPluginResource("SubstancePlugin", "kAEClose");
	
	
	if (`window -q -ex sbsBakeToTextureWin`) {
		deleteUI sbsBakeToTextureWin;
	}
	window -wh 375 195 -title $kSBSBake -s 0 sbsBakeToTextureWin;
	columnLayout -adjustableColumn false $kSBSBake;
    
    rowLayout -numberOfColumns 3
			-columnWidth3 40 60 50
			-columnAttach3 "left" "left" "left"
			-columnOffset3 10 0 2
			-adjustableColumn 2;
			
	text ($kSBPath+":");
					
	textField -width 305
			-ann $kSubstancePath
			-en 1
			-tx $sbsExportImagesToDiskPath
			sbsExportPathTFExportImages;
											
	symbolButton -image "navButtonBrowse.xpm"
				-command "sbsExportImagesToDisk_fileBrowser"
				-en 1;
	setParent..;
	
	rowLayout	-numberOfColumns 3
				-columnWidth3 195 120 60
				-columnAttach3 "both" "both" "both"
				-columnOffset3  5 20 -25
				-adjustableColumn 3;
		
		checkBoxGrp 
		-numberOfCheckBoxes 1 
		-columnWidth 1 $sbs_Indent
		-label $kCreateNetwork
		-value1 $sbsCreateShaderNetworkExportImages
		checkBoxGrpConnectMapsExportImages;
	
		text ($kSBImageFormat+":");		
        optionMenuGrp sbsFormatOMGExportImages;
            menuItem -label "jpg";
            menuItem -label "png";
            menuItem -label "tif";
            menuItem -label "tga";
            //menuItem -label "hdr";
    setParent..;	 
	
	//Select current image format
    optionMenuGrp -e -v $sbsImageFormatExportImages  sbsFormatOMGExportImages;
    
    /*int $textureWidth	= `getAttr ($nodeName+".textureWidth")`;
	int $pow2Width		= sbsComputePowerOfTwo($textureWidth);
	*/
	
    intSliderGrp 
		-columnWidth 1 $sbs_Indent
		-label (uiRes("m_performSurfaceSampling.kMapwidth")) 
		-field true
   		-minValue 128 -maxValue 2048
		-fieldMinValue 128 -fieldMaxValue 2048
		-dragCommand ("sbsTextureSizeChangeResolutionDragCmdExportImages #1 intSliderGrpTextureWidthExportImages "+$nodeName)
		-changeCommand ("sbsTextureSizeChangeResolutionChCmdExportImages #1 intSliderGrpTextureWidthExportImages "+$nodeName)
		-value $sbsTextureWidthExportImages
		intSliderGrpTextureWidthExportImages;

	/*int $textureHeight	= `getAttr ($nodeName+".textureHeight")`;
	int $pow2Height		= sbsComputePowerOfTwo($textureHeight);
	*/
	
	intSliderGrp 
		-columnWidth 1 $sbs_Indent
		-label (uiRes("m_performSurfaceSampling.kMapheight"))
		-field true
   		-minValue 128 -maxValue 2048
		-fieldMinValue 128 -fieldMaxValue 2048
		-dragCommand ("sbsTextureSizeChangeResolutionDragCmdExportImages #1 intSliderGrpTextureHeightExportImages "+$nodeName)
		-changeCommand ("sbsTextureSizeChangeResolutionChCmdExportImages #1 intSliderGrpTextureHeightExportImages "+$nodeName)		
		-value $sbsTextureHeightExportImages
		intSliderGrpTextureHeightExportImages;

	checkBoxGrp 
		-numberOfCheckBoxes 1 
		-columnWidth 1 $sbs_Indent
		-enable true
		-label (uiRes("m_performSurfaceSampling.kKeepAspectRatio"))
		-value1 $sbsKeepAspectRatioExportImages
		checkBoxGrpTextureSizeAspectRatioExportImages;
	
    rowLayout -numberOfColumns 2
			-columnWidth2 80 80
			-columnAttach2 "left" "left"
			-columnOffset2 0 0
			-adjustableColumn 2;
			
	button -w 185 -l $kSBExport -c ("sbsPerformSbsBakeToTexture "+$nodeName);
	button -w 185 -l $kSBClose -c ("sbsCloseBakeWindow "+$nodeName);
			
showWindow sbsBakeToTextureWin;				
}

global proc sbsCloseBakeWindow(string $nodeName) {
	global string	$sbsExportImagesToDiskPath;
	global int		$sbsCreateShaderNetworkExportImages;
	global int		$sbsTextureWidthExportImages;
	global int		$sbsTextureHeightExportImages;
	global int		$sbsKeepAspectRatioExportImages;
	global string	$sbsImageFormatExportImages;
	
	//update our global variables
	$sbsExportImagesToDiskPath			= `textField -q -tx sbsExportPathTFExportImages`;
	$sbsImageFormatExportImages			= `optionMenuGrp -q -v sbsFormatOMGExportImages`;
	$sbsKeepAspectRatioExportImages 	= `checkBoxGrp -q -v1 checkBoxGrpTextureSizeAspectRatioExportImages`;
	$sbsTextureWidthExportImages		= eval("intSliderGrp -q -value intSliderGrpTextureWidthExportImages");
	$sbsTextureHeightExportImages		= eval("intSliderGrp -q -value intSliderGrpTextureHeightExportImages");
	$sbsCreateShaderNetworkExportImages	= `checkBoxGrp -q -v1 checkBoxGrpConnectMapsExportImages`;
	
	deleteUI sbsBakeToTextureWin;
}

global proc sbsExportImagesToDisk_fileBrowser() {
	global string $sbsExportImagesToDiskPath;
	string $kSBSBakePath = getPluginResource("SubstancePlugin", "kAESBSBakePath");
	string $kSelect = getPluginResource("SubstancePlugin", "kAESelect");
    // this will select a directory:

    string $workspace = `workspace -fn`;
    string $startDir = `setWorkingDirectory $workspace "Folder" "Select"`;
    if (size($sbsExportImagesToDiskPath)) {
		$startDir = $sbsExportImagesToDiskPath ;
	}
	
    string $userChoice[] = `fileDialog2 -fileMode 3 -startingDirectory $startDir -caption $kSBSBakePath -okCaption $kSelect `;

    if( size($userChoice) > 0 && $userChoice[0] != "" ) {
        string $path = fromNativePath($userChoice[0]);
            
        textField -e -tx $path sbsExportPathTFExportImages;        
		
		//Update our global variable
		$sbsExportImagesToDiskPath = $path;
    }
}

global proc sbsConvertShadingNetwork_fileBrowser() {
    // this will select a directory:

    string $workspace = `workspace -fn`;
    string $startDir = `setWorkingDirectory $workspace "Folder" "Select"`;

	string $kSBSBakePath = getPluginResource("SubstancePlugin", "kAESBSBakePath");
	string $kSelect = getPluginResource("SubstancePlugin", "kAESelect");
	
	string $userChoice[] = `fileDialog2 -fileMode 3 -startingDirectory $startDir -caption $kSBSBakePath -okCaption $kSelect `;

    if( size($userChoice) > 0 && $userChoice[0] != "" ) {
        string $path = fromNativePath($userChoice[0]);
            
        textField -e -tx $path sbsExportPathTFConvertShadingNetwork;        

        string $currentDir = `workspace -q -dir`;
        retainWorkingDirectory $currentDir;
    }
}

global proc sbsUpdateAllOutputsBitmapType(string $nodeName, string $bmapType) {
	string $prefix = "outputdyn_";	
	
	if ($bmapType == "" || $nodeName == "") { return; }
		
	string $package = `getAttr ($nodeName+".package")`;
    string $graph	= `getAttr ($nodeName+".graph")`;
    
    if ($package != "" && $graph != "") {
		string $channelsNames[]	= sbs_GetChannelsNamesFromSubstanceNode($nodeName);
		
		string $curChannel = "";
		
		//Create all channels attributes
		for ($curChannel in $channelsNames) {
			//Create the channel image type attribute (when exporting to disk)
			string $attrNameWithPrefix = $prefix + $curChannel+"_imageFormat";
			
			if ( `attributeQuery -exists -node $nodeName $attrNameWithPrefix` == true) {
				setAttr ($nodeName+"."+$attrNameWithPrefix) -type "string" $bmapType; 
			} else {
				sbsDebugPrint("Error in sbsUpdateAllOutputsBitmapType, the attribute doesn't exist !");
				sbsDebugPrint("Error in sbsUpdateAllOutputsBitmapType, nodeName = "+$nodeName);
				sbsDebugPrint("Error in sbsUpdateAllOutputsBitmapType, attrNameWithPrefix = "+$attrNameWithPrefix);
			}
		}		
	}
}

global proc connectFileTextureNodeToMaterial(string $node, string $material, string $channel) {
	//$node may be a substance output node or a fileTexture or anything else...
	if ($material == "") {
		//Create/Get material and shading group
		string $material = sbs_GetMaterialFromSubstanceNodeOrCreateIt($node);
		if (!size($material)) { return; }
	}
	
	string $shadingGroup = sbs_GetShadingGroupFromMaterial($material);
    
	if ($channel == "Opacity" && ( `attributeQuery -exists -node $material "transparency"` == true) ) {
		string $reverse = `shadingNode -asUtility reverse`;
		connectAttr -f ($node + ".outColor") ($reverse + ".input");
		connectAttr -f ($reverse + ".output") ($material + ".transparency");
	} else if ($channel == "Diffuse" && ( `attributeQuery -exists -node $material "color"` == true) ) {
		connectAttr -f ($node  + ".outColor") ($material + ".color");
	} else if ($channel == "Emissive" && ( `attributeQuery -exists -node $material "incandescence"` == true) ) {
		connectAttr -f ($node  + ".outColor") ($material + ".incandescence");
	} else if ($channel == "Specular" && ( `attributeQuery -exists -node $material "specularColor"` == true) ) {
		connectAttr -f ($node + ".outColor") ($material + ".specularColor");
	} else if ($channel == "Normal" && ( `attributeQuery -exists -node $material "normalCamera"` == true) ) {
		string $bump2d = `shadingNode -asUtility bump2d`;
		connectAttr -f ($node + ".outAlpha") ($bump2d + ".bumpValue");
		connectAttr -f ($bump2d + ".outNormal") ($material + ".normalCamera");
		select -r $bump2d;
		setAttr ($bump2d + ".bumpInterp") 1;
		rename $bump2d ($node + "_bump2d");
	} else if ($channel == "Bump" && ( `attributeQuery -exists -node $material "normalCamera"` == true) ) {
		string $bump2d = `shadingNode -asUtility bump2d`;
		connectAttr -f ($node + ".outColorR") ($bump2d + ".bumpValue");
		string $connectedNodes[] = `listConnections ($material + ".normalCamera")`;
		if (!size($connectedNodes)) {
			//connect if not already something
			connectAttr -f ($bump2d + ".outNormal") ($material + ".normalCamera");
		}
		select -r $bump2d;
		rename $bump2d ($node + "_bump2d");
	} else if ($channel == "Glossiness" && ( `attributeQuery -exists -node $material "roughness"` == true) ) {
		connectAttr -f ($node + ".outColorR") ($material + ".roughness");
    } else if ($channel == "Gloss" && ( `attributeQuery -exists -node $material "roughness"` == true) ) {
		connectAttr -f ($node + ".outColorR") ($material + ".roughness");
    } else if ( ($channel == "Height") && $shadingGroup != "")  {
		string $dispShader = `shadingNode -asShader displacementShader`;
    
		select -r $dispShader;
		$dispShader = `rename $dispShader ($node + "_heightMap")`;
		
		connectAttr -f ($node + ".outColorR") ($dispShader + ".displacement");
		
		string $attr = ($dispShader + ".displacement");
		connectAttr -f $attr ($shadingGroup + ".displacementShader");
	} else if ( ($channel == "Displacement") && $shadingGroup != "") {
		string $dispShader = `shadingNode -asShader displacementShader`;
		select -r $dispShader;
		$dispShader = `rename $dispShader ($node + "_DisplacementMap")`;
		
		connectAttr -f ($node + ".outColorR") ($dispShader + ".displacement");
		
		string $connectedDispShaders[] = `listConnections ($shadingGroup + ".displacementShader")`;
		if (!size($connectedDispShaders)) {	
			//Connect it
			string $attr = ($dispShader + ".displacement");
			connectAttr -f $attr ($shadingGroup + ".displacementShader");
		}
	}
}

global proc sbsPerformSbsBakeToTexture(string $nodeName) {
	global string	$sbsExportImagesToDiskPath;
	global int		$sbsCreateShaderNetworkExportImages;
	global int		$sbsTextureWidthExportImages;
	global int		$sbsTextureHeightExportImages;
	global int		$sbsKeepAspectRatioExportImages;
	global string	$sbsImageFormatExportImages;
	string $sbsBakingIntoPathMessageA = getPluginResource("SubstancePlugin", "kAESBSBakingIntoPathA");
	string $sbsBakingIntoPathMessageB = getPluginResource("SubstancePlugin", "kAESBSBakingIntoPathB");
	string $sbsBakingIntoPathMessageC = getPluginResource("SubstancePlugin", "kAESBSBakingIntoPathC");
	
	//update our global variables
	$sbsExportImagesToDiskPath			= `textField -q -tx sbsExportPathTFExportImages`;
	$sbsImageFormatExportImages			= `optionMenuGrp -q -v sbsFormatOMGExportImages`;
	$sbsKeepAspectRatioExportImages 	= `checkBoxGrp -q -v1 checkBoxGrpTextureSizeAspectRatioExportImages`;
	$sbsTextureWidthExportImages		= eval("intSliderGrp -q -value intSliderGrpTextureWidthExportImages");
	$sbsTextureHeightExportImages		= eval("intSliderGrp -q -value intSliderGrpTextureHeightExportImages");
	$sbsCreateShaderNetworkExportImages	= `checkBoxGrp -q -v1 checkBoxGrpConnectMapsExportImages`;
	
	if ($sbsExportImagesToDiskPath == "") {	return;	}

	//Update both texturesize attributes
	int $bAbsolute;
	int $bAbsoluteWidth;
	int $bAbsoluteHeight;
	if ($nodeName != "") {
		//Update attributes
		int $pow2Width  = sbsGetPowerOfTwo($sbsTextureWidthExportImages)-5;
		int $pow2Height = sbsGetPowerOfTwo($sbsTextureHeightExportImages)-5;
		
		string $absoluteAtt = $nodeName + ".textureSizeAbsolute";
		$bAbsolute = `getAttr ($absoluteAtt)`;
		if (!$bAbsolute) {
			guiLocalTextureAbsoluteChanged($absoluteAtt);
		}
		
		$bAbsoluteWidth = getAttr ($nodeName+".absoluteTextureWidth");
		$bAbsoluteHeight = getAttr ($nodeName+".absoluteTextureHeight");
			
		setAttr ($nodeName+".absoluteTextureWidth")  $pow2Width;
		setAttr ($nodeName+".absoluteTextureHeight") $pow2Height;
	}

	//The substance output node will bake its texture and create the file texture node
	string $connectedOutputNodesTemp[] = `listConnections -type "substanceOutput" $nodeName`;
	string $connectedOutputNodes[] = `stringArrayRemoveDuplicates($connectedOutputNodesTemp)`; //remove duplicates
	if (!size($connectedOutputNodes)) {
		string $kSBSBakeFailed = getPluginResource("SubstancePlugin", "kAESBSBakeFailed");
		string $kOk = getPluginResource("SubstancePlugin", "kAEOk");

		confirmDialog
				-message $kSBSBakeFailed
				-button $kOk
				-defaultButton $kOk;
				
		select -r $nodeName;
		return;				
	}
	
	//Update all outputs bitmap format
	string $outputNode = "";
	for ($outputNode in $connectedOutputNodes) {
		string $cmd = "setAttr "+$outputNode+".imageFormat -type \"string\" \""+$sbsImageFormatExportImages+"\"";
		eval($cmd);
		
		//set the path in the attribute, this launches the exportdisk function
		string $cmd = "setAttr "+$outputNode+".imagesExportPath -type \"string\" \""+$sbsExportImagesToDiskPath+"\"";
		eval($cmd);
		
		//connect place2D
		{
			string $fileTextureNodeCreated  = `getAttr ($outputNode+".fileNodeName")`;			
			string $place2DTextureNode[]	= `listConnections ($outputNode+".uv")`;
			string $oldPlace2DTextureNode[] = `listConnections ($fileTextureNodeCreated+".uv")`;

			//delete the auto place2d
			if (size($oldPlace2DTextureNode)) {	
				delete $oldPlace2DTextureNode[0];
			}
		
			//connect the substance one
			if (size($place2DTextureNode)) {
				connectAttr ($place2DTextureNode[0]+".outUV") ($fileTextureNodeCreated+".uv");
				connectAttr ($place2DTextureNode[0]+".outUvFilterSize") ($fileTextureNodeCreated+".uvFilterSize");
			}
		}
	}	
	
	//Restore both texturesize attributes
	if ($nodeName != "") {
		setAttr ($nodeName+".absoluteTextureWidth")  $bAbsoluteWidth;
		setAttr ($nodeName+".absoluteTextureHeight") $bAbsoluteHeight;	
	
		if (!$bAbsolute) {
			string $absoluteAtt = $nodeName + ".textureSizeAbsolute";		
			guiLocalTextureAbsoluteChanged($absoluteAtt);
		}	
	}	
	
	if ($sbsCreateShaderNetworkExportImages) {
		//Get material from node, or create it
		string $materialName = ($nodeName + "_MaterialBaked");
		string $materialNodeName[]	= `ls $materialName`;
		if (!size($materialNodeName)) {
			//Doesn't exist yet so create material and shading group
			string $material		= `shadingNode -asShader phongE`;
			string $shadingGroup    = `sets -renderable true -noSurfaceShader true -empty -name phongE2SG`;
			// connect material2shadingG //
			connectAttr -f ($material + ".outColor") ($shadingGroup + ".surfaceShader");
		    
			select -r $material;
			$materialName = `rename $material $materialName`;
		}
		
		for ($outputNode in $connectedOutputNodes) {
			//Names of the file texture node created is 
			string $fileTextureNodeCreated = `getAttr ($outputNode+".fileNodeName")`;
			//Get the channel it is
			string $channelName = `getAttr ($outputNode+".channelName")`;
			if ($fileTextureNodeCreated != "") {
				connectFileTextureNodeToMaterial($fileTextureNodeCreated, $materialName, $channelName);
			}
		}	
	}
	sbs_RearrangeHypershadeGraph();
	select -r $nodeName;
	print($sbsBakingIntoPathMessageA+$nodeName+$sbsBakingIntoPathMessageB+$sbsExportImagesToDiskPath+$sbsBakingIntoPathMessageC+$sbsTextureWidthExportImages+" x "+$sbsTextureHeightExportImages+"\n");
}

global proc sbsCreateShadingNet(string $nodeName) {
    string $graph				= `getAttr ($nodeName+".graph")`;
    string $package				= `getAttr ($nodeName+".package")`;
    string $prefix              = "outputdyn_"; 
    string $postfixChannelName  = "_Name";
   
    //Opacity
    string $attrName = $prefix+"Opacity"+$postfixChannelName;
    if ( `attributeQuery -exists -node $nodeName $attrName` == true) {
        ChannelTreeViewButtonClickCommand( $nodeName, "Opacity", 1);
    }
    
    //Specular
    string $attrName = $prefix+"Specular"+$postfixChannelName;
    if ( `attributeQuery -exists -node $nodeName $attrName` == true) {
        ChannelTreeViewButtonClickCommand( $nodeName, "Specular", 1);
    }
   
    //Normal
    string $attrName = $prefix+"Normal"+$postfixChannelName;
    if ( `attributeQuery -exists -node $nodeName $attrName` == true) {
        ChannelTreeViewButtonClickCommand( $nodeName, "Normal", 1);
    } else {
		//If no normal is present, connect the bump (if any)
		//Bump
		string $attrName = $prefix+"Bump"+$postfixChannelName;
		if ( `attributeQuery -exists -node $nodeName $attrName` == true) {
			ChannelTreeViewButtonClickCommand( $nodeName, "Bump", 1);
		}
    }
   
	//don't connect the displacement or height map automatically
	/*//Displacement
    string $attrName = $prefix+$sbsDisplacementStr+$postfixChannelName;
    if ( `attributeQuery -exists -node $nodeName $attrName` == true) {
        ChannelTreeViewButtonClickCommand( $nodeName, $sbsDisplacementStr, 1);
    } else {
		//If no Displacement is present, connect the height (if any)
		//Bump
		string $attrName = $prefix+$sbsHeightStr+$postfixChannelName;
		if ( `attributeQuery -exists -node $nodeName $attrName` == true)
		{
			ChannelTreeViewButtonClickCommand( $nodeName, $sbsHeightStr, 1);
		}
    }
    */
   
	//Always connect the diffuse at the end, as if the substanceTex.outColor is connected to a material, it will replace it with a substance output
	//If it does so, the others shaders may want to create a new shader
	//Diffuse
    string $attrName = $prefix+"Diffuse"+$postfixChannelName;
    if ( `attributeQuery -exists -node $nodeName $attrName` == true) {
        ChannelTreeViewButtonClickCommand( $nodeName, "Diffuse", 1);
    }
   
    // rename of newly created nodes
    sbs_RearrangeHypershadeGraph();
	select -r $nodeName;
	sbs_RearrangeHypershadeGraph();
}

global proc int sbsAreAlreadyConnected(string $nodeWithAttributeName, string $otherNode) {
	string $connectedOutputs[] = `listConnections $nodeWithAttributeName`; 
	int $found = 0;
	for ($connectedOutput in $connectedOutputs) {
		if ($connectedOutput == $otherNode) {
			return 1;
		}
	}
	
	return 0;
}

global proc int sbsConnectShadingNetwork(string $substanceTextureNode, string $substanceOutputNode, string $channelName) {
	string $prefix					= "outputdyn_";	
	string $postfixChannelName		= "_Name";
	string $postfixChannelColor		= "_Color";
	string $postfixChannelAlpha		= "_Alpha";
	string $postfixChannelUVCoords	= "_uvCoord";

	if (!`objExists $substanceOutputNode` || !`attributeQuery -exists -node $substanceOutputNode "uv"`)
		return 0;

	//Connect color and alpha attributes
	if ( `attributeQuery -exists -node $substanceTextureNode ($prefix+$channelName+$postfixChannelColor)` == true) {
		string $attr = ($substanceTextureNode+"."+$prefix+$channelName+$postfixChannelColor);
		
		if (`attributeQuery -exists -node $substanceTextureNode ($prefix+$channelName+$postfixChannelColor)` == true) {
			int $alreadyConnected = sbsAreAlreadyConnected($attr, $substanceOutputNode);
			if (!$alreadyConnected && (`attributeQuery -exists -node $substanceOutputNode "inColor"` == true)) {
				connectAttr -f $attr ($substanceOutputNode+".inColor");
			}
		}
	}
	
	if ( `attributeQuery -exists -node $substanceTextureNode ($prefix+$channelName+$postfixChannelAlpha)` == true) {
		$attr = $substanceTextureNode+"."+$prefix+$channelName+$postfixChannelAlpha;
		int $alreadyConnected = sbsAreAlreadyConnected($attr, $substanceOutputNode);
		if (!$alreadyConnected && (`attributeQuery -exists -node $substanceOutputNode "inAlpha"` == true)) {
			connectAttr -f $attr ($substanceOutputNode+".inAlpha");
		}
	}
	
	//Connect UVs
	//connectAttr -f ($substanceTextureNode+"."+$prefix+$channelName+$postfixChannelUVCoords) ($substanceOutputNode+".inUVCoord");
	
	// connect place2DTexture to substance output node// 
	//Get place2DTextureNode
	string $place2DTextureNode[]	= `listConnections ($substanceTextureNode+".uv")`;
	string $oldPlace2DTextureNode[] = `listConnections ($substanceOutputNode+".uv")`;
	
	if (size($oldPlace2DTextureNode)) {	
		//Disconnect old place2Dtexture node
		if (size($place2DTextureNode)) {
			if ($place2DTextureNode[0] != $oldPlace2DTextureNode[0]) {
				disconnectAttr ($oldPlace2DTextureNode[0]+".outUV") ($substanceOutputNode+".uvCoord");
				disconnectAttr ($oldPlace2DTextureNode[0]+".outUvFilterSize") ($substanceOutputNode+".uvFilterSize");
			}
		}
	}
	
	if ( size($place2DTextureNode)) {
		sbsDebugPrint("connecting outUV of "+$place2DTextureNode[0]);
		
		if (size($oldPlace2DTextureNode)) {
			//Check that they are not already connected
			if ($oldPlace2DTextureNode[0] != $place2DTextureNode[0]) {
				//Connect it to the substance output node				
				connectAttr ($place2DTextureNode[0]+".outUV") ($substanceOutputNode+".uv");
				connectAttr ($place2DTextureNode[0]+".outUvFilterSize") ($substanceOutputNode+".uvFilterSize");
			} else {
				//Do nothing, they are already connected
			}	
		} else {
			//Connect it to the substance output node
			connectAttr ($place2DTextureNode[0]+".outUV") ($substanceOutputNode+".uv");
			connectAttr ($place2DTextureNode[0]+".outUvFilterSize") ($substanceOutputNode+".uvFilterSize");
		}
	}
	
	if (size($oldPlace2DTextureNode)) {	
		//Delete old place2Dtexture node
		if (size($place2DTextureNode)) {
			if ($place2DTextureNode[0] != $oldPlace2DTextureNode[0]) {
				delete $oldPlace2DTextureNode[0]; //delete it
			}
		}
	}
	
	//Connect channel name
	if ( `attributeQuery -exists -node $substanceTextureNode ($prefix+$channelName+$postfixChannelName)` == true) {
		$attr = ($substanceTextureNode+"."+$prefix+$channelName+$postfixChannelName);
		int $alreadyConnected = sbsAreAlreadyConnected($attr, $substanceOutputNode);
		if (!$alreadyConnected && (`attributeQuery -exists -node $substanceOutputNode "channelName"` == true)) {
			connectAttr -f $attr ($substanceOutputNode+".channelName");
		}
	}	
	return 1;
}

global proc reconnectShadingNetwork(string $nodeName, string $channelsNames[]) {
	//sbsDebugPrint("size of $channelsNames = "+size($channelsNames));
	
	//Connect all channels attributes if the node already exist
	string $curChannel = "";
	string $material = "";
	for ($curChannel in $channelsNames) {
		string $outputNodeName	= $curChannel+"_"+$nodeName;
		
		if (sbsConnectShadingNetwork($nodeName, $outputNodeName, $curChannel))
		{
			//Fill our material node if not yet done
			if ($material == "") {
				string $connectedNodes[] = `listConnections $outputNodeName`;
				if (size($connectedNodes)) {
					string $matNode = "";
					for ($matNode in $connectedNodes) {
						if (sbs_IsMaterialNode($matNode)) {
							$material = $matNode; //Found
							break;
						}
					}
				}
			}
		}
	}
	
	if ($material != "") {
		//Check if there is an unused bump node.
		if ( `attributeQuery -exists -node $material "normalCamera"` == true) {
			string $source = `connectionInfo -sourceFromDestination ($material+".normalCamera")`;
			if ($source != "") {
				string $bump2dNodes[] = `listConnections ($material+".normalCamera")`;
				for ($bump in $bump2dNodes) {
					string $connections[] = `listConnections ($bump+".bumpValue")`;
					if (size($connections)==0)
						delete $bump;
				}
			}
		}
	}
}


